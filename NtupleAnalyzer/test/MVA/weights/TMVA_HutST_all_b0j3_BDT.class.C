// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Oct  7 21:59:59 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 638409
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 12
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [14.2605009079,500]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.777953624725,0.752784073353]
LepCharge                     LepCharge                     LepCharge                     LepCharge                                                       'I'    [-1,1]
HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB                                              'D'    [-7.39814424515,7.9473118782]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [75.9286422729,500]
TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB                                              'D'    [0.041234549135,1000]
TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB                                             'D'    [-9.81275558472,9.05405521393]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.367354184389,5.51802539825]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.0221648290753,11.0598487854]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [-10,0.799997031689]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [-10,0.797264277935]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [-10,0.799998581409]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 12 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "MVA_TOPHLEPBB", "LepCharge", "HiggsEta_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "TopLepPt_TOPHLEPBB", "TopLepEta_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'I';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[12];
   double fVmax[12];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[12];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.450699338658512);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.285713, 0, 1, 0.74319,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355075,-99) , 
9, 0.285711, 0, 0, 0.491149,-99) , 
5, 142.892, 0, 0, 0.618497,-99) , 
NN(
0, 
0, 
-1, 0.285711, 0, -1, 0.198168,-99) , 
2, 0, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.330485);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 143.031, 0, 1, 0.686835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406184,-99) , 
5, 190.51, 0, 0, 0.463865,-99) , 
11, 0.285713, 0, 0, 0.555745,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285742,-99) , 
9, 0.555099, 0, 0, 0.377161,-99) , 
NN(
0, 
0, 
-1, 107.891, 0, -1, 0.156713,-99) , 
9, 0.285711, 0, 0, 0.279471,-99) , 
2, 0, 0, 0, 0.481309,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.238117);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.715897,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557285,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413313,-99) , 
5, 95.2754, 0, 0, 0.512438,-99) , 
10, 0.282991, 0, 0, 0.545473,-99) , 
NN(
0, 
0, 
-1, 0.285706, 0, -1, 0.310006,-99) , 
2, 0, 0, 0, 0.483459,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.228377);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717572,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431367,-99) , 
11, 0.5551, 0, 0, 0.499729,-99) , 
5, 190.595, 0, 0, 0.564107,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420798,-99) , 
8, 3.18879, 1, 0, 0.47273,-99) , 
NN(
0, 
0, 
-1, 0.285711, 0, -1, 0.282715,-99) , 
2, 0, 0, 0, 0.421759,-99) , 
11, 0.285713, 0, 0, 0.477573,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.171316);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 142.983, 0, 1, 0.646678,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49392,-99) , 
5, 190.64, 0, 0, 0.536746,-99) , 
NN(
0, 
0, 
-1, 0, 0, -1, 0.408245,-99) , 
11, 0.285713, 0, 0, 0.458527,-99) , 
10, 0.283109, 0, 0, 0.487376,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.171242);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.700528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458491,-99) , 
0, 106.782, 0, 0, 0.521105,-99) , 
8, 2.65903, 1, 0, 0.540546,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372953,-99) , 
5, 95.3707, 0, 0, 0.493472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.298636,-99) , 
9, 0.285711, 0, 0, 0.41559,-99) , 
2, 0, 0, 0, 0.509041,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.133185);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.67755, 0, 1, 0.562108,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466064,-99) , 
3, 1.39909, 0, 0, 0.496757,-99) , 
NN(
0, 
0, 
-1, 0.285711, 0, -1, 0.364892,-99) , 
2, 0, 0, 0, 0.463131,-99) , 
11, 0.285713, 0, 0, 0.501914,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.179974);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 0, 1, 0.629472,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420646,-99) , 
5, 142.892, 0, 0, 0.481569,-99) , 
9, 0.579589, 0, 0, 0.537362,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414385,-99) , 
5, 142.973, 1, 0, 0.479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341876,-99) , 
2, 0, 0, 0, 0.444843,-99) , 
9, 0.285711, 0, 0, 0.500914,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.105196);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627269,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576886,-99) , 
NN(
0, 
0, 
-1, 0.285711, 0, -1, 0.462431,-99) , 
5, 238.127, 0, 0, 0.481624,-99) , 
8, 2.65018, 1, 0, 0.49607,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.11963);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.693875, 0, 1, 0.585247,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444144,-99) , 
8, 3.17999, 1, 0, 0.471572,-99) , 
9, 0.48163, 0, 0, 0.536616,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554651,-99) , 
NN(
0, 
0, 
-1, 0, 0, -1, 0.448675,-99) , 
3, -1.62855, 1, 0, 0.467008,-99) , 
9, 0.285711, 0, 0, 0.509246,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0724182);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.65903, 1, 1, 0.526118,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440686,-99) , 
11, 0.2857, 0, 0, 0.476352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366124,-99) , 
0, 84.3958, 0, 0, 0.452767,-99) , 
2, 0, 0, 0, 0.507899,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.086648);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567058,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486829,-99) , 
8, 2.65466, 1, 0, 0.501282,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363448,-99) , 
5, 82.3119, 0, 0, 0.421316,-99) , 
7, 2.68794, 1, 0, 0.48452,-99) , 
0, 222.435, 0, 0, 0.495992,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0811);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.07368, 1, 1, 0.564328,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482038,-99) , 
3, 1.61427, 0, 0, 0.502263,-99) , 
3, -1.55226, 1, 0, 0.515301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41729,-99) , 
4, 136.51, 0, 0, 0.506123,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0505374);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621438,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499284,-99) , 
10, 0.283109, 0, 0, 0.511473,-99) , 
8, 2.60099, 1, 0, 0.519668,-99) , 
NN(
0, 
0, 
-1, -1.72698, 1, -1, 0.436989,-99) , 
5, 47.6583, 0, 0, 0.510954,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.102759);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.281982, 0, 1, 0.569449,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463832,-99) , 
1, 0.035481, 1, 0, 0.491655,-99) , 
0, 83.6519, 0, 0, 0.542665,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560811,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418222,-99) , 
5, 68.1536, 0, 0, 0.461369,-99) , 
5, 142.973, 0, 0, 0.492407,-99) , 
7, 2.08424, 1, 0, 0.518848,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0673299);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.67755, 0, 1, 0.540239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482404,-99) , 
3, -1.55706, 1, 0, 0.496108,-99) , 
11, 0.285713, 0, 0, 0.513444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433647,-99) , 
4, 136.51, 0, 0, 0.506009,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0720183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59686,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49912,-99) , 
5, 95.2754, 1, 0, 0.515241,-99) , 
10, 0.281982, 0, 0, 0.527614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536158,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443462,-99) , 
4, 206.094, 0, 0, 0.460343,-99) , 
5, 142.973, 0, 0, 0.483934,-99) , 
7, 2.08424, 1, 0, 0.506908,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0876703);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.58007, 1, 1, 0.547215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46869,-99) , 
0, 60.5214, 0, 0, 0.534612,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529163,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449551,-99) , 
4, 223.25, 0, 0, 0.467114,-99) , 
0, 202.469, 0, 0, 0.484959,-99) , 
7, 2.08424, 1, 0, 0.511088,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0653715);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577441,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480889,-99) , 
8, 2.65018, 1, 0, 0.489501,-99) , 
3, 2.09361, 0, 0, 0.497615,-99) , 
1, 0.388323, 0, 0, 0.504775,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0590579);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499923,-99) , 
5, 96.2253, 0, 0, 0.55937,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493265,-99) , 
3, -1.83446, 1, 0, 0.504651,-99) , 
8, 3.02562, 1, 0, 0.52136,-99) , 
NN(
0, 
0, 
-1, 183.867, 0, -1, 0.471347,-99) , 
8, 4.227, 1, 0, 0.512284,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0657219);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.679521, 0, 1, 0.530977,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483578,-99) , 
5, 143.789, 0, 0, 0.514233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450143,-99) , 
8, 3.56303, 1, 0, 0.489174,-99) , 
2, 0, 0, 0, 0.520643,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0606027);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561619,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486274,-99) , 
7, 2.82833, 1, 0, 0.525447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475406,-99) , 
8, 3.08021, 1, 0, 0.490765,-99) , 
3, 0.63334, 0, 0, 0.504872,-99) , 
1, 0.388323, 0, 0, 0.509948,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0320098);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -2.28299, 1, 1, 0.513531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459732,-99) , 
4, 136.51, 0, 0, 0.508565,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0506896);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543356,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496455,-99) , 
3, -1.30393, 1, 0, 0.512073,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462517,-99) , 
0, 202.469, 0, 0, 0.47841,-99) , 
7, 2.05441, 1, 0, 0.496965,-99) , 
3, 2.10142, 0, 0, 0.502041,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0424512);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570183,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489939,-99) , 
1, 0.245615, 0, 0, 0.513358,-99) , 
5, 143.979, 1, 0, 0.531111,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553447,-99) , 
NN(
0, 
0, 
-1, 4.227, 1, -1, 0.490193,-99) , 
3, -2.28299, 1, 0, 0.49615,-99) , 
7, 1.34843, 1, 0, 0.505863,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0403621);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.09478, 1, 1, 0.549285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498963,-99) , 
3, -1.80469, 1, 0, 0.509116,-99) , 
3, 1.2907, 0, 0, 0.518899,-99) , 
NN(
0, 
0, 
-1, -1.72698, 0, -1, 0.479857,-99) , 
8, 4.227, 1, 0, 0.511801,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0572707);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.8667, 0, 1, 0.524841,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480378,-99) , 
6, 0.513909, 1, 0, 0.512309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423063,-99) , 
5, 47.7483, 0, 0, 0.494358,-99) , 
7, 2.57478, 1, 0, 0.515565,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0295831);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491257,-99) , 
7, 2.31489, 1, 0, 0.53454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536573,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438867,-99) , 
10, -9.48585, 0, 0, 0.495913,-99) , 
3, 1.97745, 0, 0, 0.50101,-99) , 
6, 1.8667, 0, 0, 0.505654,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0423926);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.07538, 1, 1, 0.534164,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529209,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48438,-99) , 
6, -2.58263, 1, 0, 0.489799,-99) , 
3, 1.97745, 0, 0, 0.494735,-99) , 
6, 1.8667, 0, 0, 0.500191,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0562885);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594218,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477489,-99) , 
5, 78.895, 0, 0, 0.544289,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482454,-99) , 
8, 3.29259, 0, 0, 0.503156,-99) , 
8, 2.82539, 1, 0, 0.510247,-99) , 
NN(
0, 
0, 
-1, -1.72698, 0, -1, 0.475045,-99) , 
8, 4.227, 1, 0, 0.503839,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0513882);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533205,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487615,-99) , 
7, 2.09404, 1, 0, 0.50827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455871,-99) , 
5, 192.777, 1, 0, 0.50173,-99) , 
5, 238.127, 0, 0, 0.506602,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0401141);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566423,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497633,-99) , 
5, 95.3707, 1, 0, 0.509203,-99) , 
3, -2.28299, 1, 0, 0.513745,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490535,-99) , 
9, 0.28571, 1, 0, 0.503645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437411,-99) , 
5, 110.812, 0, 0, 0.478334,-99) , 
0, 83.6519, 0, 0, 0.506598,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.051389);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.677548, 0, 1, 0.527344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482469,-99) , 
5, 95.4212, 1, 0, 0.499586,-99) , 
9, 0.285711, 0, 0, 0.516507,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495315,-99) , 
7, 0.809784, 0, 0, 0.505392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447306,-99) , 
5, 110.812, 0, 0, 0.483221,-99) , 
0, 83.6519, 0, 0, 0.509792,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0347826);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.31489, 1, 1, 0.537011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491884,-99) , 
4, 188.437, 1, 0, 0.504706,-99) , 
6, 1.8667, 0, 0, 0.509273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472501,-99) , 
4, 136.51, 0, 0, 0.505887,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.035397);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491903,-99) , 
1, 0.179372, 0, 0, 0.509014,-99) , 
8, 3.07158, 1, 0, 0.523662,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530118,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496342,-99) , 
0, 222.766, 0, 0, 0.503253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44349,-99) , 
0, 84.1483, 0, 0, 0.498782,-99) , 
7, 1.34843, 1, 0, 0.50569,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0452982);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536408,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493884,-99) , 
11, 0.677549, 0, 0, 0.521749,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472772,-99) , 
7, 2.54545, 1, 0, 0.494896,-99) , 
11, 0.285712, 0, 0, 0.505645,-99) , 
4, 318.255, 0, 0, 0.509401,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0598911);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.718367, 0, 1, 0.605497,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460421,-99) , 
11, 0.399998, 0, 0, 0.496655,-99) , 
11, 0.62857, 0, 0, 0.525227,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530218,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471433,-99) , 
6, -0.00622041, 1, 0, 0.489096,-99) , 
4, 257.674, 0, 0, 0.497695,-99) , 
11, 0.285713, 0, 0, 0.508556,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0556031);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608837,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483139,-99) , 
8, 3.05719, 1, 0, 0.498463,-99) , 
11, 0.67755, 0, 0, 0.519439,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48066,-99) , 
5, 142.998, 1, 0, 0.499498,-99) , 
NN(
0, 
0, 
-1, 0.28571, 1, -1, 0.467664,-99) , 
0, 83.6519, 0, 0, 0.492963,-99) , 
11, 0.285713, 0, 0, 0.503395,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0581436);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.718367, 0, 1, 0.583011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47241,-99) , 
4, 201.923, 1, 0, 0.500638,-99) , 
11, 0.62857, 0, 0, 0.522138,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492251,-99) , 
5, 142.998, 1, 0, 0.515147,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475058,-99) , 
7, 1.34417, 1, 0, 0.484666,-99) , 
4, 217.286, 0, 0, 0.494753,-99) , 
11, 0.285713, 0, 0, 0.505536,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0369057);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490787,-99) , 
4, 261.539, 0, 0, 0.496678,-99) , 
1, -0.160747, 1, 0, 0.502259,-99) , 
5, 238.127, 0, 0, 0.506716,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0386241);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545703,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496805,-99) , 
9, 0.693548, 0, 0, 0.510177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467675,-99) , 
10, -9.48584, 0, 0, 0.506444,-99) , 
3, -2.28299, 1, 0, 0.509241,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0368258);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.901645, 0, 1, 0.518753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485024,-99) , 
8, 4.7526, 1, 0, 0.515639,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0268637);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534468,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535801,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460722,-99) , 
10, -9.48585, 0, 0, 0.500186,-99) , 
6, 1.8667, 0, 0, 0.504906,-99) , 
3, 2.10142, 0, 0, 0.508139,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0364907);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530921,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494444,-99) , 
3, 0.672909, 0, 0, 0.505767,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441758,-99) , 
0, 107.485, 0, 0, 0.480436,-99) , 
2, 0, 0, 0, 0.499544,-99) , 
1, 0.388323, 0, 0, 0.502329,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0473012);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.0642, 1, 1, 0.523778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478496,-99) , 
3, 0.887181, 0, 0, 0.499695,-99) , 
3, -0.774038, 1, 0, 0.508311,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489653,-99) , 
7, 2.07805, 1, 0, 0.509377,-99) , 
NN(
0, 
0, 
-1, 1.37511, 1, -1, 0.452375,-99) , 
0, 107.485, 0, 0, 0.484928,-99) , 
2, 0, 0, 0, 0.502508,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0293851);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498888,-99) , 
7, 2.07538, 1, 0, 0.520679,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513191,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487519,-99) , 
3, -1.62855, 1, 0, 0.493791,-99) , 
0, 199.304, 0, 0, 0.497103,-99) , 
6, 1.8667, 0, 0, 0.50036,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0276567);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.31489, 1, 1, 0.521667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520871,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488103,-99) , 
6, -1.4703, 1, 0, 0.496346,-99) , 
3, 1.97745, 0, 0, 0.499423,-99) , 
6, 1.8667, 0, 0, 0.502495,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0418277);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568247,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492944,-99) , 
5, 143.792, 0, 0, 0.521242,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473171,-99) , 
8, 3.19725, 0, 0, 0.499777,-99) , 
8, 3.02562, 1, 0, 0.506304,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460103,-99) , 
6, -1.72698, 0, 0, 0.483616,-99) , 
8, 4.227, 1, 0, 0.502166,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0382456);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486157,-99) , 
5, 96.2253, 0, 0, 0.523869,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490081,-99) , 
1, 0.338681, 0, 0, 0.495991,-99) , 
8, 3.02562, 1, 0, 0.504465,-99) , 
NN(
0, 
0, 
-1, 183.867, 0, -1, 0.482922,-99) , 
8, 4.227, 1, 0, 0.500536,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0343885);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481318,-99) , 
11, 0.464138, 0, 0, 0.50099,-99) , 
11, 0.702039, 0, 0, 0.514744,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528867,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48195,-99) , 
2, 0, 0, 0, 0.496539,-99) , 
8, 2.65466, 1, 0, 0.499719,-99) , 
11, 0.285713, 0, 0, 0.505643,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0423958);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580937,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477553,-99) , 
8, 3.56303, 1, 0, 0.50149,-99) , 
11, 0.702039, 0, 0, 0.51384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487172,-99) , 
0, 106.782, 0, 0, 0.503554,-99) , 
NN(
0, 
0, 
-1, 0.0367804, 0, -1, 0.48588,-99) , 
7, 2.05441, 1, 0, 0.495025,-99) , 
11, 0.285713, 0, 0, 0.50244,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0477113);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.36122, 1, 1, 0.517804,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459544,-99) , 
4, 205.748, 1, 0, 0.485588,-99) , 
5, 190.51, 1, 0, 0.508564,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488949,-99) , 
7, 1.80661, 1, 0, 0.508643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463125,-99) , 
8, 3.57907, 1, 0, 0.492503,-99) , 
4, 156.704, 0, 0, 0.504694,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0269589);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479006,-99) , 
7, 0.671021, 1, 0, 0.518364,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483674,-99) , 
3, -1.50563, 0, 0, 0.500946,-99) , 
NN(
0, 
0, 
-1, 1.95055, 0, -1, 0.481825,-99) , 
1, 0.293779, 1, 0, 0.497575,-99) , 
7, 0.857894, 1, 0, 0.500225,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0432322);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526176,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488305,-99) , 
9, 0.693548, 0, 0, 0.499313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466,-99) , 
10, -9.48584, 0, 0, 0.496387,-99) , 
3, -2.28299, 1, 0, 0.498503,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0272993);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494323,-99) , 
7, 0.671021, 1, 0, 0.526131,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498771,-99) , 
5, 95.3707, 1, 0, 0.506294,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468816,-99) , 
5, 105.44, 0, 0, 0.490407,-99) , 
0, 95.1742, 0, 0, 0.502696,-99) , 
7, 0.857894, 1, 0, 0.505683,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0332566);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526342,-99) , 
NN(
NN(
0, 
0, 
-1, 95.2754, 1, 1, 0.512035,-99) , 
NN(
0, 
0, 
-1, 54.9198, 0, -1, 0.473469,-99) , 
7, 2.68794, 1, 0, 0.504031,-99) , 
0, 222.435, 0, 0, 0.507148,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0189176);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518044,-99) , 
NN(
NN(
0, 
0, 
-1, 83.6112, 0, 1, 0.518369,-99) , 
NN(
0, 
0, 
-1, 190.51, 1, -1, 0.494462,-99) , 
7, 1.00024, 1, 0, 0.499168,-99) , 
0, 222.435, 0, 0, 0.501805,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0202936);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.10142, 0, 1, 0.507258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485937,-99) , 
11, 0.285706, 0, 0, 0.498839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464521,-99) , 
4, 162.18, 0, 0, 0.489211,-99) , 
0, 83.6519, 0, 0, 0.503611,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0242747);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518402,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518124,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491212,-99) , 
6, -2.58263, 1, 0, 0.494649,-99) , 
6, 1.8667, 0, 0, 0.497759,-99) , 
3, 2.10142, 0, 0, 0.500019,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.022309);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538137,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483833,-99) , 
7, 0.741098, 1, 0, 0.4991,-99) , 
5, 143.979, 1, 0, 0.511299,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49875,-99) , 
8, 2.60099, 1, 0, 0.501294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468613,-99) , 
0, 84.1483, 0, 0, 0.498868,-99) , 
7, 1.34843, 1, 0, 0.502318,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0162268);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.857894, 1, 1, 0.507388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484112,-99) , 
0, 60.5214, 0, 0, 0.505405,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0296382);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518257,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493462,-99) , 
9, 0.693548, 0, 0, 0.502467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481435,-99) , 
10, -9.48584, 0, 0, 0.500464,-99) , 
1, 0.388323, 0, 0, 0.50204,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0287942);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518936,-99) , 
NN(
NN(
0, 
0, 
-1, 95.2754, 1, 1, 0.509754,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444161,-99) , 
5, 54.9198, 0, 0, 0.485711,-99) , 
7, 2.68794, 1, 0, 0.504763,-99) , 
0, 222.435, 0, 0, 0.506744,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0259293);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517953,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494685,-99) , 
9, 0.693548, 0, 0, 0.501745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472731,-99) , 
10, -9.48584, 0, 0, 0.499199,-99) , 
3, -2.28299, 1, 0, 0.500532,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0274674);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51664,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529222,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49891,-99) , 
5, 95.2754, 1, 0, 0.507172,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464836,-99) , 
5, 82.3119, 0, 0, 0.486717,-99) , 
7, 2.68794, 1, 0, 0.502928,-99) , 
0, 222.435, 0, 0, 0.504845,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.027659);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49646,-99) , 
0, 67.9238, 0, 0, 0.53241,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470493,-99) , 
7, 0.787816, 1, 0, 0.497031,-99) , 
5, 191.536, 1, 0, 0.516303,-99) , 
NN(
NN(
0, 
0, 
-1, 2.10142, 0, 1, 0.504746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474262,-99) , 
0, 84.1483, 0, 0, 0.50248,-99) , 
7, 1.34843, 1, 0, 0.506316,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0400643);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 67.9238, 0, 1, 0.532864,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477389,-99) , 
7, 0.787816, 1, 0, 0.497866,-99) , 
5, 191.536, 1, 0, 0.516929,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478042,-99) , 
3, -1.37493, 0, 0, 0.509611,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522474,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486563,-99) , 
3, 2.10142, 0, 0, 0.491726,-99) , 
6, -1.72698, 1, 0, 0.496593,-99) , 
7, 1.34843, 1, 0, 0.502233,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0179135);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540348,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525695,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499663,-99) , 
8, 2.93981, 1, 0, 0.503956,-99) , 
8, 2.42493, 1, 0, 0.506771,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472192,-99) , 
6, -1.72698, 0, 0, 0.490431,-99) , 
8, 4.227, 1, 0, 0.503793,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0397995);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487579,-99) , 
10, 0.130568, 0, 0, 0.511767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483181,-99) , 
10, -9.48585, 0, 0, 0.509195,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476659,-99) , 
6, -1.72698, 0, 0, 0.490136,-99) , 
8, 4.227, 1, 0, 0.505721,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0184816);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.42493, 1, 1, 0.508602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478123,-99) , 
7, 2.56728, 0, 0, 0.489481,-99) , 
8, 4.227, 1, 0, 0.505117,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0457262);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493493,-99) , 
5, 142.973, 1, 0, 0.516047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490626,-99) , 
2, 0, 0, 0, 0.509989,-99) , 
NN(
NN(
0, 
0, 
-1, 0.751018, 0, 1, 0.51509,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449572,-99) , 
2, 0, 1, 0, 0.464963,-99) , 
9, 0.45714, 0, 0, 0.495757,-99) , 
9, 0.285711, 1, 0, 0.501367,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0368035);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.555101, 0, 1, 0.524806,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53087,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496253,-99) , 
0, 83.6519, 1, 0, 0.503821,-99) , 
11, 0.285713, 0, 0, 0.512169,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558692,-99) , 
NN(
0, 
0, 
-1, 0.396499, 0, -1, 0.4839,-99) , 
9, 0.751018, 0, 0, 0.49101,-99) , 
9, 0.285711, 1, 0, 0.499352,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0285361);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522722,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491464,-99) , 
0, 89.1457, 0, 0, 0.51517,-99) , 
NN(
0, 
0, 
-1, 0.283109, 1, -1, 0.493285,-99) , 
7, 1.6049, 1, 0, 0.500186,-99) , 
5, 238.127, 0, 0, 0.503654,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0345076);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522161,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491191,-99) , 
5, 190.51, 1, 0, 0.508006,-99) , 
7, 3.03405, 0, 0, 0.510056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464568,-99) , 
9, 0.6526, 0, 0, 0.490279,-99) , 
10, 0.283109, 1, 0, 0.507153,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0313239);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521759,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495001,-99) , 
0, 81.3396, 0, 0, 0.517083,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489368,-99) , 
5, 158.761, 0, 0, 0.495019,-99) , 
7, 1.36033, 1, 0, 0.50033,-99) , 
5, 238.127, 0, 0, 0.503626,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0306575);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531869,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496582,-99) , 
8, 2.96939, 1, 0, 0.507806,-99) , 
8, 4.14828, 0, 0, 0.512828,-99) , 
NN(
NN(
0, 
0, 
-1, 142.998, 0, 1, 0.532173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475028,-99) , 
9, 0.397664, 0, 0, 0.49304,-99) , 
9, 0.677548, 0, 0, 0.501092,-99) , 
9, 0.285711, 1, 0, 0.505721,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0293681);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 176.898, 0, 1, 0.52728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499337,-99) , 
7, 2.54969, 0, 0, 0.5082,-99) , 
6, 0.893998, 0, 0, 0.514231,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496052,-99) , 
9, 0.677548, 0, 0, 0.504194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466078,-99) , 
8, 4.23063, 1, 0, 0.497487,-99) , 
9, 0.285711, 1, 0, 0.504091,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0231461);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 274.864, 0, 1, 0.511838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485408,-99) , 
5, 48.2582, 0, 0, 0.509783,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4871,-99) , 
11, 0.285704, 0, 0, 0.493579,-99) , 
8, 4.227, 1, 0, 0.506829,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0313791);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475841,-99) , 
3, -1.32697, 0, 0, 0.513069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517118,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494878,-99) , 
3, -0.82693, 1, 0, 0.50226,-99) , 
6, -1.49882, 1, 0, 0.50561,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458912,-99) , 
0, 107.485, 0, 0, 0.488308,-99) , 
10, 0.283109, 1, 0, 0.503074,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0216299);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.42493, 1, 1, 0.508921,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481319,-99) , 
1, 0.198141, 1, 0, 0.494776,-99) , 
8, 4.227, 1, 0, 0.50632,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463221,-99) , 
10, 0.381046, 0, 0, 0.487115,-99) , 
10, 0.283109, 1, 0, 0.503506,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0221045);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531838,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468802,-99) , 
6, -1.47991, 0, 0, 0.501342,-99) , 
7, 0.647662, 1, 0, 0.508278,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496574,-99) , 
7, 3.10981, 0, 0, 0.499088,-99) , 
NN(
0, 
0, 
-1, -0.376341, 1, -1, 0.478683,-99) , 
10, 0.283109, 1, 0, 0.496123,-99) , 
7, 1.34843, 1, 0, 0.499488,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0319608);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543928,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473439,-99) , 
10, -9.48587, 0, 0, 0.502247,-99) , 
1, 0.0585745, 1, 0, 0.506131,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48537,-99) , 
7, 2.09404, 1, 0, 0.504802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471229,-99) , 
5, 190.61, 1, 0, 0.494461,-99) , 
1, 0.0238614, 0, 0, 0.501467,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0195339);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514962,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495616,-99) , 
0, 176.174, 0, 0, 0.499829,-99) , 
NN(
0, 
0, 
-1, 107.485, 0, -1, 0.477551,-99) , 
10, 0.283109, 1, 0, 0.49657,-99) , 
4, 318.255, 0, 0, 0.498799,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.026558);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.653278, 1, 1, 0.514825,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482747,-99) , 
1, 0.113143, 0, 0, 0.498735,-99) , 
3, -0.186147, 0, 0, 0.507493,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496784,-99) , 
3, -1.83446, 1, 0, 0.502154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4712,-99) , 
8, 4.23063, 1, 0, 0.496703,-99) , 
9, 0.285711, 1, 0, 0.500959,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0129117);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499044,-99) , 
0, 199.304, 0, 0, 0.502317,-99) , 
8, 2.42493, 1, 0, 0.504886,-99) , 
NN(
0, 
0, 
-1, 183.867, 0, -1, 0.493012,-99) , 
8, 4.227, 1, 0, 0.502719,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.018417);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517365,-99) , 
NN(
NN(
0, 
0, 
-1, 190.586, 0, 1, 0.511907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483924,-99) , 
5, 190.51, 1, 0, 0.497195,-99) , 
4, 170.166, 1, 0, 0.503392,-99) , 
4, 358.643, 0, 0, 0.504676,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0128015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528055,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498258,-99) , 
6, 1.43647, 0, 0, 0.501378,-99) , 
8, 2.42493, 1, 0, 0.50344,-99) , 
NN(
0, 
0, 
-1, 183.867, 0, -1, 0.492097,-99) , 
8, 4.227, 1, 0, 0.50137,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0166776);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51316,-99) , 
NN(
NN(
0, 
0, 
-1, -1.85382, 1, 1, 0.505194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478416,-99) , 
7, 3.07232, 1, 0, 0.501487,-99) , 
5, 238.127, 0, 0, 0.50328,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0326485);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499977,-99) , 
1, 0.111227, 1, 0, 0.511815,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477776,-99) , 
5, 143.148, 1, 0, 0.489571,-99) , 
4, 197.092, 1, 0, 0.503477,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489482,-99) , 
4, 201.923, 0, 0, 0.50416,-99) , 
NN(
0, 
0, 
-1, 1.37511, 1, -1, 0.469305,-99) , 
2, 0, 0, 0, 0.495175,-99) , 
0, 106.782, 0, 0, 0.500088,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0321525);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 182.589, 1, 1, 0.525719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484493,-99) , 
5, 72.6005, 0, 0, 0.500855,-99) , 
5, 190.51, 0, 0, 0.506734,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487529,-99) , 
7, 2.09404, 1, 0, 0.502158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477909,-99) , 
5, 190.61, 1, 0, 0.494691,-99) , 
1, 0.0238614, 0, 0, 0.501925,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0295695);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.111227, 1, 1, 0.512604,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485639,-99) , 
2, 0, 1, 0, 0.49273,-99) , 
4, 197.092, 1, 0, 0.505156,-99) , 
NN(
NN(
0, 
0, 
-1, 0.49659, 0, 1, 0.513466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479529,-99) , 
4, 261.539, 0, 0, 0.486657,-99) , 
0, 93.5647, 0, 0, 0.494664,-99) , 
0, 106.782, 0, 0, 0.500873,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.027092);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510222,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493763,-99) , 
5, 56.7281, 1, 0, 0.5007,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461481,-99) , 
5, 79.4438, 0, 0, 0.485904,-99) , 
7, 2.82775, 1, 0, 0.497263,-99) , 
5, 238.127, 0, 0, 0.499252,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0300346);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496943,-99) , 
7, 1.84251, 1, 0, 0.509158,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492117,-99) , 
8, 2.83994, 1, 0, 0.499768,-99) , 
5, 95.2754, 1, 0, 0.5028,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474506,-99) , 
5, 142.983, 0, 0, 0.49312,-99) , 
10, 0.283109, 1, 0, 0.501382,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0258086);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 142.892, 0, 1, 0.512331,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548918,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494654,-99) , 
5, 95.7613, 1, 0, 0.502905,-99) , 
7, 1.82191, 0, 0, 0.508263,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472586,-99) , 
0, 107.485, 0, 0, 0.493883,-99) , 
10, 0.283109, 1, 0, 0.506157,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0198241);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.679043, 1, 1, 0.516364,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492216,-99) , 
1, 0.28974, 1, 0, 0.50411,-99) , 
7, 1.09463, 1, 0, 0.506536,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474604,-99) , 
10, 0.381046, 0, 0, 0.492898,-99) , 
10, 0.283109, 1, 0, 0.504539,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0262528);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 163.444, 1, 1, 0.515728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481562,-99) , 
4, 212.604, 0, 0, 0.49539,-99) , 
4, 182.352, 1, 0, 0.508558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487317,-99) , 
5, 190.51, 1, 0, 0.505155,-99) , 
NN(
0, 
0, 
-1, 117.46, 0, -1, 0.490124,-99) , 
7, 2.08424, 1, 0, 0.497461,-99) , 
1, 0.169646, 0, 0, 0.501452,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0270029);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51267,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481785,-99) , 
3, -1.37493, 0, 0, 0.510446,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489888,-99) , 
7, 1.34914, 1, 0, 0.496327,-99) , 
6, -1.72698, 1, 0, 0.499913,-99) , 
4, 318.255, 0, 0, 0.501459,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.018176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 95.5668, 1, 1, 0.509757,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503285,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465965,-99) , 
8, 2.65903, 0, 0, 0.498398,-99) , 
0, 123.304, 0, 0, 0.503741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484249,-99) , 
0, 60.5214, 0, 0, 0.502069,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0171938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495691,-99) , 
3, -1.83446, 1, 0, 0.498682,-99) , 
8, 2.42493, 1, 0, 0.500939,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478679,-99) , 
7, 2.56728, 0, 0, 0.489668,-99) , 
8, 4.227, 1, 0, 0.498881,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0182357);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515433,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480485,-99) , 
7, 2.67633, 1, 0, 0.500737,-99) , 
0, 176.174, 0, 0, 0.503605,-99) , 
NN(
0, 
0, 
-1, -1.72698, 0, -1, 0.489794,-99) , 
8, 4.227, 1, 0, 0.501083,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
