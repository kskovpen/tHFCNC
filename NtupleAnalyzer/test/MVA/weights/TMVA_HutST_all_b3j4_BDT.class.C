// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Sat Oct  8 14:57:00 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 162557
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 20
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [15.1087627411,500]
TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD                                         'D'    [40.1792678833,1000]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.71241736412,0.754667162895]
MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD                                                'D'    [-0.872949898243,0.684497892857]
LepCharge                     LepCharge                     LepCharge                     LepCharge                                                       'I'    [-1,1]
HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB                                              'D'    [-6.61822748184,7.03937387466]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [84.6297454834,500]
TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD                                         'D'    [45.4443511963,500]
TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB                                              'D'    [0.409886658192,1000]
TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB                                             'D'    [-6.92331504822,6.62239837646]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.399316638708,5.42987298965]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.0144780697301,9.75196933746]
TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD                                     'D'    [0.0383455716074,10.8463878632]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [0.800953149796,1]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [0.800002396107,0.999438345432]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [0.800001859665,0.999629676342]
TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800002515316,0.999627888203]
TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800007224083,1]
TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.999085485935]
TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.799665033817]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 20 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "TopHadMass_TOPTOPLEPHAD", "MVA_TOPHLEPBB", "MVA_TOPTOPLEPHAD", "LepCharge", "HiggsEta_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "TopLepMass_TOPTOPLEPHAD", "TopLepPt_TOPHLEPBB", "TopLepEta_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "TopLepTopHadDr_TOPTOPLEPHAD", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPTOPLEPHAD", "TopHadBJetCSVv2_TOPTOPLEPHAD", "TopHadWNonBJet1CSVv2_TOPTOPLEPHAD", "TopHadWNonBJet2CSVv2_TOPTOPLEPHAD" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'I';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';
      fType[12] = 'D';
      fType[13] = 'D';
      fType[14] = 'D';
      fType[15] = 'D';
      fType[16] = 'D';
      fType[17] = 'D';
      fType[18] = 'D';
      fType[19] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[20];
   double fVmax[20];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[20];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.507320516078366);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.923465, 0, 1, 0.781895,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348182,-99) , 
14, 0.923428, 0, 0, 0.460792,-99) , 
1, 227.486, 0, 0, 0.629343,-99) , 
NN(
0, 
0, 
-1, 0.951954, 0, -1, 0.235114,-99) , 
4, 0, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.314916);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.923464, 0, 1, 0.696325,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417627,-99) , 
17, 0.961906, 0, 0, 0.507793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.197411,-99) , 
14, 0.951956, 0, 0, 0.266717,-99) , 
4, 0, 0, 0, 0.422741,-99) , 
1, 314.414, 0, 0, 0.507326,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.280553);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 370.955, 0, 1, 0.702029,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367246,-99) , 
3, 0.222742, 1, 0, 0.489675,-99) , 
8, 238.465, 0, 0, 0.555262,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322158,-99) , 
1, 187.999, 0, 0, 0.460919,-99) , 
NN(
0, 
0, 
-1, 0.192313, 1, -1, 0.23992,-99) , 
14, 0.90447, 0, 0, 0.341861,-99) , 
4, 0, 0, 0, 0.487368,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.224719);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.199195, 0, 1, 0.658138,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414999,-99) , 
2, 0.188195, 0, 0, 0.489689,-99) , 
NN(
0, 
0, 
-1, 0, 0, -1, 0.348203,-99) , 
14, 0.875978, 0, 0, 0.434211,-99) , 
1, 451.531, 0, 0, 0.469136,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.194364);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665493,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.689142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479801,-99) , 
15, 0.952088, 0, 0, 0.596223,-99) , 
NN(
0, 
0, 
-1, 0, 0, -1, 0.419418,-99) , 
14, 0.970947, 0, 0, 0.45103,-99) , 
8, 333.607, 0, 0, 0.476557,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.205458);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 110.731, 0, 1, 0.62342,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45259,-99) , 
11, 2.54507, 1, 0, 0.490495,-99) , 
10, 1.56549, 1, 0, 0.549906,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364825,-99) , 
17, 0.971118, 0, 0, 0.465557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275315,-99) , 
3, 0.230875, 1, 0, 0.404929,-99) , 
4, 0, 0, 0, 0.505072,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.167894);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 189.573, 0, 1, 0.595434,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438571,-99) , 
8, 191.327, 0, 0, 0.486222,-99) , 
16, 0.980618, 0, 0, 0.539779,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346931,-99) , 
2, 0.0557915, 0, 0, 0.472731,-99) , 
NN(
0, 
0, 
-1, 0.980748, 0, -1, 0.334634,-99) , 
3, 0.157287, 1, 0, 0.416088,-99) , 
4, 0, 0, 0, 0.501779,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.13442);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467466,-99) , 
0, 104.173, 0, 0, 0.60937,-99) , 
NN(
0, 
0, 
-1, 143.754, 1, -1, 0.472037,-99) , 
10, 1.35789, 1, 0, 0.510253,-99) , 
NN(
0, 
0, 
-1, 0.952084, 0, -1, 0.351066,-99) , 
0, 84.3789, 0, 0, 0.491154,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.142305);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 500.138, 0, 1, 0.557856,-99) , 
NN(
0, 
0, 
-1, 239.861, 0, -1, 0.406166,-99) , 
0, 143.754, 1, 0, 0.530513,-99) , 
NN(
0, 
0, 
-1, 0.952084, 0, -1, 0.382267,-99) , 
0, 84.3789, 0, 0, 0.512924,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.161385);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0871657, 1, 1, 0.633628,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460914,-99) , 
5, 1.40294, 0, 0, 0.502549,-99) , 
5, -1.41533, 1, 0, 0.52777,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414353,-99) , 
15, 0.961547, 0, 0, 0.474675,-99) , 
NN(
0, 
0, 
-1, 223.002, 0, -1, 0.351811,-99) , 
13, 0.980748, 0, 0, 0.42746,-99) , 
4, 0, 0, 0, 0.497092,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.127883);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.84181, 1, 1, 0.599624,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434047,-99) , 
18, 0.47532, 0, 0, 0.497909,-99) , 
8, 238.408, 0, 0, 0.523731,-99) , 
NN(
0, 
0, 
-1, 0.990248, 0, -1, 0.389115,-99) , 
3, 0.387841, 1, 0, 0.507169,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.10553);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 233.659, 0, 1, 0.608664,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486333,-99) , 
11, 2.11501, 1, 0, 0.50288,-99) , 
14, 0.961451, 0, 0, 0.526029,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427512,-99) , 
10, 2.04193, 1, 0, 0.47523,-99) , 
NN(
0, 
0, 
-1, 0.933081, 0, -1, 0.391496,-99) , 
13, 0.990192, 0, 0, 0.431682,-99) , 
4, 0, 0, 0, 0.497182,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.107558);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646799,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473095,-99) , 
15, 0.9331, 0, 0, 0.521727,-99) , 
1, 545.58, 0, 0, 0.534868,-99) , 
NN(
0, 
0, 
-1, 0.942586, 0, -1, 0.442137,-99) , 
4, 0, 0, 0, 0.506572,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.107493);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666117,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458519,-99) , 
10, 2.35029, 1, 0, 0.509439,-99) , 
10, 1.11836, 1, 0, 0.533109,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429757,-99) , 
14, 0.866481, 0, 0, 0.477983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388648,-99) , 
15, 0.876051, 0, 0, 0.462003,-99) , 
0, 107.469, 0, 0, 0.507818,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0930414);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498166,-99) , 
7, 218.608, 0, 0, 0.513334,-99) , 
1, 368.837, 0, 0, 0.534679,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472097,-99) , 
8, 192.918, 0, 0, 0.51407,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43024,-99) , 
19, 0.285371, 0, 0, 0.447643,-99) , 
11, 2.79662, 1, 0, 0.470872,-99) , 
13, 0.990522, 0, 0, 0.501032,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.100039);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643758,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450663,-99) , 
0, 144.853, 1, 0, 0.511635,-99) , 
10, 1.11836, 1, 0, 0.531321,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469287,-99) , 
5, 1.48152, 0, 0, 0.483432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401478,-99) , 
0, 72.284, 0, 0, 0.469237,-99) , 
0, 107.469, 0, 0, 0.509219,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.051961);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.72922, 1, 1, 0.581876,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587271,-99) , 
NN(
0, 
0, 
-1, 0.905216, 0, -1, 0.487839,-99) , 
8, 381.206, 0, 0, 0.495302,-99) , 
14, 0.980444, 0, 0, 0.506325,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0684954);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489368,-99) , 
8, 144.519, 0, 0, 0.57809,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49525,-99) , 
5, -1.41533, 1, 0, 0.509287,-99) , 
11, 2.30531, 1, 0, 0.522339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425415,-99) , 
13, 0.905216, 0, 0, 0.514323,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.093085);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 188.58, 0, 1, 0.570696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468694,-99) , 
13, 0.996598, 0, 0, 0.506925,-99) , 
4, 0, 0, 0, 0.551043,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438313,-99) , 
15, 0.866544, 0, 0, 0.510202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420707,-99) , 
3, 0.390845, 1, 0, 0.499371,-99) , 
13, 0.990522, 0, 0, 0.523813,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0424409);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 588.648, 0, 1, 0.516867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430716,-99) , 
13, 0.905216, 0, 0, 0.509733,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.100116);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473524,-99) , 
9, -0.472975, 0, 0, 0.506695,-99) , 
10, 1.83716, 1, 0, 0.541624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482611,-99) , 
10, 2.03399, 1, 0, 0.534509,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450042,-99) , 
11, 2.10007, 1, 0, 0.462515,-99) , 
5, -1.0437, 1, 0, 0.487495,-99) , 
5, 1.18612, 0, 0, 0.500882,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0720086);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473441,-99) , 
4, 0, 0, 0, 0.515881,-99) , 
19, 0.285395, 0, 0, 0.52821,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440446,-99) , 
3, 0.32035, 1, 0, 0.496735,-99) , 
NN(
0, 
0, 
-1, 230.792, 1, -1, 0.443805,-99) , 
13, 0.962032, 0, 0, 0.482668,-99) , 
7, 175.317, 0, 0, 0.5057,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0659529);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575026,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45629,-99) , 
0, 87.3254, 0, 0, 0.514395,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465829,-99) , 
5, 1.83654, 0, 0, 0.473442,-99) , 
7, 175.317, 0, 0, 0.49412,-99) , 
5, -2.06569, 1, 0, 0.499515,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0584878);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560235,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528524,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477953,-99) , 
10, 1.11797, 1, 0, 0.487769,-99) , 
8, 381.206, 0, 0, 0.493066,-99) , 
14, 0.989941, 0, 0, 0.498516,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0586873);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 190.766, 0, 1, 0.56867,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468155,-99) , 
14, 0.834826, 0, 0, 0.504139,-99) , 
14, 0.90447, 0, 0, 0.534295,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490144,-99) , 
11, 2.25035, 1, 0, 0.500036,-99) , 
NN(
0, 
0, 
-1, 2.10624, 1, -1, 0.457633,-99) , 
8, 95.6089, 0, 0, 0.490927,-99) , 
15, 0.990124, 0, 0, 0.504257,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0541957);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.990411, 0, 1, 0.547993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564167,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482419,-99) , 
5, 0.969403, 0, 0, 0.495295,-99) , 
5, -2.06569, 1, 0, 0.499824,-99) , 
19, 0.285395, 0, 0, 0.508947,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0660386);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.47532, 0, 1, 0.541735,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465654,-99) , 
10, 1.8915, 1, 0, 0.490743,-99) , 
15, 0.904561, 0, 0, 0.528229,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478143,-99) , 
9, -0.0292971, 1, 0, 0.52151,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472918,-99) , 
5, 1.91538, 0, 0, 0.480425,-99) , 
5, -0.959126, 1, 0, 0.492515,-99) , 
13, 0.990522, 0, 0, 0.50938,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0442486);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.655305, 1, 1, 0.519987,-99) , 
NN(
0, 
0, 
-1, 2.64794, 1, -1, 0.48062,-99) , 
8, 95.6089, 0, 0, 0.511024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43848,-99) , 
3, 0.462005, 1, 0, 0.507087,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0569899);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.79872, 1, 1, 0.538987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484257,-99) , 
4, 0, 0, 0, 0.522973,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484959,-99) , 
18, 0.899139, 0, 0, 0.504738,-99) , 
NN(
0, 
0, 
-1, 233.11, 1, -1, 0.471588,-99) , 
18, 0.475143, 0, 0, 0.491938,-99) , 
5, -0.76497, 1, 0, 0.501993,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0524882);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.31024, 1, 1, 0.532666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479351,-99) , 
0, 87.3254, 0, 0, 0.523852,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485391,-99) , 
11, 2.81753, 1, 0, 0.501387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453185,-99) , 
10, 2.79506, 1, 0, 0.494494,-99) , 
6, 183.527, 0, 0, 0.506091,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0338004);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552595,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455671,-99) , 
10, 3.03437, 1, 0, 0.505158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445264,-99) , 
15, 0.82852, 0, 0, 0.501706,-99) , 
8, 381.206, 0, 0, 0.505342,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0321378);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543924,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551043,-99) , 
NN(
0, 
0, 
-1, 84.3789, 0, -1, 0.489814,-99) , 
1, 144.64, 1, 0, 0.495327,-99) , 
1, 588.648, 0, 0, 0.498882,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0543194);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.952506, 1, 1, 0.520258,-99) , 
NN(
0, 
0, 
-1, 223.002, 1, -1, 0.470422,-99) , 
0, 94.2732, 0, 0, 0.508946,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41916,-99) , 
0, 236.118, 0, 0, 0.470724,-99) , 
0, 153.649, 1, 0, 0.504402,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0260277);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548029,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544756,-99) , 
NN(
0, 
0, 
-1, 130.559, 1, -1, 0.491522,-99) , 
8, 381.206, 0, 0, 0.494987,-99) , 
7, 326.836, 0, 0, 0.498083,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0490392);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482201,-99) , 
10, 2.2028, 1, 0, 0.512626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470696,-99) , 
0, 153.649, 1, 0, 0.507754,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431082,-99) , 
1, 231.87, 1, 0, 0.47397,-99) , 
14, 0.828493, 0, 0, 0.503034,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0288734);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548885,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494125,-99) , 
10, 2.56276, 1, 0, 0.532813,-99) , 
NN(
0, 
0, 
-1, 0.83799, 0, -1, 0.491488,-99) , 
5, 1.83654, 0, 0, 0.496327,-99) , 
5, -2.06569, 1, 0, 0.499802,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0584625);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483366,-99) , 
18, 0.824503, 0, 0, 0.519441,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459305,-99) , 
1, 230.792, 1, 0, 0.489003,-99) , 
18, 0.47532, 0, 0, 0.508014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456516,-99) , 
3, 0.462005, 1, 0, 0.505219,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0325172);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543089,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535301,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519131,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489789,-99) , 
19, 0.285395, 0, 0, 0.495445,-99) , 
10, 0.878417, 1, 0, 0.49931,-99) , 
8, 381.206, 0, 0, 0.502425,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0308584);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548433,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472601,-99) , 
0, 133.856, 1, 0, 0.499537,-99) , 
0, 222.919, 0, 0, 0.502357,-99) , 
14, 0.989941, 0, 0, 0.505307,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0374867);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574577,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493793,-99) , 
0, 238.313, 0, 0, 0.498096,-99) , 
10, 1.11836, 1, 0, 0.508967,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457255,-99) , 
2, 0.362495, 1, 0, 0.494315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44171,-99) , 
0, 72.284, 0, 0, 0.485172,-99) , 
0, 107.469, 0, 0, 0.500441,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.044133);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.11836, 1, 1, 0.514216,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466477,-99) , 
17, 0.96191, 1, 0, 0.492307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446312,-99) , 
1, 314.414, 1, 0, 0.481998,-99) , 
0, 107.469, 0, 0, 0.502672,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0378247);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537927,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524552,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484923,-99) , 
5, -1.78698, 1, 0, 0.490216,-99) , 
5, 1.83648, 0, 0, 0.493994,-99) , 
14, 0.989941, 0, 0, 0.496949,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.025095);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.10179, 1, 1, 0.511472,-99) , 
NN(
0, 
0, 
-1, 72.284, 0, -1, 0.490694,-99) , 
0, 107.469, 0, 0, 0.50407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460986,-99) , 
13, 0.895737, 0, 0, 0.501263,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0398422);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489946,-99) , 
15, 0.904565, 0, 0, 0.516635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473809,-99) , 
17, 0.952102, 1, 0, 0.491176,-99) , 
18, 0.47532, 0, 0, 0.506811,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516474,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496166,-99) , 
5, 0.0448559, 1, 0, 0.506292,-99) , 
NN(
0, 
0, 
-1, 0, 0, -1, 0.478049,-99) , 
15, 0.990107, 0, 0, 0.486568,-99) , 
6, 163.748, 0, 0, 0.499986,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0496436);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490856,-99) , 
0, 107.469, 0, 0, 0.524733,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486031,-99) , 
17, 0.961614, 1, 0, 0.496853,-99) , 
10, 1.33542, 1, 0, 0.505262,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490476,-99) , 
1, 171.612, 0, 0, 0.511643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447089,-99) , 
1, 231.87, 1, 0, 0.482893,-99) , 
13, 0.952608, 0, 0, 0.500481,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0636217);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.923464, 0, 1, 0.549761,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472488,-99) , 
15, 0.97111, 0, 0, 0.496026,-99) , 
3, 0.017229, 1, 0, 0.517957,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46889,-99) , 
14, 0.923291, 1, 0, 0.50811,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446853,-99) , 
14, 0.923078, 0, 0, 0.472889,-99) , 
1, 314.414, 1, 0, 0.497791,-99) , 
17, 0.990477, 0, 0, 0.504626,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.053179);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568228,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46808,-99) , 
4, 0, 1, 0, 0.483109,-99) , 
1, 272.928, 0, 0, 0.514768,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447935,-99) , 
2, 0.465307, 1, 0, 0.504215,-99) , 
NN(
0, 
0, 
-1, 0.421362, 0, -1, 0.466566,-99) , 
1, 314.414, 1, 0, 0.49365,-99) , 
14, 0.942457, 0, 0, 0.499965,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0274858);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534406,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532284,-99) , 
NN(
0, 
0, 
-1, 186.923, 0, -1, 0.489861,-99) , 
1, 144.64, 1, 0, 0.49368,-99) , 
1, 588.648, 0, 0, 0.496619,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0387169);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565655,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454344,-99) , 
2, 0.0149016, 0, 0, 0.494172,-99) , 
2, 0.283921, 0, 0, 0.517473,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547879,-99) , 
NN(
0, 
0, 
-1, 138.255, 1, -1, 0.490296,-99) , 
0, 199.829, 0, 0, 0.494479,-99) , 
14, 0.942457, 0, 0, 0.501351,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.036309);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.174164, 0, 1, 0.531308,-99) , 
NN(
NN(
0, 
0, 
-1, 184.01, 0, 1, 0.51615,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483974,-99) , 
5, 0.863982, 0, 0, 0.496394,-99) , 
9, -1.11801, 1, 0, 0.502173,-99) , 
10, 0.878417, 1, 0, 0.505403,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0372785);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483312,-99) , 
4, 0, 0, 0, 0.526112,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486898,-99) , 
3, 0.0911845, 1, 0, 0.501119,-99) , 
16, 0.914077, 1, 0, 0.505836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470632,-99) , 
13, 0.895737, 0, 0, 0.503546,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0251607);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547785,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476671,-99) , 
10, 2.79482, 1, 0, 0.502343,-99) , 
8, 381.206, 0, 0, 0.505252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46687,-99) , 
6, 321.984, 1, 0, 0.503182,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0301753);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52981,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583087,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48977,-99) , 
8, 287.099, 0, 0, 0.50696,-99) , 
NN(
0, 
0, 
-1, 333.607, 1, -1, 0.491359,-99) , 
11, 2.79662, 1, 0, 0.496974,-99) , 
5, -2.06569, 1, 0, 0.49914,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0228914);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543449,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496685,-99) , 
11, 2.81753, 1, 0, 0.504124,-99) , 
14, 0.989941, 0, 0, 0.506763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478857,-99) , 
2, -0.153528, 0, 0, 0.504756,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0413882);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.980628, 0, 1, 0.538297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464748,-99) , 
3, 0.313677, 1, 0, 0.519059,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494938,-99) , 
17, 0.961906, 1, 0, 0.506576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469754,-99) , 
1, 451.531, 1, 0, 0.501649,-99) , 
2, 0.3355, 0, 0, 0.506154,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0351197);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.30094, 1, 1, 0.516338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483012,-99) , 
0, 153.649, 1, 0, 0.512571,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489231,-99) , 
9, -0.518087, 1, 0, 0.504924,-99) , 
NN(
0, 
0, 
-1, 0.942514, 0, -1, 0.474031,-99) , 
1, 230.792, 1, 0, 0.491066,-99) , 
13, 0.962086, 0, 0, 0.506945,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.044478);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496296,-99) , 
15, 0.952093, 0, 0, 0.51495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462605,-99) , 
3, 0.381614, 1, 0, 0.509597,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488598,-99) , 
17, 0.961611, 1, 0, 0.520177,-99) , 
NN(
0, 
0, 
-1, 0.894974, 0, -1, 0.47733,-99) , 
3, 0.235058, 0, 0, 0.492604,-99) , 
18, 0.47532, 0, 0, 0.503061,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0307102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 230.792, 1, 1, 0.538225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484543,-99) , 
11, 2.47991, 0, 0, 0.524411,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495634,-99) , 
17, 0.990477, 0, 0, 0.503344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460815,-99) , 
15, 0.847548, 0, 0, 0.500644,-99) , 
16, 0.914074, 1, 0, 0.505595,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0387027);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494404,-99) , 
10, 2.31572, 0, 0, 0.504012,-99) , 
11, 2.23442, 1, 0, 0.513317,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498753,-99) , 
16, 0.923587, 1, 0, 0.508746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458934,-99) , 
11, 2.33293, 0, 0, 0.497926,-99) , 
8, 143.208, 0, 0, 0.506828,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0515948);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.111663, 0, 1, 0.555645,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470872,-99) , 
8, 239.284, 1, 0, 0.506376,-99) , 
11, 2.6141, 1, 0, 0.518987,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540817,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459467,-99) , 
11, 2.36559, 0, 0, 0.494705,-99) , 
8, 238.408, 0, 0, 0.502652,-99) , 
10, 1.83662, 1, 0, 0.511402,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0396311);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.94227, 0, 1, 0.531509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483092,-99) , 
0, 84.3789, 0, 0, 0.518532,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540673,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484224,-99) , 
3, 0.233165, 0, 0, 0.491721,-99) , 
8, 286.007, 0, 0, 0.497347,-99) , 
10, 1.35752, 1, 0, 0.504036,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0250048);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.174164, 0, 1, 0.528,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495209,-99) , 
2, 0.188195, 1, 0, 0.504155,-99) , 
NN(
0, 
0, 
-1, 143.208, 0, -1, 0.480781,-99) , 
14, 0.828493, 0, 0, 0.500926,-99) , 
10, 0.878417, 1, 0, 0.503914,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0227326);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532666,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491563,-99) , 
0, 130.559, 1, 0, 0.504213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473012,-99) , 
15, 0.82852, 0, 0, 0.502493,-99) , 
7, 326.836, 0, 0, 0.50424,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.040976);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 238.41, 0, 1, 0.514028,-99) , 
NN(
0, 
0, 
-1, 0.395708, 1, -1, 0.47586,-99) , 
3, 0.307816, 1, 0, 0.507469,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476866,-99) , 
1, 230.792, 1, 0, 0.505666,-99) , 
NN(
0, 
0, 
-1, 0.894975, 0, -1, 0.464406,-99) , 
4, 0, 0, 0, 0.493395,-99) , 
18, 0.47532, 0, 0, 0.502058,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0347687);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.329315, 0, 1, 0.522844,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481125,-99) , 
2, 0.0524419, 1, 0, 0.488961,-99) , 
11, 2.97208, 1, 0, 0.504997,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47667,-99) , 
10, 2.50739, 1, 0, 0.494879,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454427,-99) , 
11, 1.86924, 0, 0, 0.489869,-99) , 
8, 143.208, 0, 0, 0.498614,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0303907);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549041,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474062,-99) , 
0, 125.019, 1, 0, 0.496955,-99) , 
10, 1.12388, 1, 0, 0.511803,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48262,-99) , 
2, 0.185795, 1, 0, 0.495352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467408,-99) , 
1, 451.531, 1, 0, 0.491619,-99) , 
2, 0.3355, 0, 0, 0.49683,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.040515);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552877,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483684,-99) , 
5, 0.703948, 0, 0, 0.496973,-99) , 
14, 0.961396, 0, 0, 0.508051,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487137,-99) , 
0, 176.739, 0, 0, 0.492491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466832,-99) , 
14, 0.970948, 1, 0, 0.487962,-99) , 
2, 0.265639, 0, 0, 0.495441,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0359301);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 110.731, 0, 1, 0.534144,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475336,-99) , 
1, 185.544, 0, 0, 0.494316,-99) , 
10, 1.79872, 1, 0, 0.512861,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536648,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48582,-99) , 
16, 0.914071, 1, 0, 0.490425,-99) , 
5, 2.20814, 0, 0, 0.494272,-99) , 
5, -0.76497, 1, 0, 0.500289,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0185797);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 542.943, 0, 1, 0.506324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474145,-99) , 
13, 0.905387, 0, 0, 0.503692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473084,-99) , 
2, -0.153528, 0, 0, 0.50149,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0202216);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530427,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528329,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494591,-99) , 
1, 144.64, 1, 0, 0.497645,-99) , 
1, 588.648, 0, 0, 0.499806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470354,-99) , 
6, 321.984, 1, 0, 0.498218,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0131624);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532874,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498699,-99) , 
10, 0.878417, 1, 0, 0.501355,-99) , 
8, 381.206, 0, 0, 0.50334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475395,-99) , 
6, 321.984, 1, 0, 0.501834,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0177409);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.23535, 1, 1, 0.5074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481216,-99) , 
11, 4.19167, 1, 0, 0.505651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478678,-99) , 
6, 321.984, 1, 0, 0.504198,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0191729);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521887,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496742,-99) , 
10, 1.35789, 1, 0, 0.502192,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475528,-99) , 
5, 0.818393, 0, 0, 0.486988,-99) , 
14, 0.83799, 0, 0, 0.499311,-99) , 
5, -2.06569, 1, 0, 0.500801,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0191131);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.675267, 1, 1, 0.506975,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473752,-99) , 
10, 3.03459, 1, 0, 0.504632,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475205,-99) , 
2, 0.196248, 0, 0, 0.490387,-99) , 
14, 0.83799, 0, 0, 0.501912,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0268308);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498721,-99) , 
0, 116.802, 0, 0, 0.507082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469253,-99) , 
9, -0.186037, 1, 0, 0.489004,-99) , 
0, 133.178, 1, 0, 0.502321,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488072,-99) , 
10, 1.59742, 1, 0, 0.498188,-99) , 
NN(
0, 
0, 
-1, 144.909, 1, -1, 0.478442,-99) , 
0, 107.469, 0, 0, 0.491199,-99) , 
6, 163.748, 0, 0, 0.498575,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0179574);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515805,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510012,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497046,-99) , 
17, 0.961906, 1, 0, 0.502401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471448,-99) , 
8, 333.607, 1, 0, 0.499285,-99) , 
11, 1.86924, 1, 0, 0.501067,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0291907);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469296,-99) , 
0, 74.4821, 0, 0, 0.507892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479826,-99) , 
0, 153.649, 1, 0, 0.504712,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488101,-99) , 
5, -0.637182, 1, 0, 0.499593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472758,-99) , 
18, 0.429082, 0, 0, 0.490218,-99) , 
13, 0.952608, 0, 0, 0.501613,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0308912);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495361,-99) , 
14, 0.894973, 0, 0, 0.504104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471063,-99) , 
11, 4.18769, 1, 0, 0.501881,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474015,-99) , 
1, 227.486, 1, 0, 0.5024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460438,-99) , 
4, 0, 0, 0, 0.489609,-99) , 
15, 0.904569, 0, 0, 0.498739,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.082534);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448238,-99) , 
4, 0, 0, 0, 0.517545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459553,-99) , 
4, 0, 1, 0, 0.487535,-99) , 
1, 223.002, 1, 0, 0.503687,-99) , 
NN(
NN(
0, 
0, 
-1, 0.293462, 0, 1, 0.520787,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445237,-99) , 
4, 0, 1, 0, 0.468314,-99) , 
1, 227.486, 0, 0, 0.49283,-99) , 
14, 0.923463, 1, 0, 0.499496,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0368024);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545101,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480619,-99) , 
18, 0.403292, 0, 0, 0.49891,-99) , 
0, 176.739, 0, 0, 0.503196,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478796,-99) , 
15, 0.980613, 0, 0, 0.493682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443801,-99) , 
2, -0.0523267, 0, 0, 0.48694,-99) , 
14, 0.923463, 1, 0, 0.496917,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0403533);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494663,-99) , 
10, 2.02547, 1, 0, 0.521866,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475996,-99) , 
5, -0.672094, 1, 0, 0.491901,-99) , 
5, 1.18612, 0, 0, 0.499574,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460244,-99) , 
5, 1.17785, 1, 0, 0.496261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460226,-99) , 
15, 0.904564, 0, 0, 0.487194,-99) , 
4, 0, 0, 0, 0.495736,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0365491);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498344,-99) , 
8, 143.757, 0, 0, 0.51766,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454552,-99) , 
8, 143.208, 1, 0, 0.477751,-99) , 
4, 0, 0, 0, 0.505677,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516802,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480893,-99) , 
5, -1.73119, 1, 0, 0.486316,-99) , 
0, 176.739, 0, 0, 0.488943,-99) , 
5, 0.535754, 0, 0, 0.495558,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0284056);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.77456, 0, 1, 0.516321,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476068,-99) , 
5, -0.486256, 1, 0, 0.492182,-99) , 
5, 0.535754, 0, 0, 0.50186,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47891,-99) , 
15, 0.933081, 0, 0, 0.498347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463373,-99) , 
0, 130.559, 1, 0, 0.488686,-99) , 
4, 0, 0, 0, 0.497774,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0316356);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.971431, 1, 1, 0.511063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470224,-99) , 
4, 0, 0, 0, 0.491579,-99) , 
13, 0.981124, 0, 0, 0.50081,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488802,-99) , 
11, 2.79976, 1, 0, 0.50674,-99) , 
NN(
0, 
0, 
-1, 0.00113457, 0, -1, 0.477996,-99) , 
8, 190.869, 0, 0, 0.488916,-99) , 
16, 0.980616, 1, 0, 0.49503,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0279827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532359,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491352,-99) , 
9, -1.4342, 1, 0, 0.495306,-99) , 
5, 2.20815, 0, 0, 0.49784,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485463,-99) , 
5, -1.79384, 1, 0, 0.501283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448363,-99) , 
10, 2.50017, 1, 0, 0.482414,-99) , 
5, -1.41533, 0, 0, 0.495083,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0187741);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525387,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497502,-99) , 
0, 199.829, 0, 0, 0.499556,-99) , 
5, 2.20815, 0, 0, 0.501321,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484392,-99) , 
10, 1.70096, 1, 0, 0.501349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455294,-99) , 
10, 2.50017, 1, 0, 0.484938,-99) , 
5, -1.41533, 0, 0, 0.498395,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0294186);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482684,-99) , 
1, 314.414, 1, 0, 0.511262,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467282,-99) , 
0, 153.649, 1, 0, 0.500066,-99) , 
17, 0.961906, 1, 0, 0.504765,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489082,-99) , 
10, 1.70096, 1, 0, 0.501213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459954,-99) , 
10, 2.50017, 1, 0, 0.486516,-99) , 
5, -1.41533, 0, 0, 0.501507,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0435702);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478571,-99) , 
4, 0, 0, 0, 0.513449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484282,-99) , 
1, 314.414, 1, 0, 0.504961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483066,-99) , 
2, 0.21425, 0, 0, 0.507553,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475901,-99) , 
4, 0, 1, 0, 0.485219,-99) , 
1, 272.928, 0, 0, 0.493143,-99) , 
17, 0.961906, 1, 0, 0.498147,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0303625);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523156,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484527,-99) , 
6, 228.738, 1, 0, 0.501413,-99) , 
9, -1.40671, 1, 0, 0.506785,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475141,-99) , 
11, 3.55411, 1, 0, 0.501734,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472543,-99) , 
17, 0.923591, 1, 0, 0.48274,-99) , 
1, 177.297, 0, 0, 0.495227,-99) , 
6, 183.527, 0, 0, 0.499792,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0140822);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516939,-99) , 
NN(
0, 
0, 
-1, 72.9345, 0, -1, 0.494504,-99) , 
8, 381.206, 0, 0, 0.495927,-99) , 
7, 326.836, 0, 0, 0.49734,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0177106);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486562,-99) , 
12, 3.65432, 1, 0, 0.509632,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4714,-99) , 
0, 153.649, 1, 0, 0.497126,-99) , 
17, 0.952383, 1, 0, 0.501788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484095,-99) , 
2, 0.475222, 1, 0, 0.500033,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.02869);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516125,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520457,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48548,-99) , 
11, 2.60222, 0, 0, 0.509983,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487194,-99) , 
11, 2.35523, 1, 0, 0.491899,-99) , 
2, 0.0560555, 1, 0, 0.49636,-99) , 
14, 0.989941, 0, 0, 0.497674,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0221451);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531468,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48267,-99) , 
17, 0.877102, 0, 0, 0.500758,-99) , 
0, 156.104, 0, 0, 0.504662,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514786,-99) , 
NN(
0, 
0, 
-1, 2.73166, 1, -1, 0.492307,-99) , 
17, 0.998186, 0, 0, 0.496065,-99) , 
17, 0.961906, 1, 0, 0.499704,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0124058);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492502,-99) , 
2, 0.174164, 0, 0, 0.513129,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499242,-99) , 
3, 0.385446, 0, 0, 0.501391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479045,-99) , 
2, 0.465307, 1, 0, 0.499226,-99) , 
10, 0.878417, 1, 0, 0.500756,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0197561);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537413,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487119,-99) , 
11, 3.0515, 1, 0, 0.516882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487395,-99) , 
11, 2.33293, 0, 0, 0.501651,-99) , 
8, 286.007, 0, 0, 0.503973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484314,-99) , 
3, 0.462005, 1, 0, 0.50292,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0168306);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530896,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498636,-99) , 
16, 0.866549, 1, 0, 0.501235,-99) , 
1, 143.421, 1, 0, 0.503513,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474286,-99) , 
8, 95.6089, 0, 0, 0.498883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473136,-99) , 
2, 0.398278, 1, 0, 0.494178,-99) , 
13, 0.971565, 0, 0, 0.500565,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0230453);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499077,-99) , 
4, 0, 0, 0, 0.517027,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497659,-99) , 
10, 1.08152, 1, 0, 0.501809,-99) , 
13, 0.997292, 0, 0, 0.50644,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484602,-99) , 
1, 186.686, 0, 0, 0.500764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456616,-99) , 
2, 0.214174, 1, 0, 0.480295,-99) , 
14, 0.881416, 1, 0, 0.493147,-99) , 
13, 0.971565, 0, 0, 0.502242,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0279031);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 164.702, 0, 1, 0.518797,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491633,-99) , 
0, 112.367, 0, 0, 0.504349,-99) , 
16, 0.9521, 1, 0, 0.508249,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486522,-99) , 
14, 0.881424, 1, 0, 0.501705,-99) , 
NN(
0, 
0, 
-1, 3.21299, 1, -1, 0.482592,-99) , 
16, 0.952094, 0, 0, 0.492347,-99) , 
13, 0.971565, 0, 0, 0.503228,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0174746);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499955,-99) , 
13, 0.994584, 0, 0, 0.507951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487171,-99) , 
2, -0.0785405, 0, 0, 0.505607,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494694,-99) , 
2, 0.0511859, 1, 0, 0.498573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478015,-99) , 
12, 3.75257, 1, 0, 0.495122,-99) , 
13, 0.971565, 0, 0, 0.502296,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0196506);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.258196, 0, 1, 0.514736,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476957,-99) , 
0, 153.649, 1, 0, 0.50238,-99) , 
17, 0.961906, 1, 0, 0.505568,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508437,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474534,-99) , 
8, 190.808, 1, 0, 0.491226,-99) , 
15, 0.990124, 0, 0, 0.496796,-99) , 
13, 0.962086, 0, 0, 0.503276,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
