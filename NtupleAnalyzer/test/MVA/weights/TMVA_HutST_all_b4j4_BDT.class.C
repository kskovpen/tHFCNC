// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Feb 14 13:59:19 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 8553
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 20
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [19.3274612427,500]
TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD                                         'D'    [54.0754241943,1000]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.565324008465,0.811453938484]
MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD                                                'D'    [-0.819244325161,0.711108982563]
LepCharge                     LepCharge                     LepCharge                     LepCharge                                                       'I'    [-1,1]
HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB                                              'D'    [-6.68812131882,5.35377073288]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [87.6511764526,500]
TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD                                         'D'    [68.91456604,500]
TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB                                              'D'    [1.93938970566,989.340881348]
TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB                                             'D'    [-5.94298696518,4.82880163193]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.40500625968,4.53621196747]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.159456312656,7.82505989075]
TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD                                     'D'    [0.0325338356197,7.65750265121]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [0.850495755672,0.99962580204]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [0.800079166889,0.999312102795]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [0.800171613693,0.999599695206]
TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800361812115,0.999599695206]
TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800887107849,0.99962580204]
TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD                                       'D'    [0.0518688298762,0.99919629097]
TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.994495391846]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 20 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "TopHadMass_TOPTOPLEPHAD", "MVA_TOPHLEPBB", "MVA_TOPTOPLEPHAD", "LepCharge", "HiggsEta_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "TopLepMass_TOPTOPLEPHAD", "TopLepPt_TOPHLEPBB", "TopLepEta_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "TopLepTopHadDr_TOPTOPLEPHAD", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPTOPLEPHAD", "TopHadBJetCSVv2_TOPTOPLEPHAD", "TopHadWNonBJet1CSVv2_TOPTOPLEPHAD", "TopHadWNonBJet2CSVv2_TOPTOPLEPHAD" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'I';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';
      fType[12] = 'D';
      fType[13] = 'D';
      fType[14] = 'D';
      fType[15] = 'D';
      fType[16] = 'D';
      fType[17] = 'D';
      fType[18] = 'D';
      fType[19] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[20];
   double fVmax[20];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[20];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.445127463032856);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.95524, 0, 1, 0.743296,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284068,-99) , 
3, 0.316713, 1, 0, 0.461453,-99) , 
18, 0.865477, 0, 0, 0.626057,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3079,-99) , 
14, 0.942427, 0, 0, 0.385635,-99) , 
NN(
0, 
0, 
-1, 168.723, 1, -1, 0.111802,-99) , 
18, 0.862899, 0, 0, 0.247808,-99) , 
4, 0, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.322264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.117129, 1, 1, 0.651375,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346535,-99) , 
1, 336.145, 0, 0, 0.408951,-99) , 
4, 0, 0, 0, 0.578095,-99) , 
NN(
0, 
0, 
-1, 0, 0, -1, 0.324481,-99) , 
18, 0.863864, 0, 0, 0.466666,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.251685);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0552433, 1, 1, 0.622749,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35827,-99) , 
2, 0.399304, 0, 0, 0.442927,-99) , 
14, 0.914001, 0, 0, 0.538284,-99) , 
NN(
0, 
0, 
-1, 0.862899, 0, -1, 0.335712,-99) , 
4, 0, 0, 0, 0.473829,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.239303);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417063,-99) , 
2, 0.214482, 0, 0, 0.564038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.270841,-99) , 
16, 0.914382, 0, 0, 0.536002,-99) , 
NN(
0, 
0, 
-1, 0.908975, 0, -1, 0.378882,-99) , 
1, 189.208, 0, 0, 0.46996,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.194256);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 369.384, 0, 1, 0.587252,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41295,-99) , 
2, 0.48365, 0, 0, 0.460588,-99) , 
19, 0.470948, 0, 0, 0.518161,-99) , 
NN(
0, 
0, 
-1, 1.27308, 1, -1, 0.341649,-99) , 
17, 0.93338, 0, 0, 0.481071,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.173791);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614073,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453481,-99) , 
1, 324.34, 0, 0, 0.494389,-99) , 
NN(
0, 
0, 
-1, 0.868145, 0, -1, 0.373515,-99) , 
4, 0, 0, 0, 0.45659,-99) , 
18, 0.954085, 0, 0, 0.479488,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.154043);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 147.341, 1, 1, 0.548791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397313,-99) , 
14, 0.932757, 0, 0, 0.453348,-99) , 
17, 0.971235, 0, 0, 0.508477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297484,-99) , 
6, 244.736, 1, 0, 0.495523,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.170394);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.56222, 0, 1, 0.565886,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431914,-99) , 
5, 1.33981, 0, 0, 0.465986,-99) , 
10, 1.58754, 1, 0, 0.513314,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569918,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374777,-99) , 
14, 0.923561, 1, 0, 0.4831,-99) , 
NN(
0, 
0, 
-1, 168.723, 1, -1, 0.31884,-99) , 
18, 0.862899, 0, 0, 0.414107,-99) , 
4, 0, 0, 0, 0.482574,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0966728);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492765,-99) , 
1, 352.434, 0, 0, 0.566725,-99) , 
NN(
0, 
0, 
-1, 3.68855, 1, -1, 0.469093,-99) , 
3, -0.159132, 1, 0, 0.489538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317632,-99) , 
6, 244.736, 1, 0, 0.479251,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0650131);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.52731, 1, 1, 0.517035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354029,-99) , 
18, 0.187201, 0, 0, 0.507738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338944,-99) , 
6, 244.736, 1, 0, 0.497769,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.145545);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.97524, 0, 1, 0.614559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421532,-99) , 
10, 2.28578, 1, 0, 0.563893,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464055,-99) , 
10, 1.0015, 1, 0, 0.487411,-99) , 
NN(
0, 
0, 
-1, 0.895605, 1, -1, 0.348775,-99) , 
0, 87.995, 0, 0, 0.466094,-99) , 
6, 146.558, 1, 0, 0.485153,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.141375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613191,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481483,-99) , 
5, 1.7502, 0, 0, 0.508931,-99) , 
5, -1.52731, 1, 0, 0.52817,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401471,-99) , 
6, 170.841, 1, 0, 0.508335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272015,-99) , 
5, 0.695005, 0, 0, 0.374449,-99) , 
9, -0.300622, 1, 0, 0.447488,-99) , 
4, 0, 0, 0, 0.503655,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.135899);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.115931, 1, 1, 0.608631,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485329,-99) , 
5, 0.766383, 0, 0, 0.517468,-99) , 
14, 0.961396, 0, 0, 0.539739,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38814,-99) , 
5, 0.476022, 1, 0, 0.502449,-99) , 
NN(
0, 
0, 
-1, 203.374, 0, -1, 0.377132,-99) , 
9, -0.300622, 1, 0, 0.445694,-99) , 
4, 0, 0, 0, 0.511328,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.148738);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474389,-99) , 
10, 2.17727, 1, 0, 0.554252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450439,-99) , 
0, 87.995, 0, 0, 0.537856,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449748,-99) , 
7, 160.499, 1, 0, 0.50608,-99) , 
NN(
0, 
0, 
-1, 178.336, 0, -1, 0.380117,-99) , 
18, 0.862899, 0, 0, 0.454934,-99) , 
4, 0, 0, 0, 0.512917,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.126753);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49098,-99) , 
16, 0.971019, 0, 0, 0.54158,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40492,-99) , 
7, 194.54, 0, 0, 0.457918,-99) , 
3, 0.348509, 1, 0, 0.523029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38189,-99) , 
2, 0.0247237, 0, 0, 0.515484,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0797489);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.10073, 1, 1, 0.531011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404541,-99) , 
2, 0.0902845, 0, 0, 0.522069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395624,-99) , 
11, 1.9846, 0, 0, 0.51431,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.104634);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46249,-99) , 
10, 2.36058, 1, 0, 0.58243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465576,-99) , 
9, 0.314023, 1, 0, 0.544673,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39236,-99) , 
12, 2.54693, 0, 0, 0.497422,-99) , 
NN(
0, 
0, 
-1, 0.389312, 0, -1, 0.378158,-99) , 
12, 3.73556, 1, 0, 0.479456,-99) , 
5, -0.953887, 1, 0, 0.499472,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.117181);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461554,-99) , 
8, 238.7, 1, 0, 0.569421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430551,-99) , 
17, 0.93338, 0, 0, 0.544329,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456662,-99) , 
5, 1.44962, 0, 0, 0.476498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344788,-99) , 
13, 0.921479, 0, 0, 0.46688,-99) , 
5, -0.953887, 1, 0, 0.490583,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.105176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590086,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416812,-99) , 
15, 0.895064, 0, 0, 0.499783,-99) , 
5, -1.52731, 1, 0, 0.516316,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425483,-99) , 
9, -0.36204, 1, 0, 0.517092,-99) , 
NN(
0, 
0, 
-1, 0.894815, 0, -1, 0.41371,-99) , 
17, 0.990616, 0, 0, 0.454483,-99) , 
4, 0, 0, 0, 0.497832,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.053859);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554295,-99) , 
NN(
0, 
0, 
-1, 0.530705, 1, -1, 0.477679,-99) , 
3, -0.236253, 1, 0, 0.488659,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0657033);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.05793, 1, 1, 0.565776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414128,-99) , 
13, 0.949873, 0, 0, 0.491406,-99) , 
5, -1.52731, 1, 0, 0.504746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392144,-99) , 
6, 244.736, 1, 0, 0.49826,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.136906);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436152,-99) , 
0, 86.544, 0, 0, 0.566961,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463443,-99) , 
12, 2.7133, 1, 0, 0.483943,-99) , 
10, 0.991198, 1, 0, 0.5011,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387395,-99) , 
0, 110.884, 0, 0, 0.487803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300817,-99) , 
8, 237.117, 1, 0, 0.440293,-99) , 
3, 0.346739, 1, 0, 0.487935,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.114574);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463947,-99) , 
9, -1.23603, 0, 0, 0.557711,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471452,-99) , 
9, -1.32651, 1, 0, 0.492665,-99) , 
5, -0.953887, 1, 0, 0.513093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569769,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349161,-99) , 
16, 0.952162, 1, 0, 0.4061,-99) , 
6, 146.558, 1, 0, 0.445832,-99) , 
3, 0.346739, 1, 0, 0.49863,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0898384);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604117,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490821,-99) , 
3, -0.20857, 1, 0, 0.508861,-99) , 
1, 144.163, 1, 0, 0.51786,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433263,-99) , 
8, 192.305, 0, 0, 0.484184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324405,-99) , 
8, 237.117, 1, 0, 0.444461,-99) , 
3, 0.346739, 1, 0, 0.502143,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0806965);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477055,-99) , 
0, 86.544, 0, 0, 0.571069,-99) , 
NN(
0, 
0, 
-1, 0.291427, 0, 1, 0.514151,-99) , 
10, 0.991198, 1, 0, 0.525912,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407173,-99) , 
3, 0.520263, 1, 0, 0.492204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346067,-99) , 
13, 0.963983, 0, 0, 0.455053,-99) , 
3, 0.346739, 1, 0, 0.510811,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0635233);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.904981, 1, 1, 0.518276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363409,-99) , 
14, 0.857612, 0, 0, 0.508512,-99) , 
NN(
0, 
0, 
-1, 0.971575, 1, -1, 0.43528,-99) , 
11, 3.80974, 1, 0, 0.497271,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0753012);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449056,-99) , 
12, 3.5084, 1, 0, 0.501201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36492,-99) , 
12, 2.2111, 0, 0, 0.49371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392507,-99) , 
18, 0.187201, 0, 0, 0.487939,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.122234);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469802,-99) , 
18, 0.899125, 1, 0, 0.538216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424524,-99) , 
16, 0.931156, 1, 0, 0.477117,-99) , 
16, 0.972033, 0, 0, 0.500058,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533268,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38003,-99) , 
17, 0.946598, 1, 0, 0.41935,-99) , 
18, 0.954776, 0, 0, 0.450803,-99) , 
16, 0.990112, 1, 0, 0.481803,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0968982);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491823,-99) , 
0, 90.2357, 1, 0, 0.511125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355564,-99) , 
5, 0.397558, 0, 0, 0.437448,-99) , 
8, 277.862, 1, 0, 0.497366,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431003,-99) , 
6, 169.596, 1, 0, 0.487393,-99) , 
NN(
0, 
0, 
-1, 0.946598, 1, -1, 0.415143,-99) , 
18, 0.910356, 0, 0, 0.450143,-99) , 
16, 0.990112, 1, 0, 0.479884,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0682255);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429422,-99) , 
0, 87.995, 0, 0, 0.504519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401357,-99) , 
16, 0.895237, 0, 0, 0.497449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399848,-99) , 
11, 1.9846, 0, 0, 0.491573,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0808106);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.66455, 1, 1, 0.518855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511384,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346854,-99) , 
17, 0.974498, 0, 0, 0.430206,-99) , 
8, 277.862, 1, 0, 0.50239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520428,-99) , 
NN(
0, 
0, 
-1, 3.23975, 1, -1, 0.435145,-99) , 
10, 2.65709, 0, 0, 0.449971,-99) , 
16, 0.990112, 1, 0, 0.483014,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.109159);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488169,-99) , 
3, -0.0426407, 0, 0, 0.548626,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463127,-99) , 
3, 0.291427, 0, 0, 0.47382,-99) , 
10, 0.991198, 1, 0, 0.488982,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551521,-99) , 
NN(
0, 
0, 
-1, 206.79, 1, -1, 0.397145,-99) , 
7, 194.54, 0, 0, 0.434757,-99) , 
3, 0.346739, 1, 0, 0.477413,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0957155);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473396,-99) , 
0, 86.544, 0, 0, 0.548259,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476178,-99) , 
3, -0.149869, 1, 0, 0.495951,-99) , 
10, 0.991198, 1, 0, 0.506535,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39925,-99) , 
10, 1.86777, 0, 0, 0.486724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329217,-99) , 
8, 237.117, 1, 0, 0.448225,-99) , 
3, 0.346739, 1, 0, 0.494144,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0703819);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.52731, 1, 1, 0.521095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450421,-99) , 
1, 504.516, 1, 0, 0.512086,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547704,-99) , 
NN(
0, 
0, 
-1, 110.884, 0, -1, 0.417604,-99) , 
6, 146.558, 1, 0, 0.449467,-99) , 
3, 0.346739, 1, 0, 0.498834,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0406891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570645,-99) , 
NN(
0, 
0, 
-1, 2.2111, 0, -1, 0.489582,-99) , 
5, -2.10073, 1, 0, 0.496106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397382,-99) , 
6, 244.736, 1, 0, 0.490378,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0577842);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403039,-99) , 
18, 0.196881, 0, 0, 0.510168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417135,-99) , 
12, 2.2111, 0, 0, 0.504643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407165,-99) , 
6, 244.736, 1, 0, 0.499006,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.11344);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458944,-99) , 
15, 0.990562, 1, 0, 0.516937,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38256,-99) , 
16, 0.914117, 1, 0, 0.449669,-99) , 
15, 0.904634, 0, 0, 0.503351,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385064,-99) , 
18, 0.727727, 0, 0, 0.481557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363215,-99) , 
2, 0.221406, 0, 0, 0.455078,-99) , 
4, 0, 0, 0, 0.489299,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0814466);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450039,-99) , 
10, 1.58903, 1, 0, 0.525409,-99) , 
NN(
0, 
0, 
-1, 0.0902845, 0, -1, 0.476115,-99) , 
14, 0.961363, 0, 0, 0.488307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398848,-99) , 
8, 378.092, 1, 0, 0.483105,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0853301);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498093,-99) , 
3, -0.0703847, 0, 0, 0.531644,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388676,-99) , 
7, 153.812, 0, 0, 0.490012,-99) , 
3, 0.0552433, 1, 0, 0.511753,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52814,-99) , 
NN(
0, 
0, 
-1, 0.329734, 0, -1, 0.442936,-99) , 
9, -1.32651, 1, 0, 0.46719,-99) , 
4, 0, 0, 0, 0.498818,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0837862);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497769,-99) , 
8, 203.676, 0, 0, 0.537427,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47362,-99) , 
17, 0.965643, 1, 0, 0.498599,-99) , 
5, -0.953887, 1, 0, 0.510774,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434368,-99) , 
5, 0.284037, 1, 0, 0.492641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360964,-99) , 
13, 0.963983, 0, 0, 0.459675,-99) , 
3, 0.346739, 1, 0, 0.500075,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0900713);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457901,-99) , 
16, 0.933285, 0, 0, 0.527512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405586,-99) , 
8, 198.826, 1, 0, 0.483747,-99) , 
1, 189.208, 0, 0, 0.509296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413688,-99) , 
8, 378.092, 1, 0, 0.503768,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0613721);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486598,-99) , 
7, 171.554, 1, 0, 0.507506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403426,-99) , 
14, 0.856941, 0, 0, 0.50092,-99) , 
NN(
0, 
0, 
-1, -2.23067, 0, -1, 0.430173,-99) , 
9, -1.83945, 0, 0, 0.493546,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0950551);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422339,-99) , 
13, 0.929417, 0, 0, 0.518791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404634,-99) , 
17, 0.982475, 0, 0, 0.475231,-99) , 
10, 2.16358, 1, 0, 0.506313,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548613,-99) , 
NN(
0, 
0, 
-1, 0.468851, 0, -1, 0.4299,-99) , 
7, 194.54, 0, 0, 0.458834,-99) , 
3, 0.346739, 1, 0, 0.49641,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0520004);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490106,-99) , 
17, 0.904988, 1, 0, 0.499475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412372,-99) , 
14, 0.856941, 0, 0, 0.494013,-99) , 
NN(
0, 
0, 
-1, 0.947057, 1, -1, 0.433345,-99) , 
9, -1.83945, 0, 0, 0.487741,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0587384);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481798,-99) , 
2, 0.442098, 1, 0, 0.507804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406577,-99) , 
2, 0.0357218, 0, 0, 0.502445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420489,-99) , 
18, 0.187201, 0, 0, 0.49807,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0370022);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497727,-99) , 
12, 2.73025, 1, 0, 0.506895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417639,-99) , 
12, 2.2111, 0, 0, 0.502108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419029,-99) , 
11, 1.9846, 0, 0, 0.497241,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0948283);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440889,-99) , 
17, 0.93338, 0, 0, 0.534748,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447621,-99) , 
5, 0.984866, 0, 0, 0.492385,-99) , 
5, -0.380464, 1, 0, 0.510634,-99) , 
NN(
0, 
0, 
-1, 0.947057, 1, -1, 0.446551,-99) , 
9, -1.83945, 0, 0, 0.504043,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0495606);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428201,-99) , 
2, 0.0902845, 0, 0, 0.508732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422132,-99) , 
12, 2.2111, 0, 0, 0.504122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4226,-99) , 
11, 1.9846, 0, 0, 0.499376,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.104633);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491495,-99) , 
15, 0.961478, 0, 0, 0.524211,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439005,-99) , 
5, -0.677257, 1, 0, 0.475088,-99) , 
3, 0.0552433, 1, 0, 0.500785,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442497,-99) , 
3, 0.022354, 0, 0, 0.513992,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382961,-99) , 
2, 0.510379, 0, 0, 0.435017,-99) , 
17, 0.990616, 0, 0, 0.467478,-99) , 
4, 0, 0, 0, 0.491139,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.114483);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455397,-99) , 
13, 0.992621, 1, 0, 0.56845,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390783,-99) , 
3, 0.111677, 0, 0, 0.469555,-99) , 
7, 178.336, 0, 0, 0.520482,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47961,-99) , 
16, 0.942847, 1, 0, 0.495533,-99) , 
NN(
0, 
0, 
-1, 3.20244, 0, -1, 0.402414,-99) , 
15, 0.958474, 0, 0, 0.480389,-99) , 
15, 0.933124, 1, 0, 0.494277,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.126619);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450191,-99) , 
9, -0.932946, 0, 0, 0.543427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424932,-99) , 
17, 0.933336, 0, 0, 0.524569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493398,-99) , 
17, 0.937804, 1, 0, 0.519212,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29362,-99) , 
5, 1.02263, 0, 0, 0.404619,-99) , 
9, 0.527616, 1, 0, 0.489839,-99) , 
3, 0.0552433, 1, 0, 0.507748,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0999495);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 124.018, 1, 1, 0.539044,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401191,-99) , 
3, 0.221069, 1, 0, 0.480404,-99) , 
9, 0.489491, 1, 0, 0.521089,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437057,-99) , 
6, 168.723, 1, 0, 0.512352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403803,-99) , 
16, 0.961544, 0, 0, 0.480888,-99) , 
4, 0, 0, 0, 0.509614,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0948165);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486453,-99) , 
9, -1.85445, 0, 0, 0.581936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442935,-99) , 
0, 111.646, 1, 0, 0.52738,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4724,-99) , 
8, 224.147, 1, 0, 0.502609,-99) , 
NN(
0, 
0, 
-1, 0.89494, 0, -1, 0.438459,-99) , 
8, 143.518, 0, 0, 0.487044,-99) , 
9, -1.32651, 1, 0, 0.496501,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0927993);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602865,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424055,-99) , 
3, 0.152434, 0, 0, 0.481063,-99) , 
8, 121.908, 1, 0, 0.534735,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460676,-99) , 
13, 0.98618, 0, 0, 0.553024,-99) , 
NN(
0, 
0, 
-1, 0.904725, 0, -1, 0.477375,-99) , 
10, 0.995179, 1, 0, 0.492501,-99) , 
9, -1.32651, 1, 0, 0.502372,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0761013);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 95.9776, 1, 1, 0.528234,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425113,-99) , 
10, 1.27308, 1, 0, 0.47446,-99) , 
17, 0.93338, 0, 0, 0.518353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441052,-99) , 
16, 0.885749, 0, 0, 0.5141,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0509892);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486929,-99) , 
15, 0.961568, 0, 0, 0.565403,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389359,-99) , 
17, 0.93205, 0, 0, 0.498142,-99) , 
17, 0.904988, 1, 0, 0.505965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437542,-99) , 
14, 0.857003, 0, 0, 0.501597,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.096016);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616536,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423454,-99) , 
16, 0.942737, 1, 0, 0.487726,-99) , 
15, 0.989981, 0, 0, 0.518984,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.61412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482398,-99) , 
9, -0.880036, 1, 0, 0.55665,-99) , 
NN(
0, 
0, 
-1, 0.990103, 1, -1, 0.471004,-99) , 
8, 95.9776, 1, 0, 0.484885,-99) , 
17, 0.942843, 1, 0, 0.493522,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0597855);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464384,-99) , 
0, 87.995, 0, 0, 0.515981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4371,-99) , 
16, 0.895237, 0, 0, 0.510823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447528,-99) , 
11, 1.9846, 0, 0, 0.507192,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.101157);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574501,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380124,-99) , 
2, 0.34192, 1, 0, 0.474187,-99) , 
10, 1.58903, 1, 0, 0.523708,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467453,-99) , 
10, 1.61908, 0, 0, 0.505705,-99) , 
NN(
0, 
0, 
-1, 186.59, 0, -1, 0.414433,-99) , 
14, 0.938288, 1, 0, 0.491535,-99) , 
14, 0.961363, 0, 0, 0.499536,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.102215);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449821,-99) , 
12, 2.7133, 0, 0, 0.5209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409448,-99) , 
13, 0.929417, 0, 0, 0.511046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577774,-99) , 
NN(
0, 
0, 
-1, 0.961764, 0, -1, 0.433262,-99) , 
9, 1.10131, 0, 0, 0.463847,-99) , 
10, 2.17552, 1, 0, 0.496895,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0512273);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548068,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563155,-99) , 
NN(
0, 
0, 
-1, 2.23172, 1, -1, 0.480161,-99) , 
10, 2.96242, 0, 0, 0.487427,-99) , 
5, -2.10073, 1, 0, 0.492291,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0851306);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43209,-99) , 
6, 187.052, 1, 0, 0.535935,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477035,-99) , 
9, -0.813564, 1, 0, 0.500994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394529,-99) , 
17, 0.895525, 0, 0, 0.493135,-99) , 
10, 0.995179, 1, 0, 0.50098,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0596117);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.498495, 0, 1, 0.538058,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461099,-99) , 
9, -0.813564, 0, 0, 0.496428,-99) , 
18, 0.63831, 1, 0, 0.508577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442242,-99) , 
12, 4.38966, 1, 0, 0.504441,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0419669);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479831,-99) , 
10, 1.61908, 1, 0, 0.564618,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393456,-99) , 
17, 0.93205, 0, 0, 0.493549,-99) , 
17, 0.904988, 1, 0, 0.501799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446691,-99) , 
14, 0.857003, 0, 0, 0.49834,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.074476);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421736,-99) , 
10, 1.44608, 1, 0, 0.529149,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488193,-99) , 
5, -1.66455, 1, 0, 0.501419,-99) , 
NN(
0, 
0, 
-1, 0.821515, 0, -1, 0.462095,-99) , 
16, 0.990112, 1, 0, 0.486706,-99) , 
17, 0.904988, 1, 0, 0.491618,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0738009);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545709,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481594,-99) , 
14, 0.913762, 1, 0, 0.51086,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363462,-99) , 
5, -0.0991554, 1, 0, 0.449295,-99) , 
3, 0.346739, 1, 0, 0.499201,-99) , 
5, 1.91323, 0, 0, 0.504865,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.112835);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.970591, 1, 1, 0.529593,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358188,-99) , 
7, 138.285, 1, 0, 0.465599,-99) , 
7, 153.812, 0, 0, 0.514676,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45862,-99) , 
16, 0.990017, 1, 0, 0.528938,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367078,-99) , 
10, 1.27308, 1, 0, 0.426378,-99) , 
17, 0.972846, 0, 0, 0.480229,-99) , 
14, 0.894952, 0, 0, 0.502642,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0891942);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494865,-99) , 
16, 0.952162, 1, 0, 0.52003,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409001,-99) , 
13, 0.992525, 1, 0, 0.474312,-99) , 
8, 190.123, 0, 0, 0.497138,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459466,-99) , 
15, 0.933243, 1, 0, 0.490807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397864,-99) , 
16, 0.961544, 0, 0, 0.464029,-99) , 
4, 0, 0, 0, 0.487893,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0996322);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494851,-99) , 
6, 167.493, 1, 0, 0.527011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405564,-99) , 
2, 0.570594, 0, 0, 0.46497,-99) , 
4, 0, 0, 0, 0.510409,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459468,-99) , 
19, 0.469397, 0, 0, 0.502933,-99) , 
NN(
0, 
0, 
-1, 1.73161, 0, -1, 0.425244,-99) , 
9, 0.212321, 1, 0, 0.476181,-99) , 
8, 190.016, 0, 0, 0.493074,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.107531);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498264,-99) , 
10, 1.61431, 0, 0, 0.592113,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381148,-99) , 
2, 0.30748, 0, 0, 0.457284,-99) , 
5, 0.388263, 0, 0, 0.52705,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424613,-99) , 
16, 0.942732, 0, 0, 0.518228,-99) , 
NN(
0, 
0, 
-1, 3.66347, 1, -1, 0.456251,-99) , 
17, 0.980685, 0, 0, 0.489624,-99) , 
6, 185.829, 0, 0, 0.499238,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0810705);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628368,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465037,-99) , 
7, 199.224, 0, 0, 0.50357,-99) , 
15, 0.989981, 0, 0, 0.534607,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522687,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474732,-99) , 
8, 190.016, 0, 0, 0.497448,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396084,-99) , 
3, 0.492487, 1, 0, 0.489514,-99) , 
17, 0.942843, 1, 0, 0.500767,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0740418);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489432,-99) , 
3, 0.289464, 1, 0, 0.574223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426392,-99) , 
2, 0.329433, 1, 0, 0.488486,-99) , 
3, 0.0801328, 0, 0, 0.535623,-99) , 
NN(
NN(
0, 
0, 
-1, -0.880036, 1, 1, 0.549251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430831,-99) , 
15, 0.990103, 1, 0, 0.481034,-99) , 
8, 95.9776, 1, 0, 0.492063,-99) , 
17, 0.942843, 1, 0, 0.502906,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0922772);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.289464, 1, 1, 0.575007,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427159,-99) , 
5, 0.123589, 0, 0, 0.488734,-99) , 
3, 0.0801328, 0, 0, 0.536131,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455655,-99) , 
8, 172.71, 1, 0, 0.528921,-99) , 
NN(
0, 
0, 
-1, 0.0549827, 1, -1, 0.469055,-99) , 
6, 146.558, 1, 0, 0.482145,-99) , 
17, 0.942843, 1, 0, 0.495546,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0957646);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.895211, 1, 1, 0.586775,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422365,-99) , 
14, 0.894849, 0, 0, 0.488763,-99) , 
15, 0.989986, 0, 0, 0.521091,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496935,-99) , 
10, 1.81013, 0, 0, 0.517108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379204,-99) , 
10, 2.37225, 1, 0, 0.490557,-99) , 
7, 171.554, 1, 0, 0.505435,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0954607);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 187.052, 0, 1, 0.52998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443274,-99) , 
10, 1.59015, 1, 0, 0.487689,-99) , 
17, 0.990162, 1, 0, 0.515277,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482736,-99) , 
16, 0.989986, 1, 0, 0.535125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370028,-99) , 
7, 198.44, 0, 0, 0.437895,-99) , 
15, 0.980525, 0, 0, 0.481029,-99) , 
4, 0, 0, 0, 0.505901,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0348261);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432062,-99) , 
0, 133.773, 1, 0, 0.493954,-99) , 
18, 0.303259, 1, 0, 0.499699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430278,-99) , 
18, 0.187201, 0, 0, 0.496096,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.10958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480434,-99) , 
17, 0.964448, 1, 0, 0.537241,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380502,-99) , 
9, 0.457994, 1, 0, 0.470139,-99) , 
5, 0.300039, 0, 0, 0.502282,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577665,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479506,-99) , 
8, 142.997, 1, 0, 0.517794,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38337,-99) , 
17, 0.91216, 1, 0, 0.424281,-99) , 
17, 0.98064, 0, 0, 0.47622,-99) , 
6, 166.194, 0, 0, 0.490091,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0639636);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476786,-99) , 
18, 0.909337, 1, 0, 0.512871,-99) , 
NN(
0, 
0, 
-1, 0.904959, 0, -1, 0.473457,-99) , 
3, 0.0549827, 1, 0, 0.494599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426479,-99) , 
16, 0.885749, 0, 0, 0.491095,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0766512);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.931818, 1, 1, 0.517019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416384,-99) , 
13, 0.992347, 0, 0, 0.467783,-99) , 
9, -1.22837, 0, 0, 0.505678,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421374,-99) , 
9, -0.48294, 1, 0, 0.503669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40417,-99) , 
5, -0.313797, 0, 0, 0.466435,-99) , 
15, 0.904634, 0, 0, 0.49765,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0834691);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495665,-99) , 
16, 0.929941, 1, 0, 0.507731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418889,-99) , 
2, 0.155065, 0, 0, 0.49729,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450244,-99) , 
10, 1.39538, 1, 0, 0.50102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351432,-99) , 
1, 292.559, 1, 0, 0.467023,-99) , 
18, 0.818753, 0, 0, 0.487457,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.111251);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441894,-99) , 
11, 2.73403, 0, 0, 0.521365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412074,-99) , 
13, 0.921457, 0, 0, 0.513188,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445836,-99) , 
1, 176.604, 0, 0, 0.505075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370685,-99) , 
1, 292.559, 1, 0, 0.474707,-99) , 
18, 0.818753, 0, 0, 0.500726,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0793691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565177,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383468,-99) , 
0, 87.995, 0, 0, 0.491366,-99) , 
16, 0.98787, 1, 0, 0.506784,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465319,-99) , 
13, 0.957017, 1, 0, 0.494475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408184,-99) , 
15, 0.895475, 0, 0, 0.477385,-99) , 
16, 0.980625, 0, 0, 0.493057,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0831229);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451478,-99) , 
3, 0.530868, 1, 0, 0.522296,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453038,-99) , 
2, 0.348009, 1, 0, 0.524331,-99) , 
NN(
0, 
0, 
-1, 0.928617, 0, -1, 0.470356,-99) , 
12, 2.7133, 1, 0, 0.482542,-99) , 
3, 0.419613, 0, 0, 0.488872,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0725865);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600386,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499071,-99) , 
10, 1.66746, 1, 0, 0.554934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464081,-99) , 
11, 2.86524, 0, 0, 0.526587,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548576,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46655,-99) , 
7, 157.972, 1, 0, 0.48449,-99) , 
11, 2.37039, 1, 0, 0.492552,-99) , 
14, 0.961363, 0, 0, 0.501249,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0657615);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488459,-99) , 
9, 0.138786, 0, 0, 0.533111,-99) , 
NN(
NN(
0, 
0, 
-1, 2.96242, 0, 1, 0.511824,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389312,-99) , 
5, 1.16588, 0, 0, 0.44563,-99) , 
9, 0.608524, 1, 0, 0.496122,-99) , 
3, -0.163379, 1, 0, 0.50466,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0715204);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475317,-99) , 
1, 348.236, 0, 0, 0.535328,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45503,-99) , 
7, 153.812, 0, 0, 0.496841,-99) , 
NN(
0, 
0, 
-1, 231.456, 0, -1, 0.421211,-99) , 
1, 324.34, 1, 0, 0.484516,-99) , 
3, -0.163379, 1, 0, 0.496234,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0813615);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472392,-99) , 
14, 0.904776, 0, 0, 0.532123,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583182,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483096,-99) , 
10, 2.96359, 0, 0, 0.495377,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422764,-99) , 
13, 0.956888, 1, 0, 0.45032,-99) , 
15, 0.942815, 0, 0, 0.480215,-99) , 
3, -0.163379, 1, 0, 0.492169,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0690792);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408323,-99) , 
2, 0.309231, 1, 0, 0.482753,-99) , 
3, 0.0549827, 1, 0, 0.525017,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489252,-99) , 
15, 0.929859, 1, 0, 0.501223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364937,-99) , 
14, 0.899777, 0, 0, 0.443716,-99) , 
15, 0.89506, 0, 0, 0.492409,-99) , 
14, 0.961363, 0, 0, 0.500732,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.081287);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484935,-99) , 
7, 151.026, 1, 0, 0.505841,-99) , 
16, 0.952306, 1, 0, 0.517475,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545393,-99) , 
NN(
0, 
0, 
-1, 0.221406, 0, -1, 0.452051,-99) , 
3, -0.159132, 1, 0, 0.482703,-99) , 
15, 0.94262, 0, 0, 0.504244,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0784098);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.329433, 0, 1, 0.535232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444467,-99) , 
11, 3.80974, 1, 0, 0.522918,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605231,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48267,-99) , 
10, 2.1285, 0, 0, 0.504616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42477,-99) , 
10, 2.53611, 1, 0, 0.489635,-99) , 
15, 0.94262, 0, 0, 0.51026,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0425788);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59345,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493206,-99) , 
18, 0.63831, 1, 0, 0.504713,-99) , 
6, 214.773, 0, 0, 0.510273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447077,-99) , 
6, 244.736, 1, 0, 0.506717,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0570325);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.866987, 1, 1, 0.521696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404106,-99) , 
11, 2.95973, 0, 0, 0.466994,-99) , 
2, 0.155065, 0, 0, 0.514566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439658,-99) , 
18, 0.187201, 0, 0, 0.510759,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0637869);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496837,-99) , 
17, 0.992393, 0, 0, 0.517531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437998,-99) , 
2, 0.155065, 0, 0, 0.508447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566314,-99) , 
NN(
0, 
0, 
-1, 0.712616, 1, -1, 0.461199,-99) , 
5, 1.67911, 0, 0, 0.481333,-99) , 
18, 0.818753, 0, 0, 0.499676,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0920302);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481257,-99) , 
9, -0.794491, 0, 0, 0.532624,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444884,-99) , 
6, 166.194, 0, 0, 0.49526,-99) , 
8, 190.123, 0, 0, 0.514074,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476239,-99) , 
6, 149.236, 1, 0, 0.502363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420428,-99) , 
13, 0.964024, 0, 0, 0.484578,-99) , 
4, 0, 0, 0, 0.506134,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0459548);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576698,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485214,-99) , 
14, 0.92328, 1, 0, 0.504441,-99) , 
6, 214.773, 0, 0, 0.508936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452765,-99) , 
6, 244.736, 1, 0, 0.505805,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0388926);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591578,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442582,-99) , 
9, -1.91129, 0, 0, 0.502739,-99) , 
14, 0.86379, 1, 0, 0.50814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453147,-99) , 
14, 0.857003, 0, 0, 0.504842,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0595923);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476381,-99) , 
10, 2.17552, 1, 0, 0.508473,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366077,-99) , 
10, 1.59888, 0, 0, 0.464104,-99) , 
13, 0.949916, 0, 0, 0.500867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448648,-99) , 
8, 378.092, 1, 0, 0.497804,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.106264);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428012,-99) , 
16, 0.942675, 0, 0, 0.526214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427769,-99) , 
2, 0.549211, 1, 0, 0.508375,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482692,-99) , 
17, 0.914345, 1, 0, 0.506349,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322362,-99) , 
9, -0.123337, 1, 0, 0.43922,-99) , 
10, 1.32279, 1, 0, 0.47999,-99) , 
10, 1.78207, 0, 0, 0.493159,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0749727);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472118,-99) , 
15, 0.971303, 1, 0, 0.543097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483584,-99) , 
17, 0.949223, 1, 0, 0.490379,-99) , 
5, -1.52731, 1, 0, 0.500099,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447406,-99) , 
14, 0.894849, 0, 0, 0.502603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371057,-99) , 
10, 2.13808, 1, 0, 0.464461,-99) , 
17, 0.93338, 0, 0, 0.493342,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0901346);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49964,-99) , 
2, 0.507838, 0, 0, 0.52749,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468178,-99) , 
0, 87.995, 1, 0, 0.492975,-99) , 
3, 0.0552433, 1, 0, 0.511851,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544124,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32194,-99) , 
7, 163.705, 1, 0, 0.427082,-99) , 
10, 1.27308, 1, 0, 0.469147,-99) , 
17, 0.93338, 0, 0, 0.503778,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
