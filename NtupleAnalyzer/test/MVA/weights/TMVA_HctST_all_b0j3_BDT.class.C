// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Oct  7 22:04:11 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 635365
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 11
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [14.2605009079,500]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.777953624725,0.747964262962]
HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB                                              'D'    [-7.62669229507,7.9473118782]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [75.9286422729,500]
TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB                                              'D'    [0.041234549135,1000]
TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB                                             'D'    [-9.81275558472,9.7086057663]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.368226826191,5.52105569839]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.0221648290753,11.5570325851]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [-10,0.799997866154]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [-10,0.797946274281]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [-10,0.799991369247]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 11 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "MVA_TOPHLEPBB", "HiggsEta_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "TopLepPt_TOPHLEPBB", "TopLepEta_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[11];
   double fVmax[11];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[11];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.382638572286462);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.285706, 0, 1, 0.729012,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417576,-99) , 
10, 0.285702, 0, 0, 0.508744,-99) , 
8, 0.5551, 0, 0, 0.609961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380988,-99) , 
4, 143.031, 0, 0, 0.472122,-99) , 
NN(
0, 
0, 
-1, 142.973, 0, -1, 0.223535,-99) , 
10, 0.285698, 0, 0, 0.314882,-99) , 
8, 0.285712, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.277721);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.283758, 0, 1, 0.636198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416677,-99) , 
8, 0.628569, 0, 0, 0.463964,-99) , 
7, 3.704, 1, 0, 0.582412,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406986,-99) , 
10, 0.55509, 0, 0, 0.4832,-99) , 
NN(
0, 
0, 
-1, 95.3609, 0, -1, 0.296808,-99) , 
10, 0.285698, 0, 0, 0.368339,-99) , 
8, 0.285712, 0, 0, 0.503652,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.188506);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 107.485, 0, 1, 0.665707,-99) , 
NN(
NN(
0, 
0, 
-1, 0.2857, 0, 1, 0.587569,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379216,-99) , 
10, 0.285705, 0, 0, 0.427163,-99) , 
4, 190.51, 0, 0, 0.463448,-99) , 
9, 0.283758, 0, 0, 0.497213,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.159346);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 107.485, 0, 1, 0.622536,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404178,-99) , 
0, 85.7292, 0, 0, 0.502233,-99) , 
NN(
0, 
0, 
-1, 2.77155, 1, -1, 0.385759,-99) , 
4, 95.2754, 0, 0, 0.460681,-99) , 
9, 0.283758, 0, 0, 0.487326,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.159715);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.285706, 0, 1, 0.607039,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452268,-99) , 
4, 142.892, 0, 0, 0.493608,-99) , 
8, 0.677549, 0, 0, 0.520207,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424719,-99) , 
7, 2.84701, 1, 0, 0.467225,-99) , 
NN(
0, 
0, 
-1, 0.285686, 0, -1, 0.358417,-99) , 
7, 3.31784, 1, 0, 0.412722,-99) , 
8, 0.285712, 0, 0, 0.480812,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.108737);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493291,-99) , 
0, 107.485, 0, 0, 0.57505,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476804,-99) , 
7, 3.00397, 1, 0, 0.507401,-99) , 
NN(
0, 
0, 
-1, 4.49487, 1, -1, 0.433612,-99) , 
7, 3.31784, 1, 0, 0.471239,-99) , 
9, 0.283758, 0, 0, 0.488162,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0977246);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.10517, 1, 1, 0.541748,-99) , 
NN(
0, 
0, 
-1, 182.589, 0, -1, 0.458688,-99) , 
0, 84.3958, 0, 0, 0.525129,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456112,-99) , 
10, 0.481622, 0, 0, 0.497669,-99) , 
NN(
0, 
0, 
-1, 2.3385, 1, -1, 0.425337,-99) , 
10, 0.285698, 0, 0, 0.454353,-99) , 
8, 0.285712, 0, 0, 0.499352,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0851823);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.283758, 0, 1, 0.528826,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419472,-99) , 
4, 96.0974, 0, 0, 0.4699,-99) , 
6, 2.30366, 1, 0, 0.507781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417138,-99) , 
7, 4.4164, 1, 0, 0.495268,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0840423);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.705533, 0, 1, 0.601966,-99) , 
NN(
0, 
0, 
-1, 162.75, 0, -1, 0.478935,-99) , 
10, 0.579584, 0, 0, 0.521579,-99) , 
NN(
0, 
0, 
-1, 4.22942, 1, -1, 0.462837,-99) , 
10, 0.285706, 0, 0, 0.486245,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0737061);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.185423, 0, 1, 0.562591,-99) , 
NN(
NN(
0, 
0, 
-1, -0.386209, 1, 1, 0.548523,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471251,-99) , 
0, 199.304, 0, 0, 0.481446,-99) , 
7, 2.76856, 1, 0, 0.48966,-99) , 
9, 0.283758, 0, 0, 0.501448,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0829989);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.43763, 1, 1, 0.551214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47188,-99) , 
7, 3.18548, 1, 0, 0.491768,-99) , 
0, 106.782, 0, 0, 0.520862,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442869,-99) , 
3, 163.947, 0, 0, 0.491346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401187,-99) , 
5, 1.40951, 1, 0, 0.469936,-99) , 
6, 2.57658, 1, 0, 0.505685,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0638605);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486536,-99) , 
4, 190.595, 0, 0, 0.50687,-99) , 
10, 0.702032, 0, 0, 0.526607,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504902,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451336,-99) , 
6, 0.846411, 0, 0, 0.497619,-99) , 
NN(
0, 
0, 
-1, -0.67638, 1, -1, 0.425716,-99) , 
6, 2.81526, 1, 0, 0.482625,-99) , 
10, 0.285706, 0, 0, 0.500132,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0776667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613908,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444935,-99) , 
10, 0.359176, 0, 0, 0.515013,-99) , 
9, 0.283758, 0, 0, 0.530988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484953,-99) , 
2, -1.33399, 1, 0, 0.494574,-99) , 
NN(
0, 
0, 
-1, 0.550489, 1, -1, 0.447918,-99) , 
6, 2.32884, 1, 0, 0.47672,-99) , 
10, 0.285706, 0, 0, 0.498305,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0620149);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.285706, 0, 1, 0.529402,-99) , 
NN(
0, 
0, 
-1, 0.647778, 0, -1, 0.462194,-99) , 
8, 0.383672, 0, 0, 0.514272,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476216,-99) , 
1, 0.0534109, 1, 0, 0.494698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436648,-99) , 
3, 156.704, 0, 0, 0.480373,-99) , 
8, 0.285712, 0, 0, 0.501948,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0556879);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.44446, 1, 1, 0.544357,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471207,-99) , 
0, 71.5356, 0, 0, 0.492737,-99) , 
0, 106.782, 0, 0, 0.5137,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485469,-99) , 
2, 1.87955, 0, 0, 0.494482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434477,-99) , 
5, 1.4663, 1, 0, 0.481093,-99) , 
6, 2.08584, 1, 0, 0.498112,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0351153);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.677543, 0, 1, 0.522689,-99) , 
NN(
0, 
0, 
-1, 4.22942, 1, -1, 0.490624,-99) , 
10, 0.285706, 0, 0, 0.503436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455411,-99) , 
3, 136.51, 0, 0, 0.498848,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0430526);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485389,-99) , 
6, 2.49774, 1, 0, 0.535064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541252,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477093,-99) , 
5, -0.516869, 1, 0, 0.491929,-99) , 
1, 0.38465, 0, 0, 0.496574,-99) , 
7, 2.76856, 1, 0, 0.501282,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0422084);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560652,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489439,-99) , 
2, 1.01292, 0, 0, 0.500353,-99) , 
7, 2.53315, 1, 0, 0.505565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468233,-99) , 
7, 4.4164, 1, 0, 0.500457,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0360089);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537212,-99) , 
NN(
NN(
0, 
0, 
-1, 106.782, 0, 1, 0.518979,-99) , 
NN(
0, 
0, 
-1, 68.061, 0, -1, 0.487288,-99) , 
6, 1.84163, 1, 0, 0.500065,-99) , 
4, 238.127, 0, 0, 0.504728,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.05205);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.60377, 1, 1, 0.535446,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473978,-99) , 
0, 144.232, 1, 0, 0.497271,-99) , 
7, 3.31784, 1, 0, 0.516917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490873,-99) , 
2, -0.957528, 1, 0, 0.499007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423016,-99) , 
3, 142.912, 0, 0, 0.488734,-99) , 
0, 106.782, 0, 0, 0.505126,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.036304);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490854,-99) , 
1, 0.185423, 0, 0, 0.529917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489642,-99) , 
4, 142.892, 1, 0, 0.502679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463413,-99) , 
3, 136.51, 0, 0, 0.498993,-99) , 
9, 0.283758, 0, 0, 0.503928,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0447865);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537714,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487033,-99) , 
0, 100.173, 0, 0, 0.505531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466384,-99) , 
0, 143.13, 1, 0, 0.499319,-99) , 
0, 222.435, 0, 0, 0.503898,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0311533);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.455155, 0, 1, 0.53162,-99) , 
NN(
NN(
0, 
0, 
-1, 83.6519, 1, 1, 0.51034,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471275,-99) , 
5, -0.516869, 1, 0, 0.486084,-99) , 
1, 0.0939995, 1, 0, 0.498386,-99) , 
9, 0.283758, 0, 0, 0.503678,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0781329);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493316,-99) , 
9, 0.455155, 0, 0, 0.523855,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466636,-99) , 
9, 0.157907, 0, 0, 0.498082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466718,-99) , 
9, -9.5103, 0, 0, 0.494431,-99) , 
9, 0.283758, 0, 0, 0.499115,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0507881);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 79.7776, 0, 1, 0.545611,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465267,-99) , 
3, 237.48, 1, 0, 0.50599,-99) , 
4, 143.366, 1, 0, 0.520821,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526788,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484383,-99) , 
3, 222.888, 0, 0, 0.492153,-99) , 
0, 218.957, 0, 0, 0.498434,-99) , 
6, 1.59509, 1, 0, 0.506197,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0228128);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499029,-99) , 
1, 0.185423, 0, 0, 0.530458,-99) , 
NN(
NN(
0, 
0, 
-1, 2.53315, 1, 1, 0.505437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478739,-99) , 
7, 4.4164, 1, 0, 0.501855,-99) , 
9, 0.283758, 0, 0, 0.506413,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0332455);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.285706, 0, 1, 0.531963,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489006,-99) , 
2, -1.66326, 1, 0, 0.494707,-99) , 
2, 2.00654, 0, 0, 0.497682,-99) , 
9, 0.283758, 0, 0, 0.503142,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0290702);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476327,-99) , 
4, 68.0642, 0, 0, 0.496771,-99) , 
3, 261.764, 0, 0, 0.501597,-99) , 
4, 238.127, 0, 0, 0.50502,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0328012);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487449,-99) , 
6, 2.49774, 1, 0, 0.525392,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494872,-99) , 
10, 0.702032, 0, 0, 0.509307,-99) , 
NN(
0, 
0, 
-1, 4.34786, 1, -1, 0.489278,-99) , 
10, 0.285706, 0, 0, 0.497241,-99) , 
7, 2.76856, 1, 0, 0.500673,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0335866);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528351,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479703,-99) , 
3, 142.646, 0, 0, 0.508716,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4811,-99) , 
0, 153.043, 1, 0, 0.50377,-99) , 
4, 238.127, 0, 0, 0.506841,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0421867);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491832,-99) , 
10, 0.285706, 0, 0, 0.521437,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476516,-99) , 
6, 2.82208, 1, 0, 0.509334,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485942,-99) , 
6, 2.57658, 0, 0, 0.493763,-99) , 
4, 95.2754, 1, 0, 0.499207,-99) , 
9, 0.283758, 0, 0, 0.502742,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0231361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498153,-99) , 
8, 0.677514, 0, 0, 0.52365,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4833,-99) , 
0, 94.9708, 0, 0, 0.499436,-99) , 
6, 0.858972, 1, 0, 0.502011,-99) , 
9, 0.283758, 0, 0, 0.505451,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0283588);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499463,-99) , 
1, 0.185423, 0, 0, 0.525499,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482989,-99) , 
4, 190.957, 1, 0, 0.50871,-99) , 
NN(
0, 
0, 
-1, -9.5103, 0, -1, 0.493197,-99) , 
6, 1.59509, 1, 0, 0.498586,-99) , 
9, 0.283758, 0, 0, 0.502863,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0276044);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.677514, 0, 1, 0.527372,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486543,-99) , 
5, 1.22386, 1, 0, 0.514502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494753,-99) , 
5, -2.33021, 1, 0, 0.498386,-99) , 
2, 1.26553, 0, 0, 0.502602,-99) , 
9, 0.283758, 0, 0, 0.506537,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.02302);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531068,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526565,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497152,-99) , 
2, 2.01436, 0, 0, 0.500505,-99) , 
3, 261.764, 0, 0, 0.504524,-99) , 
4, 238.127, 0, 0, 0.507839,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0454586);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558186,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487018,-99) , 
4, 72.6005, 0, 0, 0.507022,-99) , 
4, 190.51, 0, 0, 0.51582,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539506,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458796,-99) , 
0, 132.893, 1, 0, 0.485653,-99) , 
4, 95.3872, 1, 0, 0.499589,-99) , 
3, 197.092, 1, 0, 0.509502,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0375784);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 190.51, 0, 1, 0.515234,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480356,-99) , 
4, 95.3872, 1, 0, 0.494117,-99) , 
3, 197.092, 1, 0, 0.507198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475904,-99) , 
0, 60.5214, 0, 0, 0.50458,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0183164);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522747,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518941,-99) , 
NN(
0, 
0, 
-1, 1.34231, 1, -1, 0.494912,-99) , 
3, 261.764, 0, 0, 0.498616,-99) , 
4, 238.127, 0, 0, 0.501622,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0187184);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494208,-99) , 
7, 2.507, 1, 0, 0.523843,-99) , 
NN(
NN(
0, 
0, 
-1, -1.60295, 1, 1, 0.504534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481151,-99) , 
7, 4.44257, 1, 0, 0.501046,-99) , 
7, 2.76856, 1, 0, 0.503825,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0277371);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495264,-99) , 
6, 2.49774, 1, 0, 0.523124,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496449,-99) , 
4, 238.127, 0, 0, 0.502117,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468175,-99) , 
5, 0.231277, 0, 0, 0.484484,-99) , 
3, 237.48, 1, 0, 0.497762,-99) , 
7, 2.76856, 1, 0, 0.500852,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0294846);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546747,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488236,-99) , 
3, 149.255, 0, 0, 0.504429,-99) , 
4, 238.127, 0, 0, 0.508454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477534,-99) , 
4, 142.998, 1, 0, 0.49235,-99) , 
3, 237.48, 1, 0, 0.504679,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0501985);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469738,-99) , 
9, 0.0936133, 0, 0, 0.512151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432873,-99) , 
8, 0.160662, 0, 0, 0.503931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481645,-99) , 
9, -9.48581, 0, 0, 0.501759,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0361611);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486619,-99) , 
0, 108.191, 0, 0, 0.514741,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481633,-99) , 
10, 0.555094, 0, 0, 0.503041,-99) , 
NN(
0, 
0, 
-1, 4.34786, 1, -1, 0.488899,-99) , 
10, 0.285706, 0, 0, 0.494513,-99) , 
7, 2.76856, 1, 0, 0.496978,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0327388);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.417047, 0, 1, 0.517702,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473038,-99) , 
3, 258.929, 0, 0, 0.4908,-99) , 
3, 202.205, 1, 0, 0.507813,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494265,-99) , 
2, -0.397107, 0, 0, 0.51519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471846,-99) , 
1, 0.0831867, 1, 0, 0.492344,-99) , 
1, 0.266574, 0, 0, 0.49721,-99) , 
5, -0.516869, 1, 0, 0.502387,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0160691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518534,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498042,-99) , 
2, -1.69374, 1, 0, 0.500851,-99) , 
4, 238.127, 0, 0, 0.502814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475741,-99) , 
4, 142.998, 1, 0, 0.488955,-99) , 
1, -0.0513261, 0, 0, 0.499023,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0209789);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491299,-99) , 
8, 0.628521, 0, 0, 0.516971,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496621,-99) , 
2, 0.524508, 0, 0, 0.502331,-99) , 
9, 0.283758, 0, 0, 0.504705,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481061,-99) , 
6, 1.84163, 1, 0, 0.489124,-99) , 
1, -0.0513261, 0, 0, 0.500443,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0196244);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 143.558, 0, 1, 0.514993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485071,-99) , 
0, 85.6809, 0, 0, 0.502538,-99) , 
1, 0.0628605, 1, 0, 0.50549,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480975,-99) , 
4, 142.998, 1, 0, 0.490502,-99) , 
1, -0.0513261, 0, 0, 0.501391,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0154865);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51292,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482503,-99) , 
0, 70.9061, 0, 0, 0.499027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47722,-99) , 
0, 146.434, 1, 0, 0.496505,-99) , 
0, 199.304, 0, 0, 0.498868,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0276251);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484188,-99) , 
6, 2.32815, 1, 0, 0.496231,-99) , 
4, 238.127, 0, 0, 0.499659,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506935,-99) , 
NN(
0, 
0, 
-1, -0.0326164, 1, -1, 0.475384,-99) , 
2, -0.579196, 1, 0, 0.487161,-99) , 
3, 237.48, 1, 0, 0.496728,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.013829);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510648,-99) , 
NN(
0, 
0, 
-1, 238.127, 1, -1, 0.493714,-99) , 
0, 199.304, 0, 0, 0.496151,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0347074);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484112,-99) , 
7, 2.507, 1, 0, 0.510298,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46702,-99) , 
0, 83.6519, 0, 0, 0.506588,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487052,-99) , 
2, -1.61762, 1, 0, 0.49256,-99) , 
4, 95.2754, 1, 0, 0.496991,-99) , 
7, 2.76856, 1, 0, 0.498613,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0289831);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493558,-99) , 
2, -0.11272, 0, 0, 0.513049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490838,-99) , 
2, -1.07543, 1, 0, 0.496962,-99) , 
5, -1.0559, 1, 0, 0.502795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487788,-99) , 
7, 4.4164, 1, 0, 0.500742,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0283977);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537145,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475766,-99) , 
0, 80.3472, 1, 0, 0.500272,-99) , 
0, 106.782, 0, 0, 0.511075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514965,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490027,-99) , 
0, 120.125, 1, 0, 0.498049,-99) , 
0, 218.957, 0, 0, 0.501099,-99) , 
6, 1.59509, 1, 0, 0.504557,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0187059);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496916,-99) , 
4, 143.366, 1, 0, 0.513625,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494538,-99) , 
5, -0.516869, 1, 0, 0.499874,-99) , 
6, 1.59509, 1, 0, 0.503845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486801,-99) , 
0, 60.5214, 0, 0, 0.502421,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0270037);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533222,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481116,-99) , 
3, 182.589, 0, 0, 0.500909,-99) , 
0, 106.782, 0, 0, 0.510374,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496302,-99) , 
2, 2.02706, 0, 0, 0.501994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470869,-99) , 
5, -1.44646, 1, 0, 0.486664,-99) , 
4, 47.6583, 0, 0, 0.499596,-99) , 
6, 1.59509, 1, 0, 0.50333,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0202448);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490831,-99) , 
5, 0.627924, 1, 0, 0.520057,-99) , 
NN(
0, 
0, 
-1, 2.76856, 1, 1, 0.503727,-99) , 
2, 1.58409, 0, 0, 0.507101,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471127,-99) , 
6, 2.33875, 1, 0, 0.49052,-99) , 
5, -2.37605, 0, 0, 0.505031,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0332527);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.69009, 1, 1, 0.517189,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480842,-99) , 
4, 95.3707, 1, 0, 0.493978,-99) , 
7, 3.31784, 1, 0, 0.505899,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492475,-99) , 
2, 0.136356, 1, 0, 0.50171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459417,-99) , 
2, -1.69855, 0, 0, 0.495179,-99) , 
0, 106.782, 0, 0, 0.501407,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0427267);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477394,-99) , 
7, 4.48978, 1, 0, 0.517537,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471759,-99) , 
6, 2.3129, 1, 0, 0.494147,-99) , 
5, 0.412719, 1, 0, 0.508197,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49181,-99) , 
7, 3.49106, 1, 0, 0.508277,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480822,-99) , 
5, -2.57271, 1, 0, 0.486754,-99) , 
5, 0.20763, 0, 0, 0.495049,-99) , 
2, 0.531119, 0, 0, 0.500557,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.023581);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494344,-99) , 
5, 0.627924, 1, 0, 0.519245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494403,-99) , 
2, -1.24402, 1, 0, 0.500315,-99) , 
2, 1.58409, 0, 0, 0.504224,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473785,-99) , 
6, 2.33875, 1, 0, 0.488587,-99) , 
5, -2.37605, 0, 0, 0.502275,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0139167);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.29112, 0, 1, 0.505793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47641,-99) , 
4, 58.3368, 1, 0, 0.488646,-99) , 
5, -2.37605, 0, 0, 0.503655,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0216915);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513361,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491749,-99) , 
4, 113.415, 0, 0, 0.500423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478943,-99) , 
4, 238.127, 1, 0, 0.498526,-99) , 
0, 199.304, 0, 0, 0.500663,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0217394);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494176,-99) , 
0, 108.191, 0, 0, 0.515898,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505182,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472204,-99) , 
3, 129.779, 0, 0, 0.50238,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475359,-99) , 
5, 0.231277, 0, 0, 0.486854,-99) , 
3, 237.48, 1, 0, 0.498542,-99) , 
7, 2.76856, 1, 0, 0.500659,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0235158);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496942,-99) , 
7, 2.507, 1, 0, 0.515514,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517007,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510705,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489671,-99) , 
6, 2.82195, 0, 0, 0.493749,-99) , 
5, 2.2719, 0, 0, 0.495417,-99) , 
7, 2.76856, 1, 0, 0.497867,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0188447);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49653,-99) , 
6, 2.49774, 1, 0, 0.514604,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49389,-99) , 
7, 3.60557, 0, 0, 0.499944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481667,-99) , 
0, 60.5214, 0, 0, 0.498336,-99) , 
7, 2.76856, 1, 0, 0.500319,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0118569);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526837,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498922,-99) , 
4, 47.6583, 1, 0, 0.500955,-99) , 
7, 2.65018, 1, 0, 0.503273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487874,-99) , 
6, 3.06733, 1, 0, 0.501395,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0185806);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497778,-99) , 
7, 2.94578, 1, 0, 0.502276,-99) , 
2, 2.02706, 0, 0, 0.505175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474861,-99) , 
0, 108.467, 0, 0, 0.490144,-99) , 
4, 47.6583, 0, 0, 0.503487,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0156336);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.02706, 0, 1, 0.507378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479497,-99) , 
0, 108.467, 0, 0, 0.490259,-99) , 
4, 47.6583, 0, 0, 0.505456,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0196138);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523449,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462206,-99) , 
0, 71.0123, 0, 0, 0.501802,-99) , 
6, 0.753812, 1, 0, 0.503909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488242,-99) , 
6, 3.06733, 1, 0, 0.501998,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0235305);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487622,-99) , 
7, 3.48832, 1, 0, 0.512691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488916,-99) , 
3, 277.867, 1, 0, 0.506456,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494664,-99) , 
2, 2.02706, 0, 0, 0.498672,-99) , 
NN(
0, 
0, 
-1, -1.44646, 1, -1, 0.481676,-99) , 
4, 47.6583, 0, 0, 0.496249,-99) , 
6, 1.34972, 1, 0, 0.498931,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.016582);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495333,-99) , 
6, 1.3551, 1, 0, 0.498426,-99) , 
4, 238.127, 0, 0, 0.500983,-99) , 
3, 338.449, 0, 0, 0.502346,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0123407);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491358,-99) , 
9, 0.381699, 0, 0, 0.517524,-99) , 
NN(
0, 
0, 
-1, 2.2719, 0, 1, 0.502199,-99) , 
9, 0.283758, 0, 0, 0.504639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49075,-99) , 
0, 60.5214, 0, 0, 0.503481,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0172465);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.34045, 0, 1, 0.514978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496129,-99) , 
9, 0.283758, 0, 0, 0.499751,-99) , 
1, 0.0628605, 1, 0, 0.503354,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507226,-99) , 
NN(
0, 
0, 
-1, 131.733, 1, -1, 0.489066,-99) , 
8, 0.285704, 1, 0, 0.495919,-99) , 
1, -0.0513261, 0, 0, 0.50132,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0163336);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4985,-99) , 
7, 3.31784, 0, 0, 0.50907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496773,-99) , 
9, 0.283758, 0, 0, 0.50123,-99) , 
1, 0.138983, 1, 0, 0.504528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488803,-99) , 
1, -0.155131, 1, 0, 0.496976,-99) , 
1, -0.0513261, 0, 0, 0.502461,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0159654);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487897,-99) , 
7, 4.24684, 1, 0, 0.51157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499476,-99) , 
1, 0.405417, 0, 0, 0.503955,-99) , 
5, -1.44646, 1, 0, 0.506361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486186,-99) , 
0, 106.782, 0, 0, 0.496786,-99) , 
1, -0.0513261, 0, 0, 0.503741,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0220677);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529144,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496933,-99) , 
1, 0.12933, 1, 0, 0.514152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510975,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493535,-99) , 
6, 1.25965, 0, 0, 0.505968,-99) , 
0, 130.574, 0, 0, 0.507943,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488329,-99) , 
6, 1.84163, 1, 0, 0.49518,-99) , 
1, -0.0513261, 0, 0, 0.50445,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0165129);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.12933, 1, 1, 0.513776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485722,-99) , 
7, 4.22942, 1, 0, 0.50362,-99) , 
0, 130.574, 0, 0, 0.50607,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486643,-99) , 
0, 106.782, 0, 0, 0.496634,-99) , 
1, -0.0513261, 0, 0, 0.503488,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0155957);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490779,-99) , 
3, 202.427, 1, 0, 0.511386,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488173,-99) , 
5, -2.37605, 0, 0, 0.50153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468924,-99) , 
0, 72.4692, 0, 0, 0.499432,-99) , 
6, 0.858972, 1, 0, 0.500782,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0146336);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529164,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494677,-99) , 
3, 202.427, 1, 0, 0.511487,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496359,-99) , 
2, -1.69374, 1, 0, 0.498584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47281,-99) , 
0, 72.4692, 0, 0, 0.496926,-99) , 
6, 0.858972, 1, 0, 0.49857,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0136655);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498335,-99) , 
3, 202.427, 1, 0, 0.511582,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494752,-99) , 
1, 0.0199781, 0, 0, 0.50101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476459,-99) , 
0, 72.4692, 0, 0, 0.499431,-99) , 
6, 0.858972, 1, 0, 0.500803,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0271752);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.709414, 0, 1, 0.527948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485026,-99) , 
3, 182.589, 0, 0, 0.509019,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490192,-99) , 
6, 2.08107, 1, 0, 0.51346,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48926,-99) , 
4, 95.2893, 1, 0, 0.494974,-99) , 
9, 0.283758, 0, 0, 0.497982,-99) , 
0, 83.6519, 1, 0, 0.500223,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0135327);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511353,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51756,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489207,-99) , 
2, -0.952119, 0, 0, 0.497829,-99) , 
6, 0.759759, 1, 0, 0.499827,-99) , 
0, 199.304, 0, 0, 0.501489,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0132886);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511983,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513625,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483831,-99) , 
4, 68.0642, 0, 0, 0.496874,-99) , 
4, 238.127, 0, 0, 0.498663,-99) , 
3, 358.643, 0, 0, 0.49976,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0164788);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507943,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513574,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491848,-99) , 
6, 1.3551, 1, 0, 0.494835,-99) , 
4, 238.127, 0, 0, 0.49681,-99) , 
3, 338.449, 0, 0, 0.497852,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0190787);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.2857, 0, 1, 0.510118,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474569,-99) , 
6, 2.68594, 1, 0, 0.495568,-99) , 
0, 129.913, 0, 0, 0.500889,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484081,-99) , 
10, 0.2857, 1, 0, 0.500597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467977,-99) , 
3, 262.482, 0, 0, 0.492752,-99) , 
3, 237.48, 1, 0, 0.498981,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0251432);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493342,-99) , 
2, -0.0133947, 0, 0, 0.509349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47891,-99) , 
7, 4.23555, 1, 0, 0.500602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522191,-99) , 
NN(
0, 
0, 
-1, 1.11619, 0, -1, 0.491824,-99) , 
1, 0.398522, 0, 0, 0.494285,-99) , 
5, -1.44646, 1, 0, 0.49629,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0200247);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493009,-99) , 
0, 108.191, 0, 0, 0.509548,-99) , 
NN(
NN(
0, 
0, 
-1, 129.287, 0, 1, 0.504877,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484985,-99) , 
6, 2.08584, 0, 0, 0.49384,-99) , 
4, 142.892, 1, 0, 0.499916,-99) , 
7, 2.76856, 1, 0, 0.50109,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0196957);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495973,-99) , 
7, 2.37622, 1, 0, 0.509187,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494407,-99) , 
10, 0.702032, 0, 0, 0.50373,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463607,-99) , 
7, 4.34786, 1, 0, 0.494217,-99) , 
10, 0.285706, 0, 0, 0.497997,-99) , 
7, 2.76856, 1, 0, 0.49936,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0309953);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542802,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485389,-99) , 
4, 190.595, 0, 0, 0.494233,-99) , 
10, 0.677543, 0, 0, 0.503875,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536352,-99) , 
NN(
0, 
0, 
-1, -2.37605, 0, -1, 0.49127,-99) , 
7, 2.65317, 1, 0, 0.495572,-99) , 
10, 0.285706, 0, 0, 0.498868,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0163131);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499415,-99) , 
4, 95.5374, 1, 0, 0.506728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487707,-99) , 
4, 73.6096, 0, 0, 0.500025,-99) , 
0, 129.913, 0, 0, 0.502432,-99) , 
3, 358.643, 0, 0, 0.50334,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0218338);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 143.141, 1, 1, 0.51891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492385,-99) , 
5, 0.0828284, 1, 0, 0.50744,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49668,-99) , 
0, 102.376, 1, 0, 0.507102,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476349,-99) , 
4, 93.7218, 0, 0, 0.49151,-99) , 
7, 3.17859, 0, 0, 0.500255,-99) , 
0, 129.913, 0, 0, 0.502799,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0231702);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497871,-99) , 
1, 0.0879021, 1, 0, 0.51567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490712,-99) , 
3, 197.092, 1, 0, 0.506704,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49052,-99) , 
0, 69.3328, 0, 0, 0.505859,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477547,-99) , 
0, 97.3664, 0, 0, 0.490001,-99) , 
7, 3.17859, 0, 0, 0.498895,-99) , 
0, 129.913, 0, 0, 0.501659,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0234723);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.00396, 1, 1, 0.518642,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479635,-99) , 
6, 2.60032, 0, 0, 0.498248,-99) , 
7, 3.31784, 1, 0, 0.507767,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4966,-99) , 
1, 0.095236, 1, 0, 0.502583,-99) , 
NN(
0, 
0, 
-1, 2.62321, 1, -1, 0.489407,-99) , 
7, 3.17859, 0, 0, 0.496797,-99) , 
0, 129.913, 0, 0, 0.50068,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0122012);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0615654, 1, 1, 0.511513,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51896,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489602,-99) , 
3, 237.48, 1, 0, 0.499209,-99) , 
5, 2.2719, 0, 0, 0.500626,-99) , 
7, 2.76856, 1, 0, 0.501951,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0158686);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499406,-99) , 
1, 0.0615654, 1, 0, 0.508464,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494257,-99) , 
10, 0.555094, 0, 0, 0.504957,-99) , 
NN(
0, 
0, 
-1, 4.34786, 1, -1, 0.495009,-99) , 
10, 0.285706, 0, 0, 0.498962,-99) , 
7, 2.76856, 1, 0, 0.500118,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0169408);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510687,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481507,-99) , 
0, 83.6519, 0, 0, 0.507197,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476203,-99) , 
1, 0.328633, 1, 0, 0.498822,-99) , 
3, 163.435, 1, 0, 0.501763,-99) , 
3, 338.449, 0, 0, 0.502599,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0270069);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526576,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474613,-99) , 
0, 70.4344, 0, 0, 0.492402,-99) , 
4, 147.735, 0, 0, 0.505233,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492076,-99) , 
8, 0.653018, 0, 0, 0.512758,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49204,-99) , 
2, -1.7099, 1, 0, 0.495208,-99) , 
9, 0.283758, 0, 0, 0.498062,-99) , 
0, 83.6519, 1, 0, 0.499517,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.021689);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.479, 1, 1, 0.514206,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479654,-99) , 
5, 1.74071, 1, 0, 0.494049,-99) , 
5, 0.412719, 1, 0, 0.506148,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49839,-99) , 
7, 3.90943, 1, 0, 0.517356,-99) , 
NN(
0, 
0, 
-1, -0.0582017, 0, -1, 0.493906,-99) , 
5, 1.09227, 0, 0, 0.499685,-99) , 
2, 0.531119, 0, 0, 0.502393,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0107726);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51473,-99) , 
NN(
NN(
0, 
0, 
-1, 2.65018, 1, 1, 0.503887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487648,-99) , 
5, 1.69643, 1, 0, 0.502452,-99) , 
5, 2.2719, 0, 0, 0.503365,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0116886);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512039,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496465,-99) , 
7, 3.05065, 1, 0, 0.499139,-99) , 
7, 2.65018, 1, 0, 0.500235,-99) , 
5, 2.2719, 0, 0, 0.501113,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.023241);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484475,-99) , 
10, 0.285702, 0, 0, 0.49596,-99) , 
5, 0.550489, 0, 0, 0.50719,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494551,-99) , 
10, 0.285705, 1, 0, 0.503461,-99) , 
NN(
0, 
0, 
-1, 0.139046, 0, -1, 0.483578,-99) , 
9, 0.2834, 1, 0, 0.500397,-99) , 
1, 0.239325, 0, 0, 0.502102,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
