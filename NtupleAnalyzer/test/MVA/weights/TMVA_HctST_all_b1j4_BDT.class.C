// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Oct  7 23:51:14 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 1327708
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 19
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [16.0578918457,500]
TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD                                         'D'    [36.3427124023,1000]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.723065972328,0.76589858532]
MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD                                                'D'    [-0.879554510117,0.68883895874]
HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB                                              'D'    [-8.22883605957,8.02347660065]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [79.2921905518,500]
TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD                                         'D'    [50.8424568176,500]
TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB                                              'D'    [0.195636317134,1000]
TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB                                             'D'    [-7.79600000381,6.98760652542]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.388921141624,5.62723112106]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.0148286139593,10.440864563]
TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD                                     'D'    [0.0151111688465,11.9151525497]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [-10,1]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [-10,0.799999892712]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [-10,1]
TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD                                    'D'    [-10,1]
TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD                                    'D'    [-10,1]
TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.79971408844]
TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.790807247162]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 19 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "TopHadMass_TOPTOPLEPHAD", "MVA_TOPHLEPBB", "MVA_TOPTOPLEPHAD", "HiggsEta_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "TopLepMass_TOPTOPLEPHAD", "TopLepPt_TOPHLEPBB", "TopLepEta_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "TopLepTopHadDr_TOPTOPLEPHAD", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPTOPLEPHAD", "TopHadBJetCSVv2_TOPTOPLEPHAD", "TopHadWNonBJet1CSVv2_TOPTOPLEPHAD", "TopHadWNonBJet2CSVv2_TOPTOPLEPHAD" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';
      fType[12] = 'D';
      fType[13] = 'D';
      fType[14] = 'D';
      fType[15] = 'D';
      fType[16] = 'D';
      fType[17] = 'D';
      fType[18] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[19];
   double fVmax[19];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[19];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.264768650043512);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 331.341, 0, 1, 0.726526,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491065,-99) , 
7, 190.838, 0, 0, 0.559966,-99) , 
17, 0.285442, 0, 0, 0.624327,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39772,-99) , 
13, 0.457142, 0, 0, 0.460213,-99) , 
NN(
0, 
0, 
-1, 0.242055, 1, -1, 0.292211,-99) , 
13, 0.285713, 0, 0, 0.380398,-99) , 
1, 219.896, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.233627);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.285714, 0, 1, 0.681092,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458631,-99) , 
16, 0.47619, 0, 0, 0.55845,-99) , 
1, 405.636, 0, 0, 0.606561,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420124,-99) , 
3, 0.245717, 1, 0, 0.489835,-99) , 
NN(
0, 
0, 
-1, -9.51027, 0, -1, 0.359771,-99) , 
17, 0.285033, 0, 0, 0.406516,-99) , 
1, 219.896, 0, 0, 0.504575,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.14955);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.285714, 0, 1, 0.606585,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433045,-99) , 
3, 0.151298, 1, 0, 0.478983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.311094,-99) , 
18, -9.48639, 0, 0, 0.457663,-99) , 
1, 311.673, 0, 0, 0.502092,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.113788);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.285714, 0, 1, 0.583341,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427377,-99) , 
17, 0.193336, 0, 0, 0.480861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34339,-99) , 
18, -9.48639, 0, 0, 0.46379,-99) , 
1, 357.562, 0, 0, 0.492784,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.128572);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.285709, 0, 1, 0.585589,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540975,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443527,-99) , 
12, 0.955472, 0, 0, 0.479845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371812,-99) , 
18, -9.48615, 0, 0, 0.466321,-99) , 
7, 285.854, 0, 0, 0.483066,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.093059);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486426,-99) , 
13, 0.285714, 0, 0, 0.547169,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435174,-99) , 
15, 0.47619, 0, 0, 0.490628,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.434561,-99) , 
1, 180.563, 0, 0, 0.463282,-99) , 
1, 311.673, 0, 0, 0.488062,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0862831);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 442.783, 0, 1, 0.570045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488524,-99) , 
10, 3.46342, 1, 0, 0.544473,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509328,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451963,-99) , 
18, 0.140996, 0, 0, 0.476542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40293,-99) , 
18, -9.48639, 0, 0, 0.467603,-99) , 
1, 311.673, 0, 0, 0.490283,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0780288);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576318,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47523,-99) , 
14, 0.954914, 0, 0, 0.488528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417438,-99) , 
18, -9.48615, 0, 0, 0.480079,-99) , 
1, 495.227, 0, 0, 0.491637,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0795205);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609971,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421228,-99) , 
3, 0.390097, 1, 0, 0.507509,-99) , 
10, 2.47471, 1, 0, 0.523032,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469008,-99) , 
9, 1.62049, 1, 0, 0.482054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420664,-99) , 
0, 85.1925, 0, 0, 0.471365,-99) , 
7, 143.025, 0, 0, 0.499855,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0669937);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587804,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478295,-99) , 
14, 0.475838, 0, 0, 0.508353,-99) , 
7, 143.524, 0, 0, 0.543395,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490005,-99) , 
9, 1.39278, 1, 0, 0.503738,-99) , 
NN(
0, 
0, 
-1, 90.9341, 0, -1, 0.460064,-99) , 
0, 108.481, 0, 0, 0.486099,-99) , 
10, 2.49722, 1, 0, 0.497276,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0765043);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 269.567, 0, 1, 0.558731,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46621,-99) , 
15, 0.911047, 0, 0, 0.49796,-99) , 
16, 0.955472, 0, 0, 0.514067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449099,-99) , 
18, -9.48615, 0, 0, 0.50655,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0569202);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490067,-99) , 
6, 180.465, 0, 0, 0.509855,-99) , 
9, 1.39278, 1, 0, 0.519636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516231,-99) , 
NN(
0, 
0, 
-1, 179.461, 0, -1, 0.466976,-99) , 
0, 99.4583, 0, 0, 0.478689,-99) , 
0, 108.237, 0, 0, 0.503096,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0708131);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 357.562, 0, 1, 0.535065,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430839,-99) , 
12, 0.933334, 0, 0, 0.483305,-99) , 
14, 0.47619, 0, 0, 0.51557,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519911,-99) , 
NN(
0, 
0, 
-1, 0.926987, 0, -1, 0.448514,-99) , 
15, 0.990477, 0, 0, 0.471138,-99) , 
16, 0.47619, 0, 0, 0.504796,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0493305);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493304,-99) , 
13, 0.285714, 0, 0, 0.526081,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494078,-99) , 
6, 182.673, 0, 0, 0.517898,-99) , 
NN(
0, 
0, 
-1, 221.95, 0, -1, 0.478121,-99) , 
11, 2.84845, 1, 0, 0.487103,-99) , 
1, 357.562, 0, 0, 0.496407,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0507514);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 265.785, 0, 1, 0.53097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45785,-99) , 
0, 179.306, 0, 0, 0.491089,-99) , 
0, 145.548, 1, 0, 0.515389,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479152,-99) , 
14, 0.47619, 0, 0, 0.500967,-99) , 
NN(
0, 
0, 
-1, 99.4582, 0, -1, 0.46829,-99) , 
5, 179.461, 0, 0, 0.485671,-99) , 
0, 108.237, 0, 0, 0.503378,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0311109);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541629,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495,-99) , 
1, 145.6, 1, 0, 0.499765,-99) , 
1, 495.227, 0, 0, 0.504792,-99) , 
NN(
0, 
0, 
-1, 183.934, 0, -1, 0.464805,-99) , 
11, 3.98179, 1, 0, 0.499593,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0396696);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562145,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488031,-99) , 
5, 165.79, 0, 0, 0.506848,-99) , 
7, 143.524, 0, 0, 0.531092,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486745,-99) , 
14, 0.47619, 0, 0, 0.50199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457381,-99) , 
3, 0.390097, 1, 0, 0.497982,-99) , 
10, 2.49722, 1, 0, 0.504424,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0502297);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 269.567, 0, 1, 0.53598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486719,-99) , 
10, 2.47733, 1, 0, 0.494406,-99) , 
12, 0.975057, 0, 0, 0.509249,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476626,-99) , 
0, 108.894, 0, 0, 0.493768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424923,-99) , 
14, 0.933337, 0, 0, 0.470923,-99) , 
12, 0.47619, 0, 0, 0.502948,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0401954);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.92517, 0, 1, 0.528469,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486536,-99) , 
14, 0.47619, 0, 0, 0.50192,-99) , 
6, 221.95, 0, 0, 0.509847,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479594,-99) , 
2, 0.127327, 1, 0, 0.492642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437241,-99) , 
14, 0.933337, 0, 0, 0.474295,-99) , 
12, 0.47619, 0, 0, 0.504005,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0280393);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.657288, 0, 1, 0.50997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474186,-99) , 
18, -9.48639, 0, 0, 0.505946,-99) , 
NN(
0, 
0, 
-1, 183.934, 0, -1, 0.470839,-99) , 
11, 3.98179, 1, 0, 0.501379,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0320715);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498845,-99) , 
1, 265.785, 0, 0, 0.513071,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.486635,-99) , 
12, 0.900227, 0, 0, 0.502114,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479004,-99) , 
6, 180.465, 0, 0, 0.489468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443948,-99) , 
14, 0.933337, 0, 0, 0.474411,-99) , 
12, 0.47619, 0, 0, 0.497564,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0305217);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.985747, 0, 1, 0.51118,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456594,-99) , 
14, 0.980953, 0, 0, 0.479445,-99) , 
12, 0.70068, 0, 0, 0.506481,-99) , 
NN(
0, 
0, 
-1, 0.952383, 0, -1, 0.47732,-99) , 
12, 0.47619, 0, 0, 0.501692,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0308809);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498068,-99) , 
5, 162.521, 0, 0, 0.519742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489245,-99) , 
6, 221.95, 0, 0, 0.495545,-99) , 
4, -1.11219, 1, 0, 0.501622,-99) , 
NN(
0, 
0, 
-1, 0.47619, 1, -1, 0.472837,-99) , 
10, 3.98665, 1, 0, 0.497642,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.026009);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499934,-99) , 
1, 265.785, 0, 0, 0.510394,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465998,-99) , 
3, 0.0835499, 0, 0, 0.485279,-99) , 
0, 85.1925, 0, 0, 0.506017,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481448,-99) , 
1, 176.307, 0, 0, 0.494818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462327,-99) , 
0, 155.04, 1, 0, 0.487253,-99) , 
11, 3.41512, 1, 0, 0.500312,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0302757);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49111,-99) , 
0, 144.451, 1, 0, 0.511709,-99) , 
NN(
0, 
0, 
-1, 0.0835499, 0, -1, 0.4855,-99) , 
0, 85.1925, 0, 0, 0.507142,-99) , 
NN(
0, 
0, 
-1, 4.62941, 1, -1, 0.48728,-99) , 
11, 3.41512, 1, 0, 0.501104,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0243122);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52801,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479551,-99) , 
12, 0.700682, 0, 0, 0.503293,-99) , 
NN(
0, 
0, 
-1, 0.952383, 0, -1, 0.481906,-99) , 
12, 0.47619, 0, 0, 0.499848,-99) , 
7, 333.464, 0, 0, 0.502339,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0367994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 238.504, 0, 1, 0.511833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468805,-99) , 
10, 3.98665, 1, 0, 0.506096,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47145,-99) , 
1, 177.479, 0, 0, 0.500358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464922,-99) , 
7, 190.635, 1, 0, 0.48938,-99) , 
14, 0.47619, 0, 0, 0.499384,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0277073);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525079,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490187,-99) , 
3, 0.042682, 1, 0, 0.498328,-99) , 
6, 226.304, 0, 0, 0.50482,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51215,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.485445,-99) , 
4, 1.83212, 0, 0, 0.489374,-99) , 
8, -0.756187, 1, 0, 0.495647,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0208912);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522471,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49104,-99) , 
7, 127.153, 0, 0, 0.506977,-99) , 
NN(
0, 
0, 
-1, -9.48615, 0, -1, 0.49247,-99) , 
4, -1.26356, 1, 0, 0.495823,-99) , 
7, 333.464, 0, 0, 0.498178,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0320455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.871891, 0, 1, 0.514107,-99) , 
NN(
0, 
0, 
-1, 0.122047, 0, -1, 0.479342,-99) , 
18, 0.100971, 0, 0, 0.50342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48478,-99) , 
18, -9.48615, 0, 0, 0.501274,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0200181);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461773,-99) , 
3, 0.432776, 1, 0, 0.503579,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470022,-99) , 
13, 0.285712, 0, 0, 0.488631,-99) , 
3, -0.207386, 0, 0, 0.500929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476498,-99) , 
11, 4.54846, 1, 0, 0.499466,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0413343);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.3607, 0, 1, 0.518968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469071,-99) , 
3, 0.319362, 1, 0, 0.506651,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486856,-99) , 
7, 190.635, 1, 0, 0.5016,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461701,-99) , 
3, 0.238981, 0, 0, 0.477133,-99) , 
17, 0.285033, 1, 0, 0.492862,-99) , 
2, 0.269577, 0, 0, 0.496211,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0340937);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494577,-99) , 
9, 1.36174, 0, 0, 0.524419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474628,-99) , 
14, 0.475842, 0, 0, 0.507917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487718,-99) , 
17, 0.284049, 1, 0, 0.503143,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481955,-99) , 
6, 221.95, 0, 0, 0.485173,-99) , 
5, 199.494, 0, 0, 0.490967,-99) , 
7, 238.244, 0, 0, 0.494767,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0191151);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519102,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492829,-99) , 
8, -1.01692, 1, 0, 0.497599,-99) , 
NN(
0, 
0, 
-1, 0.126184, 0, -1, 0.48212,-99) , 
7, 63.6752, 0, 0, 0.495371,-99) , 
7, 333.464, 0, 0, 0.497464,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0197696);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493865,-99) , 
10, 2.89427, 1, 0, 0.524683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478771,-99) , 
10, 3.19587, 1, 0, 0.509238,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484769,-99) , 
0, 85.1925, 0, 0, 0.497542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476471,-99) , 
8, 2.05974, 1, 0, 0.495875,-99) , 
7, 238.244, 0, 0, 0.498869,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0237229);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498807,-99) , 
10, 2.89427, 1, 0, 0.524551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483706,-99) , 
10, 3.19587, 1, 0, 0.510809,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512209,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.491561,-99) , 
9, 0.887808, 1, 0, 0.493404,-99) , 
7, 238.244, 0, 0, 0.497302,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0238972);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.36174, 0, 1, 0.525798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486278,-99) , 
14, 0.475842, 0, 0, 0.512696,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488881,-99) , 
7, 102.271, 0, 0, 0.503211,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484873,-99) , 
2, 0.163846, 0, 0, 0.493796,-99) , 
5, 179.461, 0, 0, 0.498275,-99) , 
7, 238.244, 0, 0, 0.501504,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0149266);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.89427, 1, 1, 0.522315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487774,-99) , 
10, 3.19587, 1, 0, 0.510689,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482198,-99) , 
12, 0.650795, 0, 0, 0.498821,-99) , 
NN(
0, 
0, 
-1, 0.961907, 0, -1, 0.487305,-99) , 
12, 0.47619, 0, 0, 0.497032,-99) , 
7, 238.244, 0, 0, 0.50009,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0169692);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499453,-99) , 
9, 1.36174, 0, 0, 0.518575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491127,-99) , 
14, 0.475842, 0, 0, 0.509472,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507533,-99) , 
NN(
0, 
0, 
-1, 131.282, 1, -1, 0.493712,-99) , 
2, -0.188172, 1, 0, 0.495127,-99) , 
7, 238.244, 0, 0, 0.498338,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0241429);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494945,-99) , 
0, 131.512, 1, 0, 0.518085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496803,-99) , 
3, 0.0206655, 1, 0, 0.500552,-99) , 
7, 238.244, 0, 0, 0.504381,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480184,-99) , 
0, 146.239, 1, 0, 0.500944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475376,-99) , 
0, 109, 0, 0, 0.491929,-99) , 
3, -0.1327, 0, 0, 0.501155,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.026829);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494834,-99) , 
1, 151.834, 1, 0, 0.505222,-99) , 
1, 187.087, 0, 0, 0.511717,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494589,-99) , 
9, 1.64187, 1, 0, 0.504005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460822,-99) , 
9, 0.882592, 0, 0, 0.49034,-99) , 
0, 108.894, 0, 0, 0.49902,-99) , 
3, 0.166041, 0, 0, 0.502953,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0220116);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 201.889, 0, 1, 0.51329,-99) , 
NN(
NN(
0, 
0, 
-1, 1.64187, 1, 1, 0.507257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476564,-99) , 
9, 1.54082, 0, 0, 0.487004,-99) , 
0, 108.894, 0, 0, 0.499869,-99) , 
3, 0.166041, 0, 0, 0.504025,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0206549);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523442,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492293,-99) , 
0, 141.577, 1, 0, 0.5027,-99) , 
NN(
0, 
0, 
-1, 1.03872, 0, -1, 0.489309,-99) , 
0, 103.848, 0, 0, 0.498547,-99) , 
0, 62.1476, 1, 0, 0.500161,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0273409);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.800455, 1, 1, 0.51048,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46657,-99) , 
12, 0.971432, 0, 0, 0.484299,-99) , 
14, 0.650794, 0, 0, 0.505052,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490691,-99) , 
12, 0.988209, 0, 0, 0.500737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461544,-99) , 
12, 0.876192, 0, 0, 0.494085,-99) , 
14, 0.47619, 0, 0, 0.500648,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0130938);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514936,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513062,-99) , 
NN(
0, 
0, 
-1, -9.48615, 0, -1, 0.494977,-99) , 
10, 2.00074, 1, 0, 0.496726,-99) , 
4, -2.03748, 1, 0, 0.498213,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.018105);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530022,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476904,-99) , 
10, 3.03754, 1, 0, 0.497814,-99) , 
9, 2.08766, 0, 0, 0.509253,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513354,-99) , 
NN(
0, 
0, 
-1, 2.00074, 0, -1, 0.496296,-99) , 
9, 0.887808, 1, 0, 0.497814,-99) , 
7, 238.244, 0, 0, 0.500371,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.00932408);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 62.1476, 1, 1, 0.504055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4866,-99) , 
5, 379.798, 1, 0, 0.502923,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.022385);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531439,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494131,-99) , 
1, 186.012, 0, 0, 0.501132,-99) , 
6, 201.889, 0, 0, 0.50705,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484214,-99) , 
15, 0.47619, 0, 0, 0.501289,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473948,-99) , 
9, 2.34484, 0, 0, 0.484787,-99) , 
3, 0.0664553, 1, 0, 0.498132,-99) , 
3, 0.166041, 0, 0, 0.500894,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0355329);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.829937, 0, 1, 0.518861,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479939,-99) , 
3, 0.289487, 1, 0, 0.4969,-99) , 
13, 0.285713, 0, 0, 0.508558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485077,-99) , 
7, 190.702, 1, 0, 0.500796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465356,-99) , 
1, 311.673, 0, 0, 0.486944,-99) , 
17, 0.285442, 1, 0, 0.495784,-99) , 
3, 0.166041, 0, 0, 0.49974,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0163998);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519325,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495473,-99) , 
7, 238.244, 0, 0, 0.498677,-99) , 
9, 0.876884, 1, 0, 0.500723,-99) , 
NN(
0, 
0, 
-1, 289.289, 0, -1, 0.489178,-99) , 
3, -0.1327, 0, 0, 0.497733,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0207303);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524782,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49262,-99) , 
7, 95.4151, 1, 0, 0.500837,-99) , 
5, 199.494, 0, 0, 0.506391,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495601,-99) , 
9, 1.64187, 1, 0, 0.501458,-99) , 
NN(
0, 
0, 
-1, 0.882592, 0, -1, 0.490237,-99) , 
0, 108.894, 0, 0, 0.497364,-99) , 
3, 0.166041, 0, 0, 0.50016,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0113287);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 62.1476, 1, 1, 0.504465,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47902,-99) , 
13, 0.285712, 0, 0, 0.494527,-99) , 
3, -0.207386, 0, 0, 0.502663,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.016236);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512915,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494753,-99) , 
13, 0.285712, 0, 0, 0.502115,-99) , 
NN(
0, 
0, 
-1, 1.97217, 0, -1, 0.489423,-99) , 
0, 136.767, 1, 0, 0.499162,-99) , 
0, 269.551, 0, 0, 0.500236,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0319299);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 223.07, 0, 1, 0.508454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488568,-99) , 
9, 0.80466, 1, 0, 0.494747,-99) , 
9, 1.63614, 0, 0, 0.503365,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538849,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474759,-99) , 
3, 0.240727, 0, 0, 0.485485,-99) , 
13, 0.652984, 0, 0, 0.495559,-99) , 
17, 0.285442, 1, 0, 0.500505,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0121767);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509864,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495325,-99) , 
4, -2.03748, 1, 0, 0.496576,-99) , 
6, 328.892, 0, 0, 0.498047,-99) , 
0, 62.1476, 1, 0, 0.498955,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0202235);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.11011, 1, 1, 0.512189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486688,-99) , 
10, 3.98665, 1, 0, 0.50617,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492745,-99) , 
1, 449.339, 0, 0, 0.495715,-99) , 
8, -2.16415, 1, 0, 0.498176,-99) , 
4, 1.0582, 0, 0, 0.500556,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0188884);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.137389, 0, 1, 0.513314,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494825,-99) , 
15, 0.800455, 1, 0, 0.501347,-99) , 
15, 0.47619, 1, 0, 0.503596,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495243,-99) , 
8, -0.187012, 1, 0, 0.502892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487594,-99) , 
1, 361.776, 1, 0, 0.495752,-99) , 
3, -0.1327, 0, 0, 0.501565,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0120638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527605,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49092,-99) , 
9, 2.38639, 1, 0, 0.500046,-99) , 
7, 190.635, 0, 0, 0.50851,-99) , 
NN(
NN(
0, 
0, 
-1, 264.727, 0, 1, 0.502427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48798,-99) , 
3, -0.282071, 0, 0, 0.500729,-99) , 
4, -1.26356, 1, 0, 0.502492,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0178186);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524597,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493598,-99) , 
3, 0.141165, 0, 0, 0.499894,-99) , 
7, 190.635, 0, 0, 0.507479,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459005,-99) , 
17, 0.122048, 0, 0, 0.499728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488123,-99) , 
18, -9.48615, 0, 0, 0.498422,-99) , 
4, -1.26356, 1, 0, 0.500475,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0153711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493681,-99) , 
2, 0.13204, 0, 0, 0.501276,-99) , 
7, 190.635, 0, 0, 0.507071,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494458,-99) , 
13, 0.285714, 1, 0, 0.503952,-99) , 
NN(
0, 
0, 
-1, -0.281671, 0, -1, 0.494082,-99) , 
9, 2.84021, 0, 0, 0.495679,-99) , 
4, -1.26356, 1, 0, 0.498261,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0178567);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49618,-99) , 
15, 0.925171, 0, 0, 0.511024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486911,-99) , 
15, 0.47619, 0, 0, 0.505639,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49718,-99) , 
7, 238.244, 0, 0, 0.500355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473572,-99) , 
3, 0.427829, 1, 0, 0.498454,-99) , 
6, 221.95, 0, 0, 0.500527,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.022855);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 265.785, 0, 1, 0.509762,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468275,-99) , 
1, 267.828, 1, 0, 0.497879,-99) , 
0, 92.874, 0, 0, 0.50538,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488481,-99) , 
2, 0.10951, 1, 0, 0.502315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48049,-99) , 
10, 3.95895, 1, 0, 0.498642,-99) , 
0, 131.282, 1, 0, 0.503094,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0160912);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516266,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492358,-99) , 
1, 252.674, 0, 0, 0.500709,-99) , 
1, 174.008, 1, 0, 0.505462,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509592,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489345,-99) , 
10, 3.98665, 1, 0, 0.504226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493761,-99) , 
0, 200.417, 0, 0, 0.49562,-99) , 
4, 1.38988, 0, 0, 0.498107,-99) , 
4, -1.26356, 1, 0, 0.499774,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0114269);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511566,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486561,-99) , 
15, 0.47619, 0, 0, 0.506013,-99) , 
NN(
0, 
0, 
-1, 0.362577, 1, -1, 0.497398,-99) , 
6, 221.95, 0, 0, 0.49987,-99) , 
0, 62.1476, 1, 0, 0.500627,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0100132);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.0863281, 1, 1, 0.50396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485362,-99) , 
8, 2.05974, 1, 0, 0.502766,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489792,-99) , 
5, 379.798, 1, 0, 0.501924,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0181304);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494707,-99) , 
0, 95.0685, 0, 0, 0.50447,-99) , 
NN(
0, 
0, 
-1, 2.48302, 0, -1, 0.49396,-99) , 
9, 2.28444, 1, 0, 0.501361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482372,-99) , 
13, 0.285714, 1, 0, 0.494811,-99) , 
0, 154.327, 1, 0, 0.500046,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0194353);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488012,-99) , 
13, 0.285709, 1, 0, 0.513224,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491527,-99) , 
13, 0.285713, 0, 0, 0.500235,-99) , 
0, 75.3159, 1, 0, 0.502116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482282,-99) , 
3, 0.00930523, 1, 0, 0.495055,-99) , 
0, 154.327, 1, 0, 0.500698,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0263381);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 145.799, 1, 1, 0.506807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488554,-99) , 
1, 359.35, 1, 0, 0.502551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475218,-99) , 
16, 0.931656, 0, 0, 0.48557,-99) , 
17, 0.530334, 0, 0, 0.495655,-99) , 
17, 0.285442, 1, 0, 0.500025,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0224239);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508843,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495881,-99) , 
2, 0.257621, 0, 0, 0.502043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488897,-99) , 
1, 145.601, 1, 0, 0.494175,-99) , 
1, 265.785, 0, 0, 0.497228,-99) , 
0, 62.1476, 1, 0, 0.497978,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0298359);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491668,-99) , 
10, 2.49722, 0, 0, 0.50687,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487944,-99) , 
10, 2.89005, 1, 0, 0.496998,-99) , 
7, 190.709, 1, 0, 0.502972,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550891,-99) , 
NN(
0, 
0, 
-1, 182.673, 0, -1, 0.482893,-99) , 
1, 134.675, 1, 0, 0.496397,-99) , 
1, 174.008, 0, 0, 0.501053,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0266365);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483405,-99) , 
1, 174.745, 0, 0, 0.495686,-99) , 
17, 0.284049, 0, 0, 0.505934,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497261,-99) , 
1, 223.915, 1, 0, 0.504019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481297,-99) , 
17, 0.505845, 0, 0, 0.49218,-99) , 
17, 0.285442, 1, 0, 0.499724,-99) , 
3, 0.240727, 0, 0, 0.501102,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0231662);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.800455, 1, 1, 0.510896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493862,-99) , 
15, 0.47619, 0, 0, 0.507472,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540982,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488288,-99) , 
1, 190.865, 0, 0, 0.494937,-99) , 
1, 134.675, 1, 0, 0.499234,-99) , 
1, 265.785, 0, 0, 0.502362,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0197326);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52362,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485228,-99) , 
9, 1.84203, 0, 0, 0.500301,-99) , 
6, 180.595, 0, 0, 0.509035,-99) , 
NN(
NN(
0, 
0, 
-1, 0.13403, 0, 1, 0.503516,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507825,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476724,-99) , 
14, 0.659543, 0, 0, 0.492211,-99) , 
17, 0.285442, 1, 0, 0.499416,-99) , 
3, 0.240727, 0, 0, 0.501551,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0208522);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.284049, 0, 1, 0.51261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487235,-99) , 
3, 0.432775, 1, 0, 0.506691,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497496,-99) , 
2, 0.257621, 0, 0, 0.500977,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487044,-99) , 
1, 134.675, 1, 0, 0.491802,-99) , 
1, 265.785, 0, 0, 0.496278,-99) , 
3, 0.240727, 0, 0, 0.498589,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0337729);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.114122, 1, 1, 0.52031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48052,-99) , 
16, 0.923811, 0, 0, 0.50813,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486214,-99) , 
15, 0.676925, 0, 0, 0.50868,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486452,-99) , 
15, 0.990498, 0, 0, 0.494081,-99) , 
15, 0.800455, 1, 0, 0.498823,-99) , 
15, 0.47619, 1, 0, 0.500665,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0105394);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510242,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497821,-99) , 
14, 0.475838, 0, 0, 0.50984,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480265,-99) , 
7, 285.854, 1, 0, 0.498082,-99) , 
11, 2.84845, 1, 0, 0.500725,-99) , 
1, 495.227, 0, 0, 0.501838,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0156283);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511402,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48885,-99) , 
7, 63.6752, 0, 0, 0.501563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484251,-99) , 
9, 1.34042, 1, 0, 0.491377,-99) , 
2, 0.259101, 1, 0, 0.499001,-99) , 
7, 333.464, 0, 0, 0.500082,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0182268);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 181.445, 1, 1, 0.513987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49271,-99) , 
14, 0.475838, 0, 0, 0.504259,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494018,-99) , 
3, -0.160125, 0, 0, 0.508114,-99) , 
NN(
0, 
0, 
-1, 285.854, 1, -1, 0.493002,-99) , 
1, 357.562, 0, 0, 0.49667,-99) , 
11, 2.84845, 1, 0, 0.498337,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0117344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494176,-99) , 
5, 179.461, 0, 0, 0.508326,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496691,-99) , 
3, 0.1447, 0, 0, 0.498564,-99) , 
2, 0.397719, 0, 0, 0.499608,-99) , 
3, 0.315412, 0, 0, 0.500874,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0171619);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497109,-99) , 
5, 179.461, 0, 0, 0.508822,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497769,-99) , 
0, 155, 1, 0, 0.504623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49344,-99) , 
1, 134.675, 1, 0, 0.497798,-99) , 
1, 265.785, 0, 0, 0.50083,-99) , 
3, 0.315412, 0, 0, 0.501989,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0140563);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496346,-99) , 
0, 108.481, 1, 0, 0.509548,-99) , 
NN(
NN(
0, 
0, 
-1, 1.39278, 1, 1, 0.504932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478085,-99) , 
9, 0.877264, 0, 0, 0.497624,-99) , 
0, 108.237, 0, 0, 0.502115,-99) , 
3, 0.315412, 0, 0, 0.503193,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0119399);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496363,-99) , 
9, 1.82789, 0, 0, 0.509403,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506637,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496141,-99) , 
2, -0.0858459, 1, 0, 0.497954,-99) , 
0, 200.417, 0, 0, 0.499225,-99) , 
3, 0.315412, 0, 0, 0.500701,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0102172);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 180.595, 0, 1, 0.509183,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509434,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496375,-99) , 
8, -0.772743, 1, 0, 0.49955,-99) , 
10, 2.00242, 1, 0, 0.500565,-99) , 
3, 0.315412, 0, 0, 0.501815,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0181783);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498962,-99) , 
15, 0.925171, 0, 0, 0.509153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492924,-99) , 
15, 0.47619, 0, 0, 0.505532,-99) , 
NN(
NN(
0, 
0, 
-1, 0.107429, 0, 1, 0.512067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504607,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486979,-99) , 
15, 0.950114, 1, 0, 0.497191,-99) , 
15, 0.47619, 1, 0, 0.499982,-99) , 
6, 221.95, 0, 0, 0.501582,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0168711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.954853, 0, 1, 0.512595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488475,-99) , 
4, -1.27645, 1, 0, 0.49982,-99) , 
4, -0.376437, 0, 0, 0.506984,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495656,-99) , 
3, 0.107429, 0, 0, 0.507525,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493055,-99) , 
15, 0.800455, 1, 0, 0.49647,-99) , 
15, 0.47619, 1, 0, 0.498544,-99) , 
6, 221.95, 0, 0, 0.500976,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.00944333);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509739,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495103,-99) , 
10, 2.9937, 0, 0, 0.498999,-99) , 
6, 307.504, 0, 0, 0.50039,-99) , 
7, 333.464, 0, 0, 0.501204,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0171063);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525487,-99) , 
NN(
0, 
0, 
-1, 180.571, 1, -1, 0.492535,-99) , 
2, 0.138865, 0, 0, 0.505769,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498966,-99) , 
8, 0.148817, 0, 0, 0.504117,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491876,-99) , 
9, 2.84722, 0, 0, 0.494586,-99) , 
2, 0.127771, 1, 0, 0.499279,-99) , 
10, 2.49722, 1, 0, 0.500539,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0199977);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490559,-99) , 
1, 315.936, 1, 0, 0.509195,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480027,-99) , 
16, 0.650794, 0, 0, 0.500986,-99) , 
16, 0.47619, 1, 0, 0.502985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492308,-99) , 
11, 4.54846, 1, 0, 0.502344,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0204857);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 203.363, 0, 1, 0.509549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486957,-99) , 
15, 0.904765, 0, 0, 0.504255,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519131,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497633,-99) , 
16, 0.990498, 0, 0, 0.506456,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487607,-99) , 
3, 0.244307, 0, 0, 0.49178,-99) , 
16, 0.900227, 0, 0, 0.498629,-99) , 
16, 0.47619, 1, 0, 0.499995,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0172713);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508766,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493102,-99) , 
12, 0.950114, 1, 0, 0.501598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478382,-99) , 
6, 180.465, 1, 0, 0.491964,-99) , 
12, 0.47619, 0, 0, 0.500045,-99) , 
7, 333.464, 0, 0, 0.500804,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0121173);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513938,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486674,-99) , 
6, 284.37, 0, 0, 0.500264,-99) , 
6, 248.431, 1, 0, 0.503837,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494586,-99) , 
5, 180.571, 1, 0, 0.5066,-99) , 
NN(
0, 
0, 
-1, 0.362577, 1, -1, 0.496774,-99) , 
15, 0.47619, 1, 0, 0.498617,-99) , 
6, 221.95, 0, 0, 0.500121,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0165299);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 143.107, 0, 1, 0.513432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495152,-99) , 
1, 223.915, 1, 0, 0.505507,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498076,-99) , 
0, 134.608, 1, 0, 0.508285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491344,-99) , 
1, 193.674, 0, 0, 0.496603,-99) , 
1, 311.673, 0, 0, 0.500104,-99) , 
11, 2.84845, 1, 0, 0.501292,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0120262);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507772,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512299,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50918,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496338,-99) , 
16, 0.47619, 1, 0, 0.499402,-99) , 
1, 145.6, 1, 0, 0.500815,-99) , 
1, 495.227, 0, 0, 0.501628,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0178241);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.61956, 1, 1, 0.506736,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47816,-99) , 
9, 1.60451, 0, 0, 0.496338,-99) , 
12, 0.85034, 0, 0, 0.503373,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481689,-99) , 
14, 0.952383, 0, 0, 0.496362,-99) , 
12, 0.47619, 0, 0, 0.502222,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.010174);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50788,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49712,-99) , 
9, 1.36944, 1, 0, 0.499636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477687,-99) , 
14, 0.952383, 0, 0, 0.492155,-99) , 
12, 0.47619, 0, 0, 0.498441,-99) , 
3, 0.390097, 0, 0, 0.499226,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0100857);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493723,-99) , 
2, 0.127771, 1, 0, 0.498171,-99) , 
10, 2.00074, 1, 0, 0.499156,-99) , 
4, -2.03748, 1, 0, 0.499834,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00716413);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499791,-99) , 
11, 3.98396, 0, 0, 0.501577,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485129,-99) , 
11, 3.09504, 1, 0, 0.492452,-99) , 
8, 1.35576, 1, 0, 0.500047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490143,-99) , 
5, 379.798, 1, 0, 0.499405,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.00827264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.0863281, 1, 1, 0.502948,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485702,-99) , 
4, 0.281382, 1, 0, 0.492666,-99) , 
8, 1.35576, 1, 0, 0.501223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491934,-99) , 
5, 379.798, 1, 0, 0.500621,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.012703);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497853,-99) , 
12, 0.952489, 1, 0, 0.50318,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476063,-99) , 
9, 1.12431, 0, 0, 0.495951,-99) , 
12, 0.900227, 0, 0, 0.500187,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496613,-99) , 
14, 0.971116, 0, 0, 0.500189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483958,-99) , 
4, -0.490234, 0, 0, 0.494042,-99) , 
12, 0.47619, 0, 0, 0.499178,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0125166);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495693,-99) , 
6, 180.595, 0, 0, 0.50439,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489509,-99) , 
3, -0.196725, 0, 0, 0.500241,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479828,-99) , 
6, 183.934, 0, 0, 0.492106,-99) , 
11, 3.70572, 1, 0, 0.498702,-99) , 
3, 0.315412, 0, 0, 0.499527,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
