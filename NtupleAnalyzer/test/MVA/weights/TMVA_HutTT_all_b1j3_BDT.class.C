// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Oct  7 23:16:25 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 1380718
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [15.3719539642,500]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.728321492672,0.764544904232]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [74.305809021,500]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.37183958292,5.6130604744]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.00994320120662,10.9641227722]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [-10,1]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [-10,0.799996852875]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [-10,1]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 8 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "MVA_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.16073408251152);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.28571, 0, 1, 0.603115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379645,-99) , 
4, 3.46611, 1, 0, 0.467399,-99) , 
5, 0.954998, 0, 0, 0.516919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283642,-99) , 
6, -9.48571, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.146028);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.993544, 0, 1, 0.619342,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452344,-99) , 
7, 0.475836, 0, 0, 0.511874,-99) , 
5, 0.966106, 0, 0, 0.557071,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436137,-99) , 
5, 0.954998, 0, 0, 0.467291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317403,-99) , 
6, -9.5102, 0, 0, 0.452578,-99) , 
6, 0.285711, 0, 0, 0.481574,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.0975556);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479381,-99) , 
6, 0.173665, 0, 0, 0.512933,-99) , 
NN(
0, 
0, 
-1, 0.865644, 1, -1, 0.399291,-99) , 
4, 4.19044, 1, 0, 0.49935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349849,-99) , 
6, -9.48571, 0, 0, 0.488919,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.110184);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.84375, 1, 1, 0.557043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467254,-99) , 
7, 0.47619, 0, 0, 0.501139,-99) , 
3, 1.85625, 1, 0, 0.529465,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464224,-99) , 
7, 0.975057, 0, 0, 0.498074,-99) , 
NN(
0, 
0, 
-1, 0.91429, 0, -1, 0.421676,-99) , 
7, 0.47619, 0, 0, 0.46107,-99) , 
4, 3.13971, 1, 0, 0.492668,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.0841621);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497633,-99) , 
7, 0.28571, 0, 0, 0.535934,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398628,-99) , 
7, 0.47619, 0, 0, 0.479082,-99) , 
5, 0.909996, 0, 0, 0.505616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373605,-99) , 
6, -9.48571, 0, 0, 0.496492,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.0803279);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.61261, 1, 1, 0.540153,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.469163,-99) , 
5, 0.909996, 0, 0, 0.502287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393501,-99) , 
6, -9.48571, 0, 0, 0.494822,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0461758);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577829,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430695,-99) , 
4, 4.19044, 1, 0, 0.494683,-99) , 
6, 0.542096, 0, 0, 0.503638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412826,-99) , 
6, -9.48571, 0, 0, 0.49744,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0846585);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.54991,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426311,-99) , 
5, 0.47619, 0, 0, 0.508175,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.462114,-99) , 
3, 1.61975, 1, 0, 0.482164,-99) , 
4, 2.61808, 1, 0, 0.489749,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0692319);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555187,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476321,-99) , 
7, 0.475839, 0, 0, 0.501327,-99) , 
4, 2.94641, 1, 0, 0.513536,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473585,-99) , 
6, 0.457139, 0, 0, 0.507133,-99) , 
NN(
0, 
0, 
-1, 0.47619, 0, -1, 0.460504,-99) , 
6, 0.28571, 0, 0, 0.47351,-99) , 
2, 175.662, 0, 0, 0.493947,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0518066);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475423,-99) , 
7, 0.47619, 0, 0, 0.495322,-99) , 
6, 0.542096, 0, 0, 0.502337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436941,-99) , 
6, -9.48571, 0, 0, 0.497892,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0811508);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.34551, 1, 1, 0.540344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463088,-99) , 
7, 0.47619, 0, 0, 0.485276,-99) , 
5, 0.975057, 0, 0, 0.505782,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478651,-99) , 
0, 107.682, 0, 0, 0.515674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365545,-99) , 
7, 0.92381, 0, 0, 0.466812,-99) , 
5, 0.47619, 0, 0, 0.496929,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0625807);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.11878, 1, 1, 0.54281,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449946,-99) , 
5, 0.932214, 0, 0, 0.480881,-99) , 
0, 108.774, 0, 0, 0.516197,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448367,-99) , 
5, 0.47619, 0, 0, 0.515028,-99) , 
NN(
0, 
0, 
-1, 159.887, 0, -1, 0.477211,-99) , 
3, 1.12059, 1, 0, 0.485582,-99) , 
6, 0.285711, 0, 0, 0.494101,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0312679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547249,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496933,-99) , 
4, 3.01552, 1, 0, 0.502514,-99) , 
4, 2.61808, 1, 0, 0.507125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510507,-99) , 
NN(
0, 
0, 
-1, 3.497, 1, -1, 0.465635,-99) , 
4, 2.83066, 1, 0, 0.475354,-99) , 
2, 155.39, 0, 0, 0.49959,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0438262);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491309,-99) , 
5, 0.47619, 0, 0, 0.517174,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477567,-99) , 
7, 0.475832, 0, 0, 0.493168,-99) , 
3, 2.3685, 1, 0, 0.510233,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472816,-99) , 
1, 0.144418, 0, 0, 0.492025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460012,-99) , 
4, 3.2971, 1, 0, 0.479766,-99) , 
2, 155.39, 0, 0, 0.50301,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0375564);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547073,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498325,-99) , 
4, 2.94641, 1, 0, 0.507254,-99) , 
1, 0.186944, 0, 0, 0.516664,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532492,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483777,-99) , 
0, 153.837, 0, 0, 0.489443,-99) , 
1, 0.432778, 0, 0, 0.493377,-99) , 
2, 195.933, 0, 0, 0.501068,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0280122);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.654004, 0, 1, 0.510962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460449,-99) , 
5, 0.189968, 0, 0, 0.507805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468694,-99) , 
6, -9.48571, 0, 0, 0.505163,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0257566);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499627,-99) , 
4, 3.04842, 1, 0, 0.508415,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482539,-99) , 
5, 0.475844, 1, 0, 0.48931,-99) , 
3, 2.3685, 1, 0, 0.50267,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468227,-99) , 
2, 135.119, 0, 0, 0.499923,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.026101);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.237236, 0, 1, 0.531833,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49399,-99) , 
0, 108.774, 0, 0, 0.506304,-99) , 
1, 0.116539, 0, 0, 0.515777,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495832,-99) , 
1, 0.366424, 0, 0, 0.499837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468395,-99) , 
4, 4.18296, 1, 0, 0.496446,-99) , 
2, 195.933, 0, 0, 0.502829,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0221588);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.528513,-99) , 
NN(
NN(
0, 
0, 
-1, 153.837, 0, 1, 0.506167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457098,-99) , 
4, 4.60524, 1, 0, 0.502544,-99) , 
4, 2.61808, 1, 0, 0.505453,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.019073);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.522988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497215,-99) , 
0, 153.837, 0, 0, 0.500628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462602,-99) , 
4, 4.60524, 1, 0, 0.497822,-99) , 
4, 2.61808, 1, 0, 0.500639,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0383423);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480163,-99) , 
0, 93.2374, 0, 0, 0.505489,-99) , 
3, 0.752155, 1, 0, 0.508616,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516179,-99) , 
NN(
0, 
0, 
-1, 142.935, 0, -1, 0.482002,-99) , 
1, 0.227753, 0, 0, 0.491219,-99) , 
3, 2.3685, 1, 0, 0.503337,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0150625);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523693,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498512,-99) , 
0, 163.278, 0, 0, 0.501215,-99) , 
3, 0.871003, 1, 0, 0.50391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477356,-99) , 
2, 135.119, 0, 0, 0.501794,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0158331);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.524116,-99) , 
NN(
NN(
0, 
0, 
-1, 2.80734, 1, 1, 0.50397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470202,-99) , 
4, 4.60524, 1, 0, 0.501481,-99) , 
4, 2.61808, 1, 0, 0.504014,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0147948);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.520166,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479446,-99) , 
1, -0.147212, 0, 0, 0.500287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471876,-99) , 
2, 135.119, 0, 0, 0.498106,-99) , 
4, 2.61808, 1, 0, 0.500574,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0166973);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499043,-99) , 
4, 2.24549, 1, 0, 0.516472,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495627,-99) , 
4, 2.80734, 1, 0, 0.497462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471931,-99) , 
4, 4.60524, 1, 0, 0.49558,-99) , 
4, 2.61808, 1, 0, 0.497917,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0214344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.22718, 0, 1, 0.515124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49305,-99) , 
1, -0.0946761, 0, 0, 0.509899,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496675,-99) , 
3, 0.882827, 1, 0, 0.500066,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464251,-99) , 
2, 163.192, 0, 0, 0.485656,-99) , 
4, 3.66134, 1, 0, 0.496771,-99) , 
2, 195.933, 0, 0, 0.501105,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0127057);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.519711,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499462,-99) , 
0, 153.837, 0, 0, 0.502125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475129,-99) , 
4, 4.60524, 1, 0, 0.500137,-99) , 
4, 2.61808, 1, 0, 0.502326,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0226913);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552397,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474338,-99) , 
6, 0.0859434, 0, 0, 0.502798,-99) , 
6, 0.652625, 0, 0, 0.505715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482138,-99) , 
6, -9.48571, 0, 0, 0.504124,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0234164);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498388,-99) , 
4, 2.76725, 1, 0, 0.513217,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491113,-99) , 
4, 3.34307, 0, 0, 0.499437,-99) , 
4, 3.05516, 1, 0, 0.504034,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463711,-99) , 
5, 0.874924, 0, 0, 0.490891,-99) , 
5, 0.475844, 1, 0, 0.494509,-99) , 
3, 2.11891, 1, 0, 0.50028,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0231311);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497377,-99) , 
4, 2.91121, 1, 0, 0.515312,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484953,-99) , 
2, 155.39, 0, 0, 0.499437,-99) , 
4, 3.05516, 1, 0, 0.504732,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488442,-99) , 
1, 0.225864, 0, 0, 0.495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478368,-99) , 
4, 4.18296, 1, 0, 0.491679,-99) , 
3, 2.11891, 1, 0, 0.499588,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.021445);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513192,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491164,-99) , 
0, 90.0991, 0, 0, 0.501756,-99) , 
NN(
0, 
0, 
-1, 183.905, 0, -1, 0.480057,-99) , 
0, 127.463, 1, 0, 0.497659,-99) , 
0, 153.837, 0, 0, 0.499523,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0356794);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52051,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493731,-99) , 
1, 0.250385, 0, 0, 0.498725,-99) , 
3, 0.865277, 1, 0, 0.501557,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451129,-99) , 
7, 0.924804, 0, 0, 0.50621,-99) , 
NN(
0, 
0, 
-1, 181.023, 0, -1, 0.473121,-99) , 
7, 0.475836, 0, 0, 0.490157,-99) , 
4, 3.66134, 1, 0, 0.498716,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0131768);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.515827,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498619,-99) , 
4, 2.99659, 1, 0, 0.501947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477974,-99) , 
4, 4.60524, 1, 0, 0.500185,-99) , 
4, 2.61808, 1, 0, 0.501934,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0183051);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516986,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481207,-99) , 
4, 4.43404, 1, 0, 0.50408,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481241,-99) , 
2, 183.905, 0, 0, 0.490115,-99) , 
0, 127.463, 1, 0, 0.501444,-99) , 
0, 153.837, 0, 0, 0.50331,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0155214);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512414,-99) , 
NN(
NN(
0, 
0, 
-1, 63.4103, 0, 1, 0.51049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48972,-99) , 
7, 0.47619, 1, 0, 0.496498,-99) , 
0, 74.7141, 1, 0, 0.498486,-99) , 
0, 153.837, 0, 0, 0.500158,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0149889);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496133,-99) , 
0, 74.7141, 1, 0, 0.498409,-99) , 
0, 153.837, 0, 0, 0.500505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482955,-99) , 
1, -0.15961, 0, 0, 0.499147,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0102185);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521052,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498941,-99) , 
2, 236.475, 0, 0, 0.501175,-99) , 
0, 153.837, 0, 0, 0.502754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486699,-99) , 
1, -0.15961, 0, 0, 0.501512,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.00945539);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 153.837, 0, 1, 0.504223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489252,-99) , 
1, -0.15961, 0, 0, 0.503065,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0103225);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496604,-99) , 
4, 2.24549, 1, 0, 0.511778,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498743,-99) , 
4, 2.99659, 1, 0, 0.50097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483942,-99) , 
4, 4.60524, 1, 0, 0.499718,-99) , 
4, 2.61808, 1, 0, 0.501067,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.00856975);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499185,-99) , 
4, 2.24549, 1, 0, 0.511786,-99) , 
NN(
NN(
0, 
0, 
-1, 2.83903, 0, 1, 0.502425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486521,-99) , 
4, 4.60524, 1, 0, 0.501256,-99) , 
4, 2.61808, 1, 0, 0.502434,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0482348);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24549, 1, 1, 0.511793,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47608,-99) , 
7, 0.975057, 0, 0, 0.502778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43612,-99) , 
5, 0.866668, 0, 0, 0.4959,-99) , 
7, 0.47619, 0, 0, 0.499429,-99) , 
4, 2.61808, 1, 0, 0.500811,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0558257);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.38771, 0, 1, 0.538131,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435905,-99) , 
7, 0.796892, 1, 0, 0.473885,-99) , 
7, 0.925171, 0, 0, 0.5057,-99) , 
NN(
NN(
0, 
0, 
-1, 0.997732, 0, 1, 0.515551,-99) , 
NN(
0, 
0, 
-1, 0.863493, 0, -1, 0.477774,-99) , 
5, 0.990476, 0, 0, 0.489538,-99) , 
7, 0.47619, 0, 0, 0.497694,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0193232);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508126,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486327,-99) , 
0, 100.63, 0, 0, 0.503743,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491917,-99) , 
0, 69.2191, 1, 0, 0.493709,-99) , 
2, 236.475, 0, 0, 0.495417,-99) , 
0, 176.915, 0, 0, 0.496526,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.015018);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497405,-99) , 
1, 0.429412, 0, 0, 0.499115,-99) , 
2, 236.475, 0, 0, 0.501077,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485288,-99) , 
2, 262.73, 1, 0, 0.498634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479335,-99) , 
3, 2.34559, 1, 0, 0.490987,-99) , 
1, -0.0174327, 0, 0, 0.499036,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.012633);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515769,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504303,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494869,-99) , 
5, 0.47619, 0, 0, 0.502155,-99) , 
2, 236.475, 0, 0, 0.503464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482678,-99) , 
0, 131.324, 0, 0, 0.492443,-99) , 
1, -0.0174327, 0, 0, 0.501235,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.010583);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498798,-99) , 
1, 0.354939, 0, 0, 0.500435,-99) , 
2, 236.475, 0, 0, 0.501606,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490833,-99) , 
2, 262.73, 1, 0, 0.499743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481075,-99) , 
3, 2.34559, 1, 0, 0.492346,-99) , 
1, -0.0174327, 0, 0, 0.499733,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0133671);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.243229, 0, 1, 0.504529,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479474,-99) , 
1, 0.229342, 1, 0, 0.495719,-99) , 
0, 130.76, 1, 0, 0.502879,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493479,-99) , 
2, 262.73, 1, 0, 0.499709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483718,-99) , 
3, 2.34559, 1, 0, 0.493373,-99) , 
1, -0.0174327, 0, 0, 0.500956,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0118706);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544324,-99) , 
NN(
0, 
0, 
-1, 0.189968, 0, -1, 0.496924,-99) , 
6, 0.652625, 0, 0, 0.499715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488102,-99) , 
6, -9.48571, 0, 0, 0.498933,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0122024);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471246,-99) , 
5, 0.189968, 0, 0, 0.499892,-99) , 
6, 0.652625, 0, 0, 0.502333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491068,-99) , 
6, -9.48571, 0, 0, 0.501574,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0481121);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490492,-99) , 
3, 1.38771, 0, 0, 0.527307,-99) , 
NN(
0, 
0, 
-1, 0.799267, 1, -1, 0.471531,-99) , 
7, 0.900228, 0, 0, 0.502485,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492753,-99) , 
5, 0.956463, 1, 0, 0.502707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470709,-99) , 
5, 0.885715, 0, 0, 0.496033,-99) , 
7, 0.47619, 0, 0, 0.499287,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.010229);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.44674, 1, 1, 0.50499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493117,-99) , 
3, 3.11724, 1, 0, 0.50421,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0161588);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496789,-99) , 
7, 0.475836, 0, 0, 0.512349,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493366,-99) , 
1, 0.116539, 0, 0, 0.50096,-99) , 
4, 3.4338, 0, 0, 0.505274,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499624,-99) , 
2, 155.39, 1, 0, 0.503807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501222,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474395,-99) , 
7, 0.475831, 0, 0, 0.488764,-99) , 
4, 3.66134, 1, 0, 0.500372,-99) , 
2, 195.933, 0, 0, 0.501989,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0259835);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484027,-99) , 
6, 0.285709, 1, 0, 0.507146,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491725,-99) , 
6, 0.285711, 0, 0, 0.500687,-99) , 
0, 107.682, 1, 0, 0.503747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492448,-99) , 
2, 135.119, 0, 0, 0.502849,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0134742);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511643,-99) , 
NN(
NN(
0, 
0, 
-1, 1.17604, 1, 1, 0.504732,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478254,-99) , 
5, 0.47619, 0, 0, 0.496901,-99) , 
0, 92.2965, 0, 0, 0.502307,-99) , 
0, 176.915, 0, 0, 0.503121,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0158296);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520096,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497314,-99) , 
0, 74.7141, 1, 0, 0.499742,-99) , 
0, 153.837, 0, 0, 0.501755,-99) , 
NN(
NN(
0, 
0, 
-1, 0.475836, 0, 1, 0.509836,-99) , 
NN(
0, 
0, 
-1, 0.475831, 0, -1, 0.482318,-99) , 
2, 181.023, 0, 0, 0.495961,-99) , 
4, 3.66134, 1, 0, 0.500313,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0160984);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51957,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486559,-99) , 
2, 277.017, 1, 0, 0.502186,-99) , 
4, 2.4442, 1, 0, 0.504003,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492179,-99) , 
7, 0.475836, 0, 0, 0.502969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478286,-99) , 
2, 161.087, 0, 0, 0.495993,-99) , 
4, 3.66134, 1, 0, 0.50201,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.012884);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511684,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497978,-99) , 
1, 0.354896, 0, 0, 0.499706,-99) , 
2, 256.746, 0, 0, 0.501104,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487899,-99) , 
3, 0.980029, 1, 0, 0.501048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477799,-99) , 
1, -0.0137164, 0, 0, 0.494338,-99) , 
0, 84.6045, 0, 0, 0.499735,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0236476);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4941,-99) , 
6, 0.628568, 0, 0, 0.508306,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490283,-99) , 
7, 0.47619, 0, 0, 0.500144,-99) , 
6, 0.285711, 0, 0, 0.502542,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488615,-99) , 
0, 74.7141, 1, 0, 0.501121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481015,-99) , 
1, -0.0137164, 0, 0, 0.495318,-99) , 
0, 84.6045, 0, 0, 0.50108,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0314874);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.993651, 0, 1, 0.509522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480988,-99) , 
5, 0.866668, 0, 0, 0.505046,-99) , 
NN(
NN(
0, 
0, 
-1, 1.63626, 0, 1, 0.528179,-99) , 
NN(
0, 
0, 
-1, 0.475837, 0, -1, 0.483541,-99) , 
7, 0.975057, 0, 0, 0.498509,-99) , 
7, 0.47619, 1, 0, 0.501751,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0125555);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495953,-99) , 
0, 115.116, 1, 0, 0.506711,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497189,-99) , 
4, 2.46394, 1, 0, 0.499126,-99) , 
1, 0.250942, 0, 0, 0.501407,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483673,-99) , 
1, 0.124745, 1, 0, 0.492789,-99) , 
3, 0.871003, 0, 0, 0.500379,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.00704066);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 219.907, 0, 1, 0.503001,-99) , 
NN(
0, 
0, 
-1, 0.704615, 1, -1, 0.492642,-99) , 
3, 0.871003, 0, 0, 0.501765,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0114581);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507957,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499698,-99) , 
3, 1.17604, 1, 0, 0.501898,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488642,-99) , 
4, 2.97059, 1, 0, 0.494819,-99) , 
0, 92.2965, 0, 0, 0.499706,-99) , 
0, 176.915, 0, 0, 0.500425,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0227865);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473262,-99) , 
5, 0.830532, 0, 0, 0.507703,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49131,-99) , 
7, 0.47619, 0, 0, 0.501013,-99) , 
6, 0.285711, 0, 0, 0.50293,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486663,-99) , 
3, 0.704615, 1, 0, 0.49527,-99) , 
3, 0.871003, 0, 0, 0.502017,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.029987);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528815,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497104,-99) , 
5, 0.994061, 0, 0, 0.51421,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482246,-99) , 
1, 0.0536561, 0, 0, 0.495773,-99) , 
5, 0.975057, 0, 0, 0.502655,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495616,-99) , 
7, 0.99093, 0, 0, 0.513905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436272,-99) , 
7, 0.904763, 0, 0, 0.494282,-99) , 
5, 0.47619, 0, 0, 0.50077,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0103733);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499883,-99) , 
3, 1.49239, 0, 0, 0.508072,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498744,-99) , 
0, 153.837, 0, 0, 0.501128,-99) , 
NN(
0, 
0, 
-1, 164.868, 0, -1, 0.490804,-99) , 
4, 3.66134, 1, 0, 0.498697,-99) , 
2, 256.746, 0, 0, 0.499855,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.00910007);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.475811, 1, 1, 0.508187,-99) , 
NN(
NN(
0, 
0, 
-1, 153.837, 0, 1, 0.50322,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483173,-99) , 
2, 164.868, 0, 0, 0.493397,-99) , 
4, 3.66134, 1, 0, 0.500907,-99) , 
2, 256.746, 0, 0, 0.501806,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.00827324);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498379,-99) , 
7, 0.475811, 1, 0, 0.505913,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499062,-99) , 
0, 153.837, 0, 0, 0.500945,-99) , 
NN(
0, 
0, 
-1, 0.21279, 0, -1, 0.492919,-99) , 
4, 3.66134, 1, 0, 0.499055,-99) , 
2, 256.746, 0, 0, 0.499902,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0172268);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.633326, 0, 1, 0.505823,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469163,-99) , 
1, 0.0733768, 1, 0, 0.48272,-99) , 
6, 0.0999789, 0, 0, 0.501932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494287,-99) , 
6, -9.48571, 0, 0, 0.501417,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.00763734);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509196,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49379,-99) , 
3, 1.5063, 0, 0, 0.498251,-99) , 
0, 153.837, 0, 0, 0.499118,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492244,-99) , 
1, -0.15961, 0, 0, 0.498588,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.00996964);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507022,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494178,-99) , 
1, 0.0354167, 0, 0, 0.497951,-99) , 
4, 3.4338, 0, 0, 0.501539,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497816,-99) , 
2, 135.119, 1, 0, 0.499335,-99) , 
NN(
0, 
0, 
-1, 0.258194, 0, -1, 0.49003,-99) , 
4, 3.66134, 1, 0, 0.497189,-99) , 
2, 216.204, 0, 0, 0.498214,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0143725);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511908,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497508,-99) , 
3, 2.59231, 0, 0, 0.499337,-99) , 
4, 2.4442, 1, 0, 0.500651,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48393,-99) , 
7, 0.924804, 0, 0, 0.503527,-99) , 
NN(
0, 
0, 
-1, 181.023, 0, -1, 0.48928,-99) , 
7, 0.475836, 0, 0, 0.496598,-99) , 
4, 3.66134, 1, 0, 0.499642,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0146697);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.76725, 1, 1, 0.511263,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489632,-99) , 
5, 0.47619, 0, 0, 0.49949,-99) , 
4, 3.05516, 1, 0, 0.503415,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494685,-99) , 
4, 3.81037, 1, 0, 0.502246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482264,-99) , 
4, 2.61808, 0, 0, 0.498514,-99) , 
3, 2.11891, 1, 0, 0.501486,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.00561811);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 184.131, 0, 1, 0.504984,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499716,-99) , 
4, 2.34721, 1, 0, 0.500712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48623,-99) , 
4, 3.78553, 1, 0, 0.499232,-99) , 
4, 4.18296, 0, 0, 0.499918,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0168675);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 72.5162, 1, 1, 0.506746,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492942,-99) , 
1, 0.0536561, 1, 0, 0.497,-99) , 
0, 107.682, 1, 0, 0.501832,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528205,-99) , 
NN(
0, 
0, 
-1, 0.830532, 0, -1, 0.49082,-99) , 
6, 0.653058, 0, 0, 0.498142,-99) , 
6, 0.285711, 1, 0, 0.500802,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0154031);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.48432, 1, 1, 0.509066,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478246,-99) , 
3, 1.3145, 0, 0, 0.498791,-99) , 
7, 0.47619, 1, 0, 0.503642,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499824,-99) , 
3, 0.835347, 0, 0, 0.505685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493498,-99) , 
1, 0.109726, 0, 0, 0.49651,-99) , 
3, 1.12059, 1, 0, 0.498472,-99) , 
1, 0.195834, 0, 0, 0.500576,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0160192);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523761,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496526,-99) , 
2, 141.151, 1, 0, 0.498603,-99) , 
3, 1.37017, 1, 0, 0.501931,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497915,-99) , 
0, 72.5162, 1, 0, 0.502469,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467699,-99) , 
3, 1.54675, 0, 0, 0.485436,-99) , 
6, 0.285709, 1, 0, 0.498289,-99) , 
0, 107.682, 0, 0, 0.500206,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0133582);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.37017, 1, 1, 0.504072,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491254,-99) , 
3, 2.19924, 1, 0, 0.504524,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471689,-99) , 
3, 1.54675, 0, 0, 0.485553,-99) , 
6, 0.285709, 1, 0, 0.499869,-99) , 
0, 107.682, 0, 0, 0.502081,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.00701246);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497964,-99) , 
3, 1.49239, 0, 0, 0.504019,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499111,-99) , 
0, 153.837, 0, 0, 0.50058,-99) , 
NN(
0, 
0, 
-1, 0.21279, 0, -1, 0.493785,-99) , 
4, 3.66134, 1, 0, 0.49898,-99) , 
2, 256.746, 0, 0, 0.499602,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00686368);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51162,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498257,-99) , 
1, 0.236456, 0, 0, 0.500474,-99) , 
0, 153.837, 0, 0, 0.501357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495706,-99) , 
1, -0.15961, 0, 0, 0.500921,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0101035);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509448,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495555,-99) , 
7, 0.47619, 0, 0, 0.501692,-99) , 
6, 0.285711, 0, 0, 0.503878,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496089,-99) , 
4, 3.67428, 1, 0, 0.501481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488196,-99) , 
1, -0.0316967, 0, 0, 0.500017,-99) , 
2, 195.933, 0, 0, 0.50129,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.00669553);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507768,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498825,-99) , 
2, 268.33, 0, 0, 0.501576,-99) , 
1, -0.0946761, 1, 0, 0.503041,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498886,-99) , 
3, 2.87782, 0, 0, 0.500079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490721,-99) , 
1, -0.0316967, 0, 0, 0.499047,-99) , 
2, 195.933, 0, 0, 0.500364,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.00533361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00488558, 1, 1, 0.504466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498168,-99) , 
2, 326.247, 1, 0, 0.503328,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0820578, 1, 1, 0.501323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492394,-99) , 
1, -0.0316967, 0, 0, 0.500339,-99) , 
2, 195.933, 0, 0, 0.501325,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.00651513);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505746,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508646,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501819,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496904,-99) , 
3, 1.94566, 0, 0, 0.499069,-99) , 
2, 297.288, 0, 0, 0.499832,-99) , 
0, 176.915, 0, 0, 0.500347,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.00933888);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495355,-99) , 
0, 109.531, 1, 0, 0.500813,-99) , 
6, 0.285711, 0, 0, 0.502304,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495458,-99) , 
1, 0.12594, 1, 0, 0.503727,-99) , 
NN(
0, 
0, 
-1, -0.0497281, 0, -1, 0.497631,-99) , 
3, 1.38587, 1, 0, 0.499239,-99) , 
2, 195.933, 0, 0, 0.50025,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0103068);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505967,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499221,-99) , 
5, 0.47619, 1, 0, 0.502041,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492953,-99) , 
4, 2.97059, 1, 0, 0.498131,-99) , 
0, 92.2965, 0, 0, 0.500831,-99) , 
0, 176.915, 0, 0, 0.501278,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.00609361);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 153.837, 0, 1, 0.502982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496179,-99) , 
1, -0.15961, 0, 0, 0.502457,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0259638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.28571, 0, 1, 0.514957,-99) , 
NN(
0, 
0, 
-1, 0.618724, 0, -1, 0.494161,-99) , 
5, 0.975057, 0, 0, 0.501923,-99) , 
NN(
NN(
0, 
0, 
-1, 0.99093, 0, 1, 0.51634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445978,-99) , 
7, 0.904763, 0, 0, 0.498572,-99) , 
5, 0.47619, 0, 0, 0.501169,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0274892);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496867,-99) , 
7, 0.28571, 0, 0, 0.50724,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47278,-99) , 
5, 0.79689, 1, 0, 0.493868,-99) , 
5, 0.85034, 0, 0, 0.503569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526825,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497975,-99) , 
7, 0.99093, 0, 0, 0.509854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452402,-99) , 
7, 0.904763, 0, 0, 0.495357,-99) , 
5, 0.47619, 0, 0, 0.501722,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0255074);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 195.933, 1, 1, 0.516264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497589,-99) , 
5, 0.952381, 1, 0, 0.503748,-99) , 
3, 1.32925, 1, 0, 0.506886,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492184,-99) , 
5, 0.285711, 0, 0, 0.510603,-99) , 
NN(
0, 
0, 
-1, 0.799267, 1, -1, 0.483427,-99) , 
7, 0.900228, 0, 0, 0.498502,-99) , 
7, 0.47619, 1, 0, 0.502661,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0286735);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.961905, 1, 1, 0.510493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482791,-99) , 
1, 0.130516, 0, 0, 0.498011,-99) , 
5, 0.933334, 0, 0, 0.506066,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489998,-99) , 
3, 1.38771, 0, 0, 0.508359,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45167,-99) , 
7, 0.799267, 1, 0, 0.488511,-99) , 
7, 0.875285, 0, 0, 0.500413,-99) , 
7, 0.47619, 1, 0, 0.503218,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0133938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 202.611, 1, 1, 0.510292,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492492,-99) , 
2, 240.831, 0, 0, 0.496174,-99) , 
3, 1.61975, 1, 0, 0.501695,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497931,-99) , 
2, 155.39, 1, 0, 0.500279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482678,-99) , 
1, 0.155214, 0, 0, 0.498192,-99) , 
1, 0.124745, 1, 0, 0.499715,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0169149);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514887,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492745,-99) , 
4, 3.41294, 1, 0, 0.500477,-99) , 
4, 2.61808, 1, 0, 0.502302,-99) , 
NN(
NN(
0, 
0, 
-1, 0.994061, 0, 1, 0.507421,-99) , 
NN(
0, 
0, 
-1, 2.34459, 1, -1, 0.486798,-99) , 
7, 0.875285, 0, 0, 0.499165,-99) , 
7, 0.47619, 1, 0, 0.500722,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0210265);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49607,-99) , 
0, 118.382, 1, 0, 0.503837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48766,-99) , 
3, 0.871003, 0, 0, 0.501818,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493216,-99) , 
5, 0.952381, 1, 0, 0.502422,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475214,-99) , 
7, 0.925171, 0, 0, 0.49138,-99) , 
7, 0.47619, 1, 0, 0.497042,-99) , 
4, 3.13971, 0, 0, 0.499603,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.00945477);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508421,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492859,-99) , 
0, 76.9116, 0, 0, 0.501548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489195,-99) , 
4, 2.99067, 1, 0, 0.496587,-99) , 
4, 3.13971, 0, 0, 0.499162,-99) , 
0, 176.915, 0, 0, 0.499968,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0107012);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506058,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496766,-99) , 
1, 0.124745, 1, 0, 0.503545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495569,-99) , 
1, 0.397467, 0, 0, 0.496991,-99) , 
3, 0.974147, 1, 0, 0.498088,-99) , 
0, 176.915, 0, 0, 0.498782,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.014301);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516218,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495743,-99) , 
7, 0.47619, 1, 0, 0.49983,-99) , 
3, 1.37017, 1, 0, 0.501998,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493533,-99) , 
5, 0.47619, 0, 0, 0.502632,-99) , 
NN(
0, 
0, 
-1, 1.54675, 0, -1, 0.484433,-99) , 
6, 0.285709, 1, 0, 0.498163,-99) , 
0, 107.682, 0, 0, 0.500182,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00699421);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497621,-99) , 
0, 107.721, 0, 0, 0.504609,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499014,-99) , 
4, 3.42595, 0, 0, 0.500408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488238,-99) , 
4, 3.78553, 1, 0, 0.499164,-99) , 
4, 4.18296, 0, 0, 0.499813,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0173658);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485438,-99) , 
6, 0.45714, 0, 0, 0.50964,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495097,-99) , 
1, 0.0536561, 1, 0, 0.498897,-99) , 
6, 0.285711, 0, 0, 0.502222,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499118,-99) , 
0, 72.5162, 1, 0, 0.502686,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477905,-99) , 
3, 1.54675, 0, 0, 0.489323,-99) , 
6, 0.285709, 1, 0, 0.499405,-99) , 
0, 107.682, 0, 0, 0.500888,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0127331);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511124,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490029,-99) , 
4, 3.91378, 1, 0, 0.50297,-99) , 
3, 2.87782, 0, 0, 0.503892,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499031,-99) , 
2, 181.023, 0, 0, 0.503428,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501524,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484595,-99) , 
3, 1.63567, 1, 0, 0.494843,-99) , 
0, 131.324, 0, 0, 0.498467,-99) , 
1, 0.0536561, 0, 0, 0.50224,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.00618692);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 107.721, 0, 1, 0.506314,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47542,-99) , 
4, 3.92747, 1, 0, 0.498767,-99) , 
4, 2.39452, 1, 0, 0.499697,-99) , 
4, 4.18296, 0, 0, 0.500486,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
