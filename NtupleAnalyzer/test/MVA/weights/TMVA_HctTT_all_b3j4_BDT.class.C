// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Feb 14 13:58:49 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 179618
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 16
HiggsMass_TOPTOPLEPHBB        HiggsMass_TOPTOPLEPHBB        HiggsMass_TOPTOPLEPHBB        HiggsMass_TOPTOPLEPHBB                                          'D'    [17.7639293671,500]
MVA_TOPTOPLEPHBB              MVA_TOPTOPLEPHBB              MVA_TOPTOPLEPHBB              MVA_TOPTOPLEPHBB                                                'D'    [-0.825348198414,0.618747830391]
MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD                                                'D'    [-0.856060683727,0.753217041492]
TopLepMass_TOPTOPLEPHBB       TopLepMass_TOPTOPLEPHBB       TopLepMass_TOPTOPLEPHBB       TopLepMass_TOPTOPLEPHBB                                         'D'    [47.7442779541,500]
TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD                                         'D'    [51.3774261475,500]
HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB                                         'D'    [0.392819881439,5.44198036194]
TopLepHiggsDr_TOPTOPLEPHBB    TopLepHiggsDr_TOPTOPLEPHBB    TopLepHiggsDr_TOPTOPLEPHBB    TopLepHiggsDr_TOPTOPLEPHBB                                      'D'    [0.0224535632879,9.14438152313]
TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD                                     'D'    [0.0283043645322,9.50090122223]
HiggsBJet1CSVv2_TOPTOPLEPHBB  HiggsBJet1CSVv2_TOPTOPLEPHBB  HiggsBJet1CSVv2_TOPTOPLEPHBB  HiggsBJet1CSVv2_TOPTOPLEPHBB                                    'D'    [0.822607457638,0.999628484249]
HiggsBJet2CSVv2_TOPTOPLEPHBB  HiggsBJet2CSVv2_TOPTOPLEPHBB  HiggsBJet2CSVv2_TOPTOPLEPHBB  HiggsBJet2CSVv2_TOPTOPLEPHBB                                    'D'    [0.800005912781,0.999416232109]
TopLepBJetCSVv2_TOPTOPLEPHBB  TopLepBJetCSVv2_TOPTOPLEPHBB  TopLepBJetCSVv2_TOPTOPLEPHBB  TopLepBJetCSVv2_TOPTOPLEPHBB                                    'D'    [0.800017237663,0.999632060528]
TopHadNonBJetCSVv2_TOPTOPLEPHBB TopHadNonBJetCSVv2_TOPTOPLEPHBB TopHadNonBJetCSVv2_TOPTOPLEPHBB TopHadNonBJetCSVv2_TOPTOPLEPHBB                                     'D'    [-10,0.848383247852]
TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800017237663,0.999632060528]
TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800019860268,0.999624848366]
TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.998877108097]
TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.848383247852]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 16 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPTOPLEPHBB", "MVA_TOPTOPLEPHBB", "MVA_TOPTOPLEPHAD", "TopLepMass_TOPTOPLEPHBB", "TopLepMass_TOPTOPLEPHAD", "HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB", "TopLepHiggsDr_TOPTOPLEPHBB", "TopLepTopHadDr_TOPTOPLEPHAD", "HiggsBJet1CSVv2_TOPTOPLEPHBB", "HiggsBJet2CSVv2_TOPTOPLEPHBB", "TopLepBJetCSVv2_TOPTOPLEPHBB", "TopHadNonBJetCSVv2_TOPTOPLEPHBB", "TopLepBJetCSVv2_TOPTOPLEPHAD", "TopHadBJetCSVv2_TOPTOPLEPHAD", "TopHadWNonBJet1CSVv2_TOPTOPLEPHAD", "TopHadWNonBJet2CSVv2_TOPTOPLEPHAD" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';
      fType[12] = 'D';
      fType[13] = 'D';
      fType[14] = 'D';
      fType[15] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[16];
   double fVmax[16];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[16];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.242531045936093);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.977713, 0, 1, 0.690446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435255,-99) , 
1, 0.0172522, 0, 0, 0.634741,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431623,-99) , 
15, 0.331794, 0, 0, 0.464101,-99) , 
NN(
0, 
0, 
-1, 2.084, 1, -1, 0.305822,-99) , 
0, 132.582, 1, 0, 0.430333,-99) , 
9, 0.942442, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.163761);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.979069, 0, 1, 0.611016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432882,-99) , 
1, -0.0722315, 0, 0, 0.582772,-99) , 
NN(
0, 
0, 
-1, 133.895, 1, -1, 0.442759,-99) , 
9, 0.913955, 0, 0, 0.514284,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.155075);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.952345, 0, 1, 0.66173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447743,-99) , 
0, 88.8396, 0, 0, 0.522537,-99) , 
9, 0.970929, 0, 0, 0.54806,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554791,-99) , 
NN(
0, 
0, 
-1, 150.081, 1, -1, 0.364534,-99) , 
5, 1.60428, 1, 0, 0.414892,-99) , 
0, 132.582, 1, 0, 0.520284,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.115891);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630355,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451111,-99) , 
8, 0.965903, 0, 0, 0.505756,-99) , 
NN(
0, 
0, 
-1, 2.084, 1, -1, 0.411142,-99) , 
0, 132.582, 1, 0, 0.486138,-99) , 
9, 0.980425, 0, 0, 0.504686,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.0938069);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602968,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496115,-99) , 
11, 0.651595, 0, 0, 0.529596,-99) , 
NN(
0, 
0, 
-1, 0.370056, 1, -1, 0.459612,-99) , 
11, 0.331794, 0, 0, 0.483301,-99) , 
9, 0.980425, 0, 0, 0.498561,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.0845219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49732,-99) , 
10, 0.94266, 0, 0, 0.576207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464913,-99) , 
2, 0.370056, 1, 0, 0.503641,-99) , 
9, 0.961433, 0, 0, 0.520373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360875,-99) , 
0, 178.509, 1, 0, 0.511789,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0803506);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475347,-99) , 
10, 0.961813, 0, 0, 0.514885,-99) , 
1, 0.215641, 0, 0, 0.562944,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480973,-99) , 
11, 0.331794, 0, 0, 0.497466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420516,-99) , 
1, -0.137683, 0, 0, 0.48873,-99) , 
9, 0.961433, 0, 0, 0.505684,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0662195);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.331484, 0, 1, 0.563989,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46243,-99) , 
6, 3.49747, 1, 0, 0.502476,-99) , 
9, 0.961433, 0, 0, 0.516561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393279,-99) , 
0, 178.509, 1, 0, 0.510007,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0682616);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49124,-99) , 
14, 0.836168, 1, 0, 0.506381,-99) , 
14, 0.948996, 0, 0, 0.518523,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521377,-99) , 
NN(
0, 
0, 
-1, 0.183937, 1, -1, 0.44869,-99) , 
1, 0.343682, 0, 0, 0.465804,-99) , 
14, 0.475121, 0, 0, 0.500375,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0622248);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.924065, 0, 1, 0.557853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484593,-99) , 
14, 0.475121, 0, 0, 0.537248,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443694,-99) , 
8, 0.924351, 0, 0, 0.503475,-99) , 
NN(
0, 
0, 
-1, 0.203786, 1, -1, 0.468773,-99) , 
1, 0.137382, 0, 0, 0.489491,-99) , 
13, 0.99012, 0, 0, 0.505343,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0684403);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482377,-99) , 
0, 87.4741, 0, 0, 0.542759,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466014,-99) , 
2, 0.216791, 1, 0, 0.492558,-99) , 
10, 0.971109, 0, 0, 0.516497,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518906,-99) , 
NN(
0, 
0, 
-1, 1.83476, 1, -1, 0.4604,-99) , 
9, 0.85291, 1, 0, 0.47132,-99) , 
9, 0.885467, 0, 0, 0.502742,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0460455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.970941, 0, 1, 0.533076,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475557,-99) , 
10, 0.952108, 0, 0, 0.491457,-99) , 
13, 0.99012, 0, 0, 0.505334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421085,-99) , 
0, 178.509, 1, 0, 0.500882,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.056306);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562339,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490287,-99) , 
7, 3.04361, 1, 0, 0.501506,-99) , 
9, 0.980429, 0, 0, 0.508893,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470098,-99) , 
0, 110.392, 0, 0, 0.504474,-99) , 
NN(
0, 
0, 
-1, 114.575, 1, -1, 0.453822,-99) , 
5, 1.60098, 1, 0, 0.474561,-99) , 
14, 0.475121, 0, 0, 0.497077,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0349286);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.219812, 0, 1, 0.523971,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470893,-99) , 
0, 124.924, 1, 0, 0.495702,-99) , 
13, 0.99012, 0, 0, 0.50512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438794,-99) , 
0, 178.509, 1, 0, 0.501628,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0429547);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497416,-99) , 
12, 0.980599, 0, 0, 0.512775,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47388,-99) , 
11, 0.331794, 0, 0, 0.487977,-99) , 
2, 0.216791, 1, 0, 0.501354,-99) , 
NN(
0, 
0, 
-1, 0.961802, 0, -1, 0.456932,-99) , 
6, 3.93185, 1, 0, 0.496629,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0308969);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548451,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472147,-99) , 
2, 0.446688, 1, 0, 0.500617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458694,-99) , 
6, 3.93185, 1, 0, 0.496426,-99) , 
1, 0.481215, 0, 0, 0.499351,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0397439);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.980678, 0, 1, 0.539844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479359,-99) , 
9, 0.894957, 0, 0, 0.517108,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480812,-99) , 
2, 0.226707, 1, 0, 0.494767,-99) , 
NN(
0, 
0, 
-1, 0.134311, 0, -1, 0.460233,-99) , 
6, 3.49747, 1, 0, 0.488671,-99) , 
1, 0.343682, 0, 0, 0.495384,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0409921);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477059,-99) , 
10, 0.904585, 0, 0, 0.503659,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440714,-99) , 
5, 2.084, 1, 0, 0.476903,-99) , 
0, 133.31, 1, 0, 0.498364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44932,-99) , 
3, 284.64, 1, 0, 0.495111,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0367198);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549681,-99) , 
NN(
0, 
0, 
-1, 0.448493, 0, -1, 0.491845,-99) , 
9, 0.970931, 0, 0, 0.501931,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48278,-99) , 
5, 1.59477, 1, 0, 0.491507,-99) , 
NN(
0, 
0, 
-1, 0.47464, 0, -1, 0.464967,-99) , 
6, 3.0631, 1, 0, 0.481719,-99) , 
1, 0.206149, 0, 0, 0.491371,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0322381);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 106.973, 0, 1, 0.52935,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472046,-99) , 
9, 0.918093, 1, 0, 0.490397,-99) , 
8, 0.991199, 0, 0, 0.507913,-99) , 
NN(
0, 
0, 
-1, 289.575, 1, -1, 0.486492,-99) , 
1, 0.206149, 0, 0, 0.496722,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0371892);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.331642, 0, 1, 0.5237,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48428,-99) , 
14, 0.838542, 1, 0, 0.496666,-99) , 
14, 0.899114, 0, 0, 0.505967,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469856,-99) , 
2, -0.0295433, 1, 0, 0.477387,-99) , 
6, 2.45521, 1, 0, 0.484552,-99) , 
14, 0.475121, 0, 0, 0.498604,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0383938);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534093,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469851,-99) , 
15, 0.55319, 0, 0, 0.510134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47062,-99) , 
9, 0.942442, 1, 0, 0.491231,-99) , 
15, 0.331794, 0, 0, 0.495377,-99) , 
1, 0.481215, 0, 0, 0.497547,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0312759);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567784,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456752,-99) , 
13, 0.961748, 0, 0, 0.484569,-99) , 
15, 0.602389, 0, 0, 0.51327,-99) , 
NN(
0, 
0, 
-1, -0.137683, 0, -1, 0.489813,-99) , 
15, 0.331794, 0, 0, 0.494955,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0176586);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533752,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484289,-99) , 
3, 220.032, 1, 0, 0.499779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466597,-99) , 
8, 0.906903, 0, 0, 0.497826,-99) , 
9, 0.98992, 0, 0, 0.500208,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0327256);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559612,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465514,-99) , 
0, 110.392, 0, 0, 0.49066,-99) , 
11, 0.331484, 0, 0, 0.513498,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482677,-99) , 
9, 0.869185, 0, 0, 0.506189,-99) , 
NN(
0, 
0, 
-1, 0.923594, 0, -1, 0.490014,-99) , 
12, 0.914083, 1, 0, 0.493091,-99) , 
9, 0.961433, 0, 0, 0.497669,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0238707);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528147,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486365,-99) , 
0, 133.848, 1, 0, 0.503166,-99) , 
NN(
0, 
0, 
-1, 260.028, 1, -1, 0.475991,-99) , 
3, 220.032, 1, 0, 0.499344,-99) , 
4, 265.007, 0, 0, 0.501632,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0279031);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496695,-99) , 
8, 0.982762, 0, 0, 0.507752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465866,-99) , 
14, 0.574884, 0, 0, 0.503951,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497111,-99) , 
12, 0.971223, 1, 0, 0.508531,-99) , 
NN(
0, 
0, 
-1, 0.885467, 0, -1, 0.481458,-99) , 
5, 1.36091, 1, 0, 0.489548,-99) , 
14, 0.475121, 0, 0, 0.498997,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0268249);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522268,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486831,-99) , 
9, 0.894943, 0, 0, 0.505691,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465548,-99) , 
12, 0.971094, 1, 0, 0.49152,-99) , 
10, 0.971116, 0, 0, 0.498522,-99) , 
4, 265.007, 0, 0, 0.500406,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0225932);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530526,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487708,-99) , 
9, 0.873243, 0, 0, 0.499329,-99) , 
9, 0.970893, 0, 0, 0.504279,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492297,-99) , 
13, 0.961596, 0, 0, 0.505463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479547,-99) , 
13, 0.942614, 1, 0, 0.487454,-99) , 
1, 0.343682, 0, 0, 0.491494,-99) , 
10, 0.971116, 0, 0, 0.497674,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0113219);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52069,-99) , 
NN(
0, 
0, 
-1, 0.52332, 1, -1, 0.49523,-99) , 
1, 0.481215, 0, 0, 0.496655,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0131601);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515732,-99) , 
NN(
0, 
0, 
-1, 263.104, 1, -1, 0.495585,-99) , 
2, -0.243003, 1, 0, 0.497628,-99) , 
9, 0.98992, 0, 0, 0.499168,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0155544);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.980422, 0, 1, 0.505589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467031,-99) , 
10, 0.923582, 0, 0, 0.492873,-99) , 
3, 149.271, 0, 0, 0.502903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480137,-99) , 
3, 284.64, 1, 0, 0.501401,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0335339);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498148,-99) , 
5, 1.35306, 1, 0, 0.506374,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471135,-99) , 
5, 1.97318, 0, 0, 0.487474,-99) , 
0, 101.961, 0, 0, 0.499755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475194,-99) , 
0, 178.509, 1, 0, 0.498468,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0418324);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470021,-99) , 
0, 146.798, 1, 0, 0.500324,-99) , 
5, 1.36224, 1, 0, 0.508038,-99) , 
NN(
NN(
0, 
0, 
-1, 2.63261, 0, 1, 0.525062,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459803,-99) , 
9, 0.913926, 1, 0, 0.48541,-99) , 
5, 2.03168, 0, 0, 0.497458,-99) , 
0, 109.618, 0, 0, 0.503242,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0155568);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516578,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495733,-99) , 
1, -0.0898388, 1, 0, 0.497964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47789,-99) , 
3, 241.568, 1, 0, 0.496271,-99) , 
4, 265.007, 0, 0, 0.497879,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0164993);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519967,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493402,-99) , 
9, 0.91757, 0, 0, 0.511281,-99) , 
NN(
0, 
0, 
-1, 138.34, 1, -1, 0.49571,-99) , 
1, -0.000150468, 1, 0, 0.499114,-99) , 
9, 0.98992, 0, 0, 0.500487,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0212146);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48454,-99) , 
8, 0.915333, 0, 0, 0.506993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474226,-99) , 
3, 290.796, 1, 0, 0.504846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486185,-99) , 
3, 133.888, 0, 0, 0.503321,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0207664);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.838546, 1, 1, 0.507338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477682,-99) , 
14, 0.624766, 0, 0, 0.50349,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512197,-99) , 
NN(
0, 
0, 
-1, 1.79994, 1, -1, 0.487418,-99) , 
11, 0.285606, 0, 0, 0.493873,-99) , 
14, 0.475121, 0, 0, 0.500183,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0239483);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499027,-99) , 
1, -0.00116187, 1, 0, 0.504247,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466297,-99) , 
0, 122.584, 1, 0, 0.492265,-99) , 
5, 2.30637, 1, 0, 0.500827,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483174,-99) , 
2, 0.23987, 0, 0, 0.497538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467626,-99) , 
4, 203.909, 1, 0, 0.48998,-99) , 
7, 3.63691, 1, 0, 0.498515,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0240058);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498682,-99) , 
0, 109.618, 0, 0, 0.507718,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472261,-99) , 
0, 122.584, 1, 0, 0.491558,-99) , 
5, 2.30637, 1, 0, 0.503106,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492122,-99) , 
2, 0.215756, 0, 0, 0.502302,-99) , 
NN(
0, 
0, 
-1, 1.70781, 0, -1, 0.479362,-99) , 
0, 110.964, 0, 0, 0.491061,-99) , 
7, 3.63691, 1, 0, 0.50054,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0158971);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516985,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489031,-99) , 
3, 198.496, 1, 0, 0.501018,-99) , 
2, -0.243003, 1, 0, 0.502618,-99) , 
NN(
0, 
0, 
-1, 0.913939, 1, -1, 0.48802,-99) , 
6, 3.93185, 1, 0, 0.501073,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0125992);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.970893, 0, 1, 0.506374,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477663,-99) , 
12, 0.990103, 1, 0, 0.496093,-99) , 
10, 0.971116, 0, 0, 0.500969,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471472,-99) , 
0, 111.059, 0, 0, 0.487867,-99) , 
2, 0.52332, 1, 0, 0.499512,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0189813);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511175,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496012,-99) , 
9, 0.980387, 0, 0, 0.498822,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461562,-99) , 
12, 0.923542, 1, 0, 0.486887,-99) , 
10, 0.914083, 0, 0, 0.496028,-99) , 
4, 265.007, 0, 0, 0.497226,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.022592);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498233,-99) , 
8, 0.998095, 0, 0, 0.512595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484538,-99) , 
1, 0.285174, 1, 0, 0.497974,-99) , 
8, 0.99163, 0, 0, 0.5042,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494534,-99) , 
1, 0.0305556, 1, 0, 0.500279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482992,-99) , 
4, 222.281, 0, 0, 0.488468,-99) , 
6, 3.07757, 1, 0, 0.494766,-99) , 
10, 0.971116, 0, 0, 0.499328,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0235714);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491112,-99) , 
10, 0.923589, 0, 0, 0.508332,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469244,-99) , 
9, 0.945613, 1, 0, 0.497618,-99) , 
8, 0.991199, 0, 0, 0.502446,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469282,-99) , 
4, 181.984, 1, 0, 0.48644,-99) , 
1, -0.137683, 0, 0, 0.500653,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0142977);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495696,-99) , 
8, 0.991199, 0, 0, 0.500572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479837,-99) , 
3, 129.786, 0, 0, 0.499158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48441,-99) , 
3, 263.104, 1, 0, 0.497884,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.00786071);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513488,-99) , 
NN(
0, 
0, 
-1, 263.104, 1, -1, 0.498189,-99) , 
2, -0.243003, 1, 0, 0.499825,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485101,-99) , 
5, 3.03762, 1, 0, 0.498743,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0111179);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52308,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488518,-99) , 
0, 133.938, 1, 0, 0.500322,-99) , 
1, -0.0655805, 1, 0, 0.501665,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475893,-99) , 
3, 207.667, 1, 0, 0.489645,-99) , 
1, -0.137683, 0, 0, 0.500319,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0119572);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491468,-99) , 
6, 3.15822, 1, 0, 0.509096,-99) , 
NN(
0, 
0, 
-1, 66.9702, 0, -1, 0.497249,-99) , 
0, 132.582, 0, 0, 0.499494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485369,-99) , 
5, 3.03762, 1, 0, 0.498456,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0112158);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499687,-99) , 
9, 0.961436, 0, 0, 0.503414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479275,-99) , 
0, 71.344, 0, 0, 0.501702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485037,-99) , 
0, 178.509, 1, 0, 0.50083,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0120311);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513878,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481693,-99) , 
3, 263.104, 1, 0, 0.502248,-99) , 
2, -0.243003, 1, 0, 0.503491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490134,-99) , 
5, 3.03762, 1, 0, 0.50251,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0262395);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524261,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483085,-99) , 
8, 0.941071, 0, 0, 0.499408,-99) , 
0, 86.6548, 1, 0, 0.503658,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51537,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485577,-99) , 
11, 0.28569, 0, 0, 0.491554,-99) , 
15, 0.331794, 0, 0, 0.497208,-99) , 
13, 0.97111, 1, 0, 0.500282,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0109986);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512578,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491915,-99) , 
10, 0.914083, 0, 0, 0.499975,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48522,-99) , 
2, 0.52332, 1, 0, 0.498521,-99) , 
1, 0.481215, 0, 0, 0.499308,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.017137);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.894994, 0, 1, 0.513392,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485445,-99) , 
2, 0.292548, 0, 0, 0.494603,-99) , 
5, 1.84221, 1, 0, 0.504175,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493003,-99) , 
12, 0.988769, 0, 0, 0.498568,-99) , 
NN(
0, 
0, 
-1, 0.882406, 1, -1, 0.483583,-99) , 
10, 0.933099, 0, 0, 0.495948,-99) , 
12, 0.942599, 1, 0, 0.498241,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0305366);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519657,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494919,-99) , 
5, 1.83442, 1, 0, 0.5074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481019,-99) , 
15, 0.331729, 1, 0, 0.502206,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466985,-99) , 
15, 0.528607, 0, 0, 0.507134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479401,-99) , 
9, 0.942442, 1, 0, 0.492113,-99) , 
15, 0.331794, 0, 0, 0.495603,-99) , 
12, 0.96161, 1, 0, 0.498082,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0256016);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.28066, 1, 1, 0.516287,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486155,-99) , 
2, 0.194884, 1, 0, 0.498657,-99) , 
2, 0.370056, 0, 0, 0.503655,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474593,-99) , 
15, 0.528607, 0, 0, 0.50727,-99) , 
NN(
0, 
0, 
-1, 0.942604, 0, -1, 0.49065,-99) , 
15, 0.331794, 0, 0, 0.494509,-99) , 
12, 0.96161, 1, 0, 0.497943,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0255848);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489902,-99) , 
8, 0.9798, 0, 0, 0.506399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483631,-99) , 
0, 86.6548, 0, 0, 0.503136,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494999,-99) , 
10, 0.93332, 1, 0, 0.502972,-99) , 
NN(
0, 
0, 
-1, 0.990141, 1, -1, 0.484077,-99) , 
8, 0.974332, 1, 0, 0.493604,-99) , 
9, 0.894963, 0, 0, 0.499614,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0210696);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49978,-99) , 
2, 0.305798, 1, 0, 0.517255,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479817,-99) , 
13, 0.942477, 0, 0, 0.492611,-99) , 
0, 111.059, 1, 0, 0.505202,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495245,-99) , 
1, 0.158914, 0, 0, 0.51343,-99) , 
NN(
0, 
0, 
-1, 0.875453, 0, -1, 0.494555,-99) , 
8, 0.998023, 0, 0, 0.498526,-99) , 
8, 0.96591, 1, 0, 0.500335,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0231324);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49335,-99) , 
9, 0.86646, 0, 0, 0.507552,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474406,-99) , 
2, -0.00101682, 0, 0, 0.497348,-99) , 
5, 2.30637, 1, 0, 0.504639,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51908,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477439,-99) , 
0, 110.964, 0, 0, 0.490457,-99) , 
5, 2.56123, 0, 0, 0.497989,-99) , 
7, 3.63691, 1, 0, 0.503222,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.00742466);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 245.963, 0, 1, 0.502285,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483236,-99) , 
3, 290.796, 1, 0, 0.50104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490886,-99) , 
3, 133.888, 0, 0, 0.500211,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0292061);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519128,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476805,-99) , 
5, 2.0811, 1, 0, 0.492935,-99) , 
1, -0.118045, 0, 0, 0.504147,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480028,-99) , 
0, 122.76, 1, 0, 0.500433,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458523,-99) , 
0, 101.216, 0, 0, 0.482645,-99) , 
5, 1.16285, 0, 0, 0.497422,-99) , 
1, -0.000150468, 1, 0, 0.498881,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0222761);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519787,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480159,-99) , 
3, 166.915, 1, 0, 0.494391,-99) , 
11, 0.331729, 0, 0, 0.502862,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493332,-99) , 
9, 0.970931, 0, 0, 0.496434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465972,-99) , 
0, 66.9702, 0, 0, 0.494429,-99) , 
0, 132.582, 0, 0, 0.496154,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0194502);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524757,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480936,-99) , 
1, 0.0183156, 0, 0, 0.497779,-99) , 
0, 88.1314, 1, 0, 0.502739,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518848,-99) , 
NN(
0, 
0, 
-1, 88.1799, 0, -1, 0.490592,-99) , 
1, -0.0722315, 1, 0, 0.49512,-99) , 
9, 0.913955, 1, 0, 0.498911,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0104353);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491237,-99) , 
4, 179.555, 0, 0, 0.512338,-99) , 
NN(
0, 
0, 
-1, 138.34, 1, -1, 0.498007,-99) , 
1, 0.00645402, 1, 0, 0.499798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480697,-99) , 
4, 181.984, 1, 0, 0.491632,-99) , 
1, -0.137683, 0, 0, 0.498884,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0121891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515032,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492836,-99) , 
5, 1.36218, 0, 0, 0.500821,-99) , 
3, 241.568, 0, 0, 0.502075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481393,-99) , 
13, 0.971476, 1, 0, 0.491779,-99) , 
1, -0.137683, 0, 0, 0.500923,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0098345);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49264,-99) , 
4, 179.555, 0, 0, 0.510801,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480661,-99) , 
0, 138.34, 1, 0, 0.499021,-99) , 
1, 0.00645402, 1, 0, 0.500493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482561,-99) , 
3, 207.667, 1, 0, 0.491821,-99) , 
1, -0.137683, 0, 0, 0.499523,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0169643);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49644,-99) , 
9, 0.961436, 0, 0, 0.5025,-99) , 
NN(
0, 
0, 
-1, 0.951905, 1, -1, 0.491178,-99) , 
0, 101.961, 0, 0, 0.498536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487209,-99) , 
0, 178.509, 1, 0, 0.497943,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0149961);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.928872, 0, 1, 0.511499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491344,-99) , 
2, 0.151491, 0, 0, 0.498431,-99) , 
1, 0.068616, 1, 0, 0.502248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491499,-99) , 
9, 0.980425, 1, 0, 0.500946,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.00707348);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.85698, 1, 1, 0.501937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486589,-99) , 
12, 0.876061, 0, 0, 0.501021,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480566,-99) , 
0, 111.059, 0, 0, 0.492291,-99) , 
2, 0.52332, 1, 0, 0.50005,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.00857267);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518553,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498958,-99) , 
1, -0.0689169, 1, 0, 0.500724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480716,-99) , 
0, 71.344, 0, 0, 0.499306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486891,-99) , 
0, 178.509, 1, 0, 0.498657,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0171015);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48194,-99) , 
9, 0.913856, 1, 0, 0.511126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497002,-99) , 
9, 0.980426, 0, 0, 0.499904,-99) , 
0, 88.0795, 1, 0, 0.501598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483195,-99) , 
1, -0.235937, 0, 0, 0.491425,-99) , 
1, -0.137683, 0, 0, 0.500461,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.00992907);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497745,-99) , 
1, 0.222648, 1, 0, 0.512842,-99) , 
NN(
0, 
0, 
-1, -0.243003, 1, 1, 0.502899,-99) , 
5, 2.79718, 0, 0, 0.504237,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484082,-99) , 
4, 181.984, 1, 0, 0.491676,-99) , 
1, -0.137683, 0, 0, 0.502832,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0125015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515066,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494951,-99) , 
0, 120.34, 1, 0, 0.501018,-99) , 
5, 0.873692, 1, 0, 0.502336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490649,-99) , 
9, 0.980425, 1, 0, 0.500921,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0153848);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530592,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49518,-99) , 
9, 0.90446, 0, 0, 0.516184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492789,-99) , 
6, 3.21986, 1, 0, 0.507263,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487813,-99) , 
6, 2.18589, 0, 0, 0.500842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468233,-99) , 
0, 66.9702, 0, 0, 0.498699,-99) , 
0, 132.582, 0, 0, 0.50045,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0146226);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.966162, 0, 1, 0.51707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497357,-99) , 
13, 0.980692, 1, 0, 0.508288,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495846,-99) , 
0, 88.8414, 1, 0, 0.497972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472065,-99) , 
0, 66.9702, 0, 0, 0.496271,-99) , 
0, 132.582, 0, 0, 0.498727,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0257817);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527891,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484833,-99) , 
0, 146.798, 1, 0, 0.498652,-99) , 
5, 1.36224, 1, 0, 0.504146,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498261,-99) , 
9, 0.932928, 0, 0, 0.505699,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462045,-99) , 
13, 0.942608, 1, 0, 0.482479,-99) , 
5, 1.37614, 0, 0, 0.496506,-99) , 
0, 109.618, 0, 0, 0.500681,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.014338);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523156,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481911,-99) , 
9, 0.942441, 1, 0, 0.501819,-99) , 
6, 2.82919, 1, 0, 0.507385,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472362,-99) , 
0, 127.747, 1, 0, 0.499008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481432,-99) , 
5, 0.907055, 0, 0, 0.497014,-99) , 
0, 132.582, 0, 0, 0.499133,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.017482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518256,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483028,-99) , 
6, 3.2012, 1, 0, 0.499202,-99) , 
11, 0.331729, 0, 0, 0.50556,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511095,-99) , 
NN(
0, 
0, 
-1, 3.63691, 1, -1, 0.493091,-99) , 
9, 0.85698, 1, 0, 0.494711,-99) , 
0, 132.582, 0, 0, 0.496927,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0120128);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489274,-99) , 
0, 125.397, 1, 0, 0.505789,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512722,-99) , 
NN(
0, 
0, 
-1, 3.63691, 1, -1, 0.4965,-99) , 
2, -0.243003, 1, 0, 0.498281,-99) , 
5, 2.79718, 0, 0, 0.499351,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0180885);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496581,-99) , 
9, 0.894943, 0, 0, 0.506969,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486146,-99) , 
7, 3.30412, 0, 0, 0.493758,-99) , 
2, 0.449778, 1, 0, 0.504173,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510609,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495758,-99) , 
1, 0.137382, 1, 0, 0.501833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477598,-99) , 
9, 0.980425, 1, 0, 0.49861,-99) , 
10, 0.971116, 0, 0, 0.5013,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0112792);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498487,-99) , 
2, 0.304063, 1, 0, 0.503656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487852,-99) , 
3, 129.786, 0, 0, 0.50258,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490862,-99) , 
3, 263.104, 1, 0, 0.50157,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.00938797);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 136.829, 1, 1, 0.50342,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481141,-99) , 
8, 0.991254, 1, 0, 0.493865,-99) , 
7, 4.0021, 1, 0, 0.502148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489884,-99) , 
7, 2.28368, 0, 0, 0.501417,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0178629);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49984,-99) , 
5, 1.35594, 1, 0, 0.504388,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485091,-99) , 
11, 0.651595, 0, 0, 0.495761,-99) , 
11, 0.331794, 1, 0, 0.501457,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496439,-99) , 
12, 0.997822, 0, 0, 0.501473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482227,-99) , 
10, 0.980623, 0, 0, 0.496325,-99) , 
12, 0.990127, 1, 0, 0.499607,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0110878);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497623,-99) , 
9, 0.942442, 1, 0, 0.503509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488341,-99) , 
4, 243.644, 1, 0, 0.502441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493761,-99) , 
3, 263.104, 1, 0, 0.501693,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0114247);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510132,-99) , 
NN(
NN(
0, 
0, 
-1, 88.1009, 1, 1, 0.502781,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485861,-99) , 
0, 110.392, 0, 0, 0.494029,-99) , 
5, 1.36091, 0, 0, 0.500482,-99) , 
4, 265.007, 0, 0, 0.501243,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.00912085);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507277,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499878,-99) , 
5, 0.878304, 1, 0, 0.501292,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483137,-99) , 
12, 0.933077, 1, 0, 0.493718,-99) , 
10, 0.942599, 0, 0, 0.498606,-99) , 
4, 265.007, 0, 0, 0.499289,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.020391);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490304,-99) , 
2, 0.52757, 1, 0, 0.504976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484457,-99) , 
11, 0.5778, 0, 0, 0.495966,-99) , 
11, 0.331794, 1, 0, 0.50196,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4927,-99) , 
13, 0.953906, 0, 0, 0.500659,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484331,-99) , 
13, 0.990115, 1, 0, 0.496395,-99) , 
10, 0.933094, 0, 0, 0.500177,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0164304);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499209,-99) , 
12, 0.97109, 1, 0, 0.509536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48489,-99) , 
9, 0.951941, 1, 0, 0.503323,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498455,-99) , 
11, 0.331642, 0, 0, 0.505049,-99) , 
NN(
0, 
0, 
-1, 0.331735, 1, -1, 0.493207,-99) , 
9, 0.932944, 0, 0, 0.497875,-99) , 
2, 0.370056, 0, 0, 0.499396,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00966047);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516572,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498055,-99) , 
9, 0.913955, 1, 0, 0.501815,-99) , 
1, -0.0655805, 1, 0, 0.502685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487617,-99) , 
10, 0.961781, 0, 0, 0.495719,-99) , 
1, -0.137683, 0, 0, 0.501907,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0135925);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.35019, 0, 1, 0.505941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487603,-99) , 
8, 0.955015, 0, 0, 0.503937,-99) , 
NN(
NN(
0, 
0, 
-1, 0.974516, 1, 1, 0.509124,-99) , 
NN(
0, 
0, 
-1, 0.376149, 0, -1, 0.493759,-99) , 
3, 156.617, 1, 0, 0.498073,-99) , 
9, 0.894963, 0, 0, 0.501769,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.00741499);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509539,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499209,-99) , 
0, 86.6548, 1, 0, 0.5047,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481323,-99) , 
2, 0.505447, 1, 0, 0.498002,-99) , 
13, 0.942595, 1, 0, 0.500118,-99) , 
1, 0.481215, 0, 0, 0.500646,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0160102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495846,-99) , 
7, 3.68751, 0, 0, 0.499685,-99) , 
0, 86.6548, 1, 0, 0.504463,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498009,-99) , 
5, 1.1104, 1, 0, 0.500275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458894,-99) , 
5, 1.14149, 0, 0, 0.484515,-99) , 
0, 87.4741, 0, 0, 0.497881,-99) , 
13, 0.942595, 1, 0, 0.49996,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0147898);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487455,-99) , 
8, 0.915968, 0, 0, 0.502053,-99) , 
0, 86.6548, 1, 0, 0.505724,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499928,-99) , 
9, 0.97093, 0, 0, 0.503423,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462872,-99) , 
5, 1.14149, 0, 0, 0.484494,-99) , 
0, 87.4741, 0, 0, 0.500548,-99) , 
13, 0.942595, 1, 0, 0.502183,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0158966);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.11413, 1, 1, 0.506385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484706,-99) , 
10, 0.923582, 0, 0, 0.49672,-99) , 
3, 156.617, 0, 0, 0.503666,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483079,-99) , 
13, 0.942612, 1, 0, 0.496009,-99) , 
0, 86.6548, 0, 0, 0.502484,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00807652);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514311,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498215,-99) , 
10, 0.866556, 1, 0, 0.499296,-99) , 
5, 0.873692, 1, 0, 0.500701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493629,-99) , 
9, 0.980425, 1, 0, 0.499846,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0132071);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486999,-99) , 
9, 0.951941, 1, 0, 0.50585,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496725,-99) , 
9, 0.932944, 0, 0, 0.500327,-99) , 
2, 0.370056, 0, 0, 0.501845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491786,-99) , 
7, 4.53906, 1, 0, 0.501314,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0181502);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499451,-99) , 
1, 0.152387, 1, 0, 0.511539,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484711,-99) , 
15, 0.331794, 1, 0, 0.50059,-99) , 
0, 132.582, 0, 0, 0.502802,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472887,-99) , 
1, 0.083382, 0, 0, 0.495509,-99) , 
9, 0.970929, 1, 0, 0.501536,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0122257);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495198,-99) , 
1, 0.152387, 1, 0, 0.508746,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48917,-99) , 
0, 116.176, 1, 0, 0.498178,-99) , 
0, 132.582, 0, 0, 0.500328,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492426,-99) , 
9, 0.980425, 1, 0, 0.499373,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0105662);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497937,-99) , 
1, 0.186639, 1, 0, 0.508595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49681,-99) , 
2, -0.243003, 1, 0, 0.498161,-99) , 
5, 2.79718, 0, 0, 0.499564,-99) , 
NN(
0, 
0, 
-1, 207.667, 1, -1, 0.491425,-99) , 
1, -0.137683, 0, 0, 0.498656,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0152);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00527429, 1, 1, 0.511066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493068,-99) , 
5, 2.56371, 1, 0, 0.505337,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498763,-99) , 
2, 0.429808, 0, 0, 0.50386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477004,-99) , 
2, 0.300228, 1, 0, 0.492169,-99) , 
0, 99.7743, 0, 0, 0.499424,-99) , 
0, 132.582, 0, 0, 0.500632,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
