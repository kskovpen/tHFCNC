// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Feb 14 13:59:32 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 8974
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 19
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [20.2688121796,500]
TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD                                         'D'    [58.5842285156,1000]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.670251607895,0.811453938484]
MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD                                                'D'    [-0.819244325161,0.724039137363]
HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB            HiggsEta_TOPHLEPBB                                              'D'    [-6.68812131882,6.19571208954]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [87.5672454834,500]
TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD                                         'D'    [69.2039871216,500]
TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB            TopLepPt_TOPHLEPBB                                              'D'    [1.80893290043,1000]
TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB           TopLepEta_TOPHLEPBB                                             'D'    [-5.94298696518,5.05945110321]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.40500625968,4.53621196747]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.159456312656,7.82505989075]
TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD                                     'D'    [0.0325338356197,7.0212726593]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [0.848929703236,0.99962580204]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [0.800079166889,0.999099850655]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [0.800964355469,0.999454319477]
TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD  TopLepBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.800361812115,0.999459385872]
TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD  TopHadBJetCSVv2_TOPTOPLEPHAD                                    'D'    [0.804405987263,0.99962580204]
TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD TopHadWNonBJet1CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.99919629097]
TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD TopHadWNonBJet2CSVv2_TOPTOPLEPHAD                                       'D'    [-10,0.994495391846]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 19 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "TopHadMass_TOPTOPLEPHAD", "MVA_TOPHLEPBB", "MVA_TOPTOPLEPHAD", "HiggsEta_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "TopLepMass_TOPTOPLEPHAD", "TopLepPt_TOPHLEPBB", "TopLepEta_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "TopLepTopHadDr_TOPTOPLEPHAD", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPTOPLEPHAD", "TopHadBJetCSVv2_TOPTOPLEPHAD", "TopHadWNonBJet1CSVv2_TOPTOPLEPHAD", "TopHadWNonBJet2CSVv2_TOPTOPLEPHAD" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';
      fType[12] = 'D';
      fType[13] = 'D';
      fType[14] = 'D';
      fType[15] = 'D';
      fType[16] = 'D';
      fType[17] = 'D';
      fType[18] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[19];
   double fVmax[19];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[19];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.349342639288143);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.914661, 0, 1, 0.721816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470146,-99) , 
18, 0.844924, 0, 0, 0.676389,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.233924,-99) , 
17, 0.797445, 0, 0, 0.445184,-99) , 
NN(
0, 
0, 
-1, 0.977943, 0, -1, 0.255664,-99) , 
17, 0.473071, 0, 0, 0.369978,-99) , 
18, 0.470948, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.311976);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.962724, 0, 1, 0.725768,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417813,-99) , 
16, 0.961047, 0, 0, 0.524114,-99) , 
13, 0.914171, 0, 0, 0.629527,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412969,-99) , 
2, 0.332162, 0, 0, 0.519558,-99) , 
NN(
0, 
0, 
-1, 0.148858, 0, -1, 0.339327,-99) , 
13, 0.970665, 0, 0, 0.374653,-99) , 
18, 0.470948, 0, 0, 0.482041,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.218668);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.942063, 0, 1, 0.600447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356721,-99) , 
17, 0.863864, 0, 0, 0.440386,-99) , 
3, 0.139129, 1, 0, 0.527709,-99) , 
NN(
0, 
0, 
-1, 141.169, 1, -1, 0.31724,-99) , 
2, 0.176437, 0, 0, 0.494345,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.233553);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469056,-99) , 
17, 0.820437, 0, 0, 0.577244,-99) , 
NN(
0, 
0, 
-1, 0.127158, 1, -1, 0.435505,-99) , 
13, 0.904328, 0, 0, 0.515764,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.281829,-99) , 
9, 1.21222, 1, 0, 0.454664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.170864,-99) , 
2, 0.459783, 0, 0, 0.359167,-99) , 
7, 239.473, 1, 0, 0.477663,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.159508);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497567,-99) , 
3, 0.147094, 1, 0, 0.544343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402716,-99) , 
2, 0.130732, 0, 0, 0.528663,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331402,-99) , 
9, 1.21222, 1, 0, 0.448673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206531,-99) , 
2, 0.459783, 0, 0, 0.369466,-99) , 
7, 239.473, 1, 0, 0.490859,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.150635);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.82462, 1, 1, 0.615759,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471412,-99) , 
7, 148.975, 1, 0, 0.51108,-99) , 
13, 0.970668, 0, 0, 0.530985,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329577,-99) , 
1, 202.676, 0, 0, 0.444403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.233893,-99) , 
2, 0.459783, 0, 0, 0.376986,-99) , 
7, 239.473, 1, 0, 0.494924,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.136079);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.469393, 0, 1, 0.55027,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408504,-99) , 
7, 126.292, 1, 0, 0.472011,-99) , 
2, 0.26423, 0, 0, 0.521922,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415947,-99) , 
2, 0.688932, 1, 0, 0.46889,-99) , 
NN(
0, 
0, 
-1, 0.387191, 0, -1, 0.296789,-99) , 
2, 0.577007, 0, 0, 0.382922,-99) , 
7, 239.473, 1, 0, 0.489733,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.111615);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438686,-99) , 
0, 96.3966, 0, 0, 0.501048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354539,-99) , 
0, 134.491, 1, 0, 0.486351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269223,-99) , 
10, 1.9846, 0, 0, 0.475174,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.126818);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474709,-99) , 
0, 101.809, 0, 0, 0.538894,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424198,-99) , 
18, 0.470948, 0, 0, 0.461561,-99) , 
9, 1.43009, 1, 0, 0.48522,-99) , 
NN(
0, 
0, 
-1, 0.576613, 0, -1, 0.349055,-99) , 
7, 287.006, 1, 0, 0.468444,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.103268);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471447,-99) , 
9, 1.78551, 1, 0, 0.558631,-99) , 
NN(
0, 
0, 
-1, 253.831, 1, -1, 0.465483,-99) , 
13, 0.970668, 0, 0, 0.482854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300433,-99) , 
10, 1.9846, 0, 0, 0.473697,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0664041);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613913,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387977,-99) , 
6, 253.831, 1, 0, 0.499314,-99) , 
13, 0.989623, 0, 0, 0.507801,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.257661,-99) , 
2, 0.576613, 0, 0, 0.395757,-99) , 
7, 287.006, 1, 0, 0.494277,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.101126);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476002,-99) , 
8, -0.894807, 0, 0, 0.539208,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436802,-99) , 
0, 112.234, 1, 0, 0.473366,-99) , 
9, 1.43009, 1, 0, 0.493443,-99) , 
NN(
0, 
0, 
-1, 0.576613, 0, -1, 0.392888,-99) , 
7, 287.006, 1, 0, 0.481366,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0595621);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582541,-99) , 
NN(
0, 
0, 
-1, 239.473, 1, -1, 0.47431,-99) , 
13, 0.989623, 0, 0, 0.482031,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0991398);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466538,-99) , 
11, 3.44486, 1, 0, 0.548369,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415348,-99) , 
11, 2.69491, 0, 0, 0.495226,-99) , 
9, 1.43009, 1, 0, 0.509531,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40369,-99) , 
2, 0.576613, 0, 0, 0.498859,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344842,-99) , 
1, 193.072, 0, 0, 0.443292,-99) , 
7, 239.473, 1, 0, 0.494784,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.099232);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 372.389, 0, 1, 0.531147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423435,-99) , 
4, -1.10095, 0, 0, 0.514403,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437053,-99) , 
9, 2.27387, 0, 0, 0.486892,-99) , 
NN(
0, 
0, 
-1, 0.773642, 0, -1, 0.397495,-99) , 
7, 185.782, 1, 0, 0.461027,-99) , 
9, 1.58535, 1, 0, 0.483721,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0736483);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467576,-99) , 
8, -0.703731, 0, 0, 0.497316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391644,-99) , 
0, 134.782, 1, 0, 0.487974,-99) , 
NN(
0, 
0, 
-1, 166.822, 1, -1, 0.408402,-99) , 
16, 0.906664, 0, 0, 0.478824,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.092722);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484166,-99) , 
11, 3.10635, 0, 0, 0.522562,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384733,-99) , 
9, 1.6089, 1, 0, 0.447946,-99) , 
6, 162.006, 1, 0, 0.504487,-99) , 
NN(
0, 
0, 
-1, 0.917111, 0, -1, 0.453043,-99) , 
6, 171.774, 1, 0, 0.478777,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0666565);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419362,-99) , 
3, 0.50357, 1, 0, 0.505432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419064,-99) , 
10, 2.34963, 0, 0, 0.496072,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404201,-99) , 
12, 0.913514, 0, 0, 0.489383,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0599206);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470881,-99) , 
13, 0.904326, 0, 0, 0.493496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412757,-99) , 
6, 253.831, 1, 0, 0.487222,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394661,-99) , 
7, 334.539, 1, 0, 0.481283,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0545025);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.159158, 0, 1, 0.535308,-99) , 
NN(
0, 
0, 
-1, 334.539, 1, -1, 0.473977,-99) , 
3, -0.231327, 1, 0, 0.481913,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0423089);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499855,-99) , 
15, 0.885687, 1, 0, 0.506016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426807,-99) , 
11, 2.36211, 0, 0, 0.500631,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533144,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394894,-99) , 
6, 159.155, 1, 0, 0.442382,-99) , 
2, 0.176437, 0, 0, 0.491998,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0679316);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456576,-99) , 
0, 87.0289, 0, 0, 0.515004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437188,-99) , 
11, 2.36211, 0, 0, 0.509728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405048,-99) , 
6, 159.155, 1, 0, 0.445507,-99) , 
2, 0.176437, 0, 0, 0.500234,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0487842);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490956,-99) , 
9, 1.1919, 1, 0, 0.502042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431289,-99) , 
6, 253.831, 1, 0, 0.496601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418172,-99) , 
7, 334.539, 1, 0, 0.491623,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0519314);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484077,-99) , 
8, 0.344121, 1, 0, 0.509295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443292,-99) , 
6, 253.831, 1, 0, 0.504232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430086,-99) , 
7, 334.539, 1, 0, 0.499539,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0408421);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.924373, 1, 1, 0.511873,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445937,-99) , 
16, 0.906664, 0, 0, 0.505,-99) , 
NN(
0, 
0, 
-1, 141.169, 1, -1, 0.455616,-99) , 
2, 0.176437, 0, 0, 0.49773,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0763377);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418331,-99) , 
12, 0.971487, 0, 0, 0.528983,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48224,-99) , 
3, -0.183665, 1, 0, 0.529968,-99) , 
NN(
0, 
0, 
-1, 287.1, 1, -1, 0.47456,-99) , 
1, 372.389, 0, 0, 0.484273,-99) , 
5, 146.486, 1, 0, 0.492335,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0619971);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.889606, 1, 1, 0.517019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452511,-99) , 
14, 0.867128, 0, 0, 0.512267,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439349,-99) , 
0, 111.646, 0, 0, 0.51114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404473,-99) , 
1, 193.072, 0, 0, 0.473082,-99) , 
7, 239.473, 1, 0, 0.503735,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0591425);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460841,-99) , 
8, -1.22766, 0, 0, 0.504707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438147,-99) , 
13, 0.856942, 0, 0, 0.499349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444021,-99) , 
0, 134.491, 1, 0, 0.494188,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0324395);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545888,-99) , 
NN(
0, 
0, 
-1, 253.831, 1, -1, 0.486052,-99) , 
13, 0.989623, 0, 0, 0.490298,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.097664);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433918,-99) , 
13, 0.876799, 0, 0, 0.523545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463748,-99) , 
13, 0.885374, 1, 0, 0.490104,-99) , 
4, -0.552963, 1, 0, 0.502567,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354177,-99) , 
10, 2.03655, 0, 0, 0.452566,-99) , 
10, 2.34963, 0, 0, 0.497255,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0539638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.888072, 1, 1, 0.509978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416942,-99) , 
8, -0.998117, 1, 0, 0.46712,-99) , 
3, 0.43008, 1, 0, 0.502536,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371754,-99) , 
4, 0.0583182, 0, 0, 0.451014,-99) , 
10, 2.34963, 0, 0, 0.497086,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.034262);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424218,-99) , 
17, 0.195266, 0, 0, 0.497878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42631,-99) , 
11, 2.38781, 0, 0, 0.492516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434414,-99) , 
6, 253.831, 1, 0, 0.487673,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0938349);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453545,-99) , 
13, 0.876333, 0, 0, 0.52508,-99) , 
NN(
0, 
0, 
-1, 0.98997, 1, -1, 0.464126,-99) , 
2, 0.389949, 0, 0, 0.496322,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431916,-99) , 
1, 204.635, 1, 0, 0.491965,-99) , 
NN(
0, 
0, 
-1, 3.09349, 1, -1, 0.399759,-99) , 
7, 185.782, 1, 0, 0.468151,-99) , 
9, 1.78207, 1, 0, 0.482651,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0880844);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543109,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467896,-99) , 
15, 0.93328, 1, 0, 0.486634,-99) , 
13, 0.97079, 0, 0, 0.500799,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469924,-99) , 
8, -0.776371, 1, 0, 0.504185,-99) , 
NN(
0, 
0, 
-1, 2.77834, 0, -1, 0.445328,-99) , 
16, 0.99033, 0, 0, 0.467775,-99) , 
9, 1.78207, 1, 0, 0.484782,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0613026);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446364,-99) , 
0, 106.612, 1, 0, 0.536711,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480462,-99) , 
5, 177.345, 0, 0, 0.492002,-99) , 
5, 205.405, 0, 0, 0.49797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439044,-99) , 
7, 334.539, 1, 0, 0.494317,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0808517);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489064,-99) , 
8, -0.703731, 0, 0, 0.526462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405878,-99) , 
15, 0.91439, 0, 0, 0.513398,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461382,-99) , 
4, -0.123075, 0, 0, 0.499153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42545,-99) , 
7, 234.076, 1, 0, 0.486403,-99) , 
1, 193.072, 0, 0, 0.500613,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0361989);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.492886, 0, 1, 0.543338,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424528,-99) , 
3, 0.525191, 1, 0, 0.497989,-99) , 
5, 205.405, 0, 0, 0.503722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454536,-99) , 
6, 253.831, 1, 0, 0.499645,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0608647);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499146,-99) , 
8, -0.159158, 0, 0, 0.525108,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469487,-99) , 
6, 171.774, 1, 0, 0.503541,-99) , 
NN(
0, 
0, 
-1, 187.622, 1, -1, 0.468078,-99) , 
13, 0.92328, 1, 0, 0.488656,-99) , 
3, -0.231327, 1, 0, 0.4934,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0318658);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558745,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501149,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41494,-99) , 
7, 287.006, 1, 0, 0.49368,-99) , 
1, 386.932, 0, 0, 0.500759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447854,-99) , 
1, 551.707, 1, 0, 0.497946,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0719947);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555889,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428219,-99) , 
9, 0.91074, 0, 0, 0.493941,-99) , 
1, 417.219, 0, 0, 0.5063,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463791,-99) , 
2, 0.391216, 1, 0, 0.499015,-99) , 
NN(
0, 
0, 
-1, -0.300622, 1, -1, 0.441677,-99) , 
0, 121.373, 1, 0, 0.481455,-99) , 
9, 1.58535, 1, 0, 0.491988,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0652707);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585386,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498775,-99) , 
9, 1.0998, 1, 0, 0.514096,-99) , 
NN(
0, 
0, 
-1, 3.41176, 1, -1, 0.452094,-99) , 
0, 97.2342, 0, 0, 0.500915,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567995,-99) , 
NN(
0, 
0, 
-1, 189.688, 1, -1, 0.456296,-99) , 
10, 3.80974, 0, 0, 0.471673,-99) , 
2, 0.317552, 0, 0, 0.489161,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0743179);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492373,-99) , 
3, 0.212243, 1, 0, 0.524663,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409822,-99) , 
10, 3.41176, 1, 0, 0.468307,-99) , 
0, 97.2342, 0, 0, 0.512702,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453868,-99) , 
17, 0.909528, 1, 0, 0.501368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402808,-99) , 
7, 187.622, 1, 0, 0.483443,-99) , 
2, 0.317552, 0, 0, 0.500952,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0612415);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 127.487, 0, 1, 0.520732,-99) , 
NN(
0, 
0, 
-1, 0.567724, 1, -1, 0.464688,-99) , 
0, 97.2342, 0, 0, 0.508845,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454356,-99) , 
13, 0.904411, 0, 0, 0.494828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420807,-99) , 
7, 187.622, 1, 0, 0.481419,-99) , 
2, 0.317552, 0, 0, 0.497836,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0809426);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485425,-99) , 
12, 0.978323, 0, 0, 0.52744,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380993,-99) , 
2, 0.338206, 1, 0, 0.45232,-99) , 
14, 0.995855, 1, 0, 0.50589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550393,-99) , 
NN(
0, 
0, 
-1, 239.473, 1, -1, 0.468484,-99) , 
15, 0.885683, 1, 0, 0.47913,-99) , 
14, 0.961647, 0, 0, 0.492742,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0316604);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426031,-99) , 
2, 0.149089, 0, 0, 0.495048,-99) , 
1, 386.932, 0, 0, 0.501054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444138,-99) , 
1, 551.707, 1, 0, 0.498063,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0600672);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434308,-99) , 
12, 0.971487, 0, 0, 0.517025,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488572,-99) , 
11, 3.2982, 1, 0, 0.532664,-99) , 
NN(
0, 
0, 
-1, 144.519, 0, -1, 0.479015,-99) , 
4, -1.62813, 1, 0, 0.486809,-99) , 
5, 146.486, 1, 0, 0.492248,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.072198);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478714,-99) , 
7, 210.114, 1, 0, 0.532724,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436568,-99) , 
6, 194.54, 1, 0, 0.515512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470866,-99) , 
9, 1.19814, 1, 0, 0.484496,-99) , 
8, -0.703731, 1, 0, 0.496487,-99) , 
5, 205.405, 0, 0, 0.501485,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0413659);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449869,-99) , 
12, 0.914416, 0, 0, 0.509734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444934,-99) , 
17, 0.195266, 0, 0, 0.505676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459774,-99) , 
11, 2.36211, 0, 0, 0.502456,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0532775);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494069,-99) , 
11, 3.36567, 0, 0, 0.525107,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486104,-99) , 
3, -0.083764, 1, 0, 0.507238,-99) , 
NN(
0, 
0, 
-1, 3.33778, 1, -1, 0.475372,-99) , 
0, 111.646, 0, 0, 0.491396,-99) , 
5, 205.405, 0, 0, 0.496038,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0504461);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.905677, 0, 1, 0.519477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522302,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462211,-99) , 
16, 0.990268, 0, 0, 0.49095,-99) , 
13, 0.923282, 1, 0, 0.507235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455872,-99) , 
1, 551.707, 1, 0, 0.504547,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0544922);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 129.303, 0, 1, 0.514932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463887,-99) , 
10, 4.00369, 1, 0, 0.507471,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477636,-99) , 
4, -0.491817, 1, 0, 0.512477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40872,-99) , 
11, 3.13816, 1, 0, 0.461048,-99) , 
12, 0.985355, 1, 0, 0.485394,-99) , 
2, 0.317552, 0, 0, 0.498606,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0555216);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457056,-99) , 
12, 0.985583, 1, 0, 0.520591,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486198,-99) , 
3, 0.350908, 0, 0, 0.495334,-99) , 
NN(
0, 
0, 
-1, 0.199923, 1, -1, 0.455473,-99) , 
11, 3.45516, 1, 0, 0.488057,-99) , 
11, 4.0261, 0, 0, 0.492889,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0490827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5659,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490733,-99) , 
17, 0.86419, 1, 0, 0.528708,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47972,-99) , 
14, 0.942743, 0, 0, 0.502034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437301,-99) , 
3, 0.504698, 1, 0, 0.495651,-99) , 
5, 205.405, 0, 0, 0.500208,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0509748);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487575,-99) , 
11, 3.06617, 0, 0, 0.528633,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477524,-99) , 
6, 151.26, 1, 0, 0.488806,-99) , 
3, -0.22644, 1, 0, 0.49449,-99) , 
5, 205.405, 0, 0, 0.499193,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0232811);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557101,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454316,-99) , 
9, 0.798454, 0, 0, 0.501452,-99) , 
3, 0.564948, 0, 0, 0.504673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459915,-99) , 
7, 334.539, 1, 0, 0.501985,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0485968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483648,-99) , 
13, 0.904411, 0, 0, 0.522815,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592311,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466259,-99) , 
3, 0.235793, 0, 0, 0.525985,-99) , 
NN(
0, 
0, 
-1, 0.277423, 0, -1, 0.486281,-99) , 
16, 0.925256, 1, 0, 0.493436,-99) , 
5, 205.405, 0, 0, 0.49748,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0476816);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57026,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429377,-99) , 
17, 0.232312, 0, 0, 0.505023,-99) , 
16, 0.924372, 1, 0, 0.509811,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408089,-99) , 
6, 166.822, 1, 0, 0.473501,-99) , 
16, 0.906664, 0, 0, 0.505901,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0679315);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.78355, 1, 1, 0.525803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44936,-99) , 
16, 0.939206, 0, 0, 0.50885,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487185,-99) , 
8, -0.703731, 1, 0, 0.50701,-99) , 
NN(
0, 
0, 
-1, -0.596516, 0, -1, 0.398107,-99) , 
10, 2.58676, 0, 0, 0.489641,-99) , 
4, 0.674069, 0, 0, 0.496631,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.055546);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.277423, 1, 1, 0.51113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418884,-99) , 
13, 0.858084, 0, 0, 0.503695,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465757,-99) , 
14, 0.98698, 1, 0, 0.51735,-99) , 
NN(
0, 
0, 
-1, 0.374413, 0, -1, 0.434378,-99) , 
14, 0.9558, 0, 0, 0.477035,-99) , 
8, -1.22766, 0, 0, 0.497005,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0651999);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460999,-99) , 
12, 0.985583, 1, 0, 0.513973,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474403,-99) , 
16, 0.98102, 1, 0, 0.502555,-99) , 
NN(
0, 
0, 
-1, 3.47427, 1, -1, 0.4693,-99) , 
4, 0.0605533, 1, 0, 0.486041,-99) , 
11, 4.0261, 0, 0, 0.490173,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0676404);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466947,-99) , 
4, 0.0337559, 1, 0, 0.533138,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479483,-99) , 
4, 0.807716, 0, 0, 0.495471,-99) , 
0, 90.2357, 1, 0, 0.501778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562283,-99) , 
NN(
0, 
0, 
-1, 180.47, 1, -1, 0.451178,-99) , 
9, 0.805126, 1, 0, 0.478536,-99) , 
7, 239.473, 1, 0, 0.496875,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.049529);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.885861, 1, 1, 0.514407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427302,-99) , 
10, 2.24, 0, 0, 0.507355,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532042,-99) , 
NN(
0, 
0, 
-1, 3.25581, 1, -1, 0.44518,-99) , 
4, 1.98878, 0, 0, 0.480772,-99) , 
4, 1.28759, 1, 0, 0.501689,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0394727);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481478,-99) , 
8, -0.282839, 0, 0, 0.548574,-99) , 
NN(
0, 
0, 
-1, 0.474982, 1, -1, 0.488948,-99) , 
6, 209.826, 0, 0, 0.496818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462257,-99) , 
6, 253.831, 1, 0, 0.493994,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.028135);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536843,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496346,-99) , 
6, 209.826, 0, 0, 0.503437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45836,-99) , 
6, 253.831, 1, 0, 0.499857,-99) , 
13, 0.989623, 0, 0, 0.502507,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0559565);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53149,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488614,-99) , 
2, 0.291603, 0, 0, 0.516863,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454666,-99) , 
7, 139.261, 1, 0, 0.486013,-99) , 
6, 148.304, 0, 0, 0.509535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47772,-99) , 
6, 253.831, 1, 0, 0.506939,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0557814);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495323,-99) , 
17, 0.897239, 1, 0, 0.543217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472989,-99) , 
17, 0.732262, 0, 0, 0.521475,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480504,-99) , 
14, 0.989988, 1, 0, 0.507769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449916,-99) , 
2, 0.300965, 0, 0, 0.499739,-99) , 
2, 0.246995, 1, 0, 0.505609,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0481801);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561541,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443936,-99) , 
2, 0.151542, 0, 0, 0.506471,-99) , 
4, 0.674086, 0, 0, 0.526346,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495313,-99) , 
15, 0.886029, 1, 0, 0.500544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442905,-99) , 
11, 4.3589, 1, 0, 0.496198,-99) , 
2, 0.246995, 1, 0, 0.504333,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0572386);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564838,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43634,-99) , 
3, 0.50357, 1, 0, 0.508845,-99) , 
15, 0.93456, 1, 0, 0.514009,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43239,-99) , 
17, 0.79055, 0, 0, 0.486828,-99) , 
15, 0.914132, 0, 0, 0.510298,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0391918);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545368,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454986,-99) , 
1, 261.742, 1, 0, 0.496841,-99) , 
1, 386.932, 0, 0, 0.502067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461559,-99) , 
1, 551.707, 1, 0, 0.499972,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0532242);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57475,-99) , 
NN(
0, 
0, 
-1, 2.09601, 0, -1, 0.489871,-99) , 
10, 3.28788, 0, 0, 0.500628,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452287,-99) , 
12, 0.978323, 0, 0, 0.497862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413536,-99) , 
11, 2.95463, 0, 0, 0.481059,-99) , 
10, 3.44472, 1, 0, 0.494588,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0574681);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561693,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426595,-99) , 
10, 2.09601, 0, 0, 0.503176,-99) , 
10, 3.28788, 0, 0, 0.510569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433812,-99) , 
1, 282.731, 1, 0, 0.499636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429563,-99) , 
14, 0.990146, 1, 0, 0.481263,-99) , 
10, 3.44472, 1, 0, 0.501532,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0593769);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466866,-99) , 
16, 0.981785, 1, 0, 0.518115,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482679,-99) , 
0, 88.8966, 1, 0, 0.493101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429946,-99) , 
7, 287.006, 1, 0, 0.487697,-99) , 
1, 372.389, 0, 0, 0.492739,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0421788);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565365,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492209,-99) , 
5, 205.405, 0, 0, 0.499323,-99) , 
16, 0.924372, 1, 0, 0.504174,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412319,-99) , 
6, 166.822, 1, 0, 0.475372,-99) , 
16, 0.906664, 0, 0, 0.501098,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0412506);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.856942, 1, 1, 0.514711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469169,-99) , 
1, 148.243, 0, 0, 0.510425,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41977,-99) , 
17, 0.505555, 1, 0, 0.474786,-99) , 
16, 0.906664, 0, 0, 0.506625,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.058344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.508822, 1, 1, 0.514566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444178,-99) , 
14, 0.962285, 1, 0, 0.484859,-99) , 
10, 3.44472, 1, 0, 0.504206,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473151,-99) , 
8, -0.345889, 1, 0, 0.518017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425697,-99) , 
15, 0.973935, 0, 0, 0.480212,-99) , 
7, 239.473, 1, 0, 0.499179,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0598797);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490111,-99) , 
16, 0.950932, 1, 0, 0.509458,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453801,-99) , 
18, 0.469393, 0, 0, 0.482431,-99) , 
8, -0.179805, 0, 0, 0.495723,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413405,-99) , 
0, 111.646, 0, 0, 0.466429,-99) , 
16, 0.906664, 0, 0, 0.49261,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0508414);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497486,-99) , 
2, 0.246514, 1, 0, 0.507852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447122,-99) , 
0, 134.782, 1, 0, 0.502813,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484294,-99) , 
13, 0.869055, 0, 0, 0.526457,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384141,-99) , 
3, 0.219945, 0, 0, 0.436884,-99) , 
13, 0.885372, 1, 0, 0.477134,-99) , 
16, 0.943849, 0, 0, 0.496349,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0431139);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564834,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498444,-99) , 
8, 1.63034, 0, 0, 0.504561,-99) , 
2, 0.670339, 0, 0, 0.509587,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493565,-99) , 
11, 3.14674, 1, 0, 0.527871,-99) , 
NN(
0, 
0, 
-1, 0.980543, 0, -1, 0.438169,-99) , 
13, 0.885372, 1, 0, 0.478503,-99) , 
16, 0.943849, 0, 0, 0.501774,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.055752);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 123.907, 0, 1, 0.520966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468307,-99) , 
0, 134.782, 1, 0, 0.51661,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497793,-99) , 
13, 0.869055, 0, 0, 0.528104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390584,-99) , 
15, 0.980543, 0, 0, 0.448809,-99) , 
13, 0.885372, 1, 0, 0.484487,-99) , 
16, 0.943849, 0, 0, 0.508546,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0509032);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.950932, 1, 1, 0.519797,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455344,-99) , 
14, 0.952323, 0, 0, 0.487887,-99) , 
8, -0.179805, 0, 0, 0.503594,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517072,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416978,-99) , 
6, 166.822, 1, 0, 0.46949,-99) , 
16, 0.906664, 0, 0, 0.500005,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.072113);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56334,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42751,-99) , 
2, 0.28766, 0, 0, 0.487756,-99) , 
14, 0.906569, 1, 0, 0.506612,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479711,-99) , 
15, 0.933291, 1, 0, 0.49595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389288,-99) , 
15, 0.980804, 0, 0, 0.444522,-99) , 
16, 0.917111, 0, 0, 0.487018,-99) , 
13, 0.942237, 0, 0, 0.493424,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0448094);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536725,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488627,-99) , 
13, 0.866419, 1, 0, 0.495222,-99) , 
8, 1.63034, 0, 0, 0.499357,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396784,-99) , 
8, -0.121573, 1, 0, 0.470137,-99) , 
16, 0.91596, 0, 0, 0.495493,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0360848);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492345,-99) , 
17, 0.86419, 1, 0, 0.534835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444189,-99) , 
2, 0.151528, 0, 0, 0.500428,-99) , 
5, 205.405, 0, 0, 0.505253,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407557,-99) , 
8, -0.121573, 1, 0, 0.468565,-99) , 
16, 0.91596, 0, 0, 0.500409,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0462752);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495512,-99) , 
14, 0.974846, 0, 0, 0.535555,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486714,-99) , 
14, 0.886032, 1, 0, 0.492718,-99) , 
5, 205.405, 0, 0, 0.498719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414653,-99) , 
17, 0.589896, 1, 0, 0.467293,-99) , 
16, 0.91596, 0, 0, 0.494575,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.042881);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486875,-99) , 
16, 0.987555, 1, 0, 0.536464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480575,-99) , 
11, 3.3605, 1, 0, 0.500807,-99) , 
5, 205.405, 0, 0, 0.505797,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415541,-99) , 
8, -0.121573, 1, 0, 0.467062,-99) , 
16, 0.91596, 0, 0, 0.500695,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0409364);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.0261, 0, 1, 0.510826,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446297,-99) , 
3, -0.0113955, 1, 0, 0.479946,-99) , 
14, 0.923839, 0, 0, 0.502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419307,-99) , 
14, 0.923989, 1, 0, 0.460834,-99) , 
16, 0.906664, 0, 0, 0.497708,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0365375);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499043,-99) , 
12, 0.985795, 1, 0, 0.534482,-99) , 
NN(
0, 
0, 
-1, 2.96438, 1, -1, 0.488598,-99) , 
11, 4.0261, 0, 0, 0.495351,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414323,-99) , 
16, 0.889331, 1, 0, 0.464245,-99) , 
16, 0.91596, 0, 0, 0.491263,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0295612);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541899,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431734,-99) , 
16, 0.938715, 0, 0, 0.499646,-99) , 
16, 0.924372, 1, 0, 0.502685,-99) , 
NN(
0, 
0, 
-1, 111.646, 0, -1, 0.45706,-99) , 
16, 0.906664, 0, 0, 0.497938,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0330504);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563553,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494001,-99) , 
4, 0.190503, 0, 0, 0.528627,-99) , 
NN(
0, 
0, 
-1, 2.96438, 1, -1, 0.491302,-99) , 
11, 4.0261, 0, 0, 0.49679,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425989,-99) , 
15, 0.980811, 0, 0, 0.467444,-99) , 
16, 0.91596, 0, 0, 0.492938,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0383266);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.86419, 1, 1, 0.53548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490212,-99) , 
8, 0.650588, 0, 0, 0.498712,-99) , 
5, 205.405, 0, 0, 0.503844,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429863,-99) , 
17, 0.508839, 1, 0, 0.467573,-99) , 
16, 0.91596, 0, 0, 0.499087,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0332733);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438271,-99) , 
6, 130.746, 0, 0, 0.500661,-99) , 
8, -1.79878, 1, 0, 0.505671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426159,-99) , 
16, 0.889331, 1, 0, 0.468297,-99) , 
16, 0.91596, 0, 0, 0.500775,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0212088);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539043,-99) , 
NN(
0, 
0, 
-1, 0.232312, 0, -1, 0.495041,-99) , 
16, 0.924372, 1, 0, 0.498187,-99) , 
NN(
0, 
0, 
-1, 0.923989, 1, -1, 0.461717,-99) , 
16, 0.906664, 0, 0, 0.494402,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0327157);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534609,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492615,-99) , 
14, 0.886032, 1, 0, 0.498505,-99) , 
8, -1.79878, 1, 0, 0.503338,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430616,-99) , 
8, -0.121573, 1, 0, 0.470376,-99) , 
16, 0.91596, 0, 0, 0.499024,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0356356);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539946,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433413,-99) , 
7, 287.006, 1, 0, 0.504362,-99) , 
2, 0.670339, 0, 0, 0.507276,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435368,-99) , 
15, 0.980811, 0, 0, 0.469211,-99) , 
16, 0.91596, 0, 0, 0.502296,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0427662);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569947,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420856,-99) , 
14, 0.927365, 0, 0, 0.495259,-99) , 
14, 0.910353, 1, 0, 0.50122,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524099,-99) , 
NN(
0, 
0, 
-1, 0.710302, 1, -1, 0.423424,-99) , 
18, 0.41164, 0, 0, 0.471297,-99) , 
14, 0.895483, 0, 0, 0.495496,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0646184);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470359,-99) , 
16, 0.975753, 1, 0, 0.503285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440068,-99) , 
16, 0.983654, 0, 0, 0.481791,-99) , 
15, 0.980498, 1, 0, 0.491951,-99) , 
NN(
0, 
0, 
-1, 0.952284, 1, -1, 0.464482,-99) , 
16, 0.91596, 0, 0, 0.48836,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0870847);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457847,-99) , 
15, 0.911868, 0, 0, 0.512176,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417315,-99) , 
6, 157.972, 1, 0, 0.468407,-99) , 
8, -1.00661, 0, 0, 0.498313,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469312,-99) , 
15, 0.995831, 1, 0, 0.516178,-99) , 
NN(
0, 
0, 
-1, 185.766, 1, -1, 0.455265,-99) , 
2, 0.415672, 0, 0, 0.481229,-99) , 
15, 0.980498, 1, 0, 0.489381,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0644894);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444755,-99) , 
5, 169.179, 1, 0, 0.531053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463558,-99) , 
9, 3.03756, 1, 0, 0.5089,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490344,-99) , 
15, 0.93004, 1, 0, 0.498567,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380239,-99) , 
9, 1.6404, 1, 0, 0.460089,-99) , 
17, 0.820545, 0, 0, 0.487181,-99) , 
9, 2.56897, 0, 0, 0.491861,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0519015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482187,-99) , 
7, 127.975, 0, 0, 0.518344,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496945,-99) , 
13, 0.961224, 0, 0, 0.508256,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414575,-99) , 
17, 0.312633, 1, 0, 0.461039,-99) , 
17, 0.820545, 0, 0, 0.494139,-99) , 
9, 2.7657, 0, 0, 0.497879,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0675958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483407,-99) , 
3, 0.198113, 1, 0, 0.513593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457394,-99) , 
17, 0.799711, 0, 0, 0.506854,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539612,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373638,-99) , 
12, 0.99227, 0, 0, 0.446981,-99) , 
14, 0.933428, 1, 0, 0.483658,-99) , 
17, 0.475425, 0, 0, 0.502149,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
