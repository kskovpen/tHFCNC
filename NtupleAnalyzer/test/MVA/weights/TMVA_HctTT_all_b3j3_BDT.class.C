// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Sat Oct  8 14:55:00 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 52381
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
IgnoreNegWeightsInTraining: "True" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB           HiggsMass_TOPHLEPBB                                             'D'    [18.9371604919,500]
MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                 MVA_TOPHLEPBB                                                   'D'    [-0.697250723839,0.731746673584]
TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB          TopLepMass_TOPHLEPBB                                            'D'    [84.6946792603,500]
HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB HiggsBJet1HiggsBJet2Dr_TOPHLEPBB                                      'D'    [0.398995548487,5.18255138397]
TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB       TopLepHiggsDr_TOPHLEPBB                                         'D'    [0.049660269171,9.83377933502]
HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB     HiggsBJet1CSVv2_TOPHLEPBB                                       'D'    [0.803021073341,1]
HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB     HiggsBJet2CSVv2_TOPHLEPBB                                       'D'    [0.800004303455,0.999403893948]
TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB     TopLepBJetCSVv2_TOPHLEPBB                                       'D'    [0.800007343292,0.999631464481]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 8 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPHLEPBB", "MVA_TOPHLEPBB", "TopLepMass_TOPHLEPBB", "HiggsBJet1HiggsBJet2Dr_TOPHLEPBB", "TopLepHiggsDr_TOPHLEPBB", "HiggsBJet1CSVv2_TOPHLEPBB", "HiggsBJet2CSVv2_TOPHLEPBB", "TopLepBJetCSVv2_TOPHLEPBB" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.272445881711221);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.967755, 0, 1, 0.763081,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498182,-99) , 
6, 0.970906, 0, 0, 0.574096,-99) , 
7, 0.923594, 0, 0, 0.697645,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417569,-99) , 
6, 0.869634, 0, 0, 0.46619,-99) , 
NN(
0, 
0, 
-1, 0.85695, 0, -1, 0.337395,-99) , 
5, 0.971522, 0, 0, 0.40674,-99) , 
6, 0.932937, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.195863);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.904592, 0, 1, 0.679096,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430464,-99) , 
7, 0.961614, 0, 0, 0.475347,-99) , 
NN(
0, 
0, 
-1, 0.953377, 0, -1, 0.388735,-99) , 
4, 3.32685, 1, 0, 0.443869,-99) , 
6, 0.942433, 0, 0, 0.507927,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.172838);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.961596, 0, 1, 0.728216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482077,-99) , 
4, 3.47839, 1, 0, 0.570554,-99) , 
6, 0.980415, 0, 0, 0.626435,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492064,-99) , 
3, 1.51334, 1, 0, 0.5348,-99) , 
NN(
0, 
0, 
-1, 0.99026, 0, -1, 0.430584,-99) , 
2, 206.256, 0, 0, 0.451704,-99) , 
6, 0.932937, 0, 0, 0.50605,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.130616);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.961596, 0, 1, 0.692696,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491401,-99) , 
7, 0.904622, 0, 0, 0.542115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415518,-99) , 
6, 0.877152, 0, 0, 0.454981,-99) , 
5, 0.98124, 0, 0, 0.50162,-99) , 
6, 0.980413, 0, 0, 0.522158,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.114449);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.199775, 0, 1, 0.664216,-99) , 
NN(
NN(
0, 
0, 
-1, 168.755, 0, 1, 0.538588,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451417,-99) , 
3, 1.08236, 1, 0, 0.467381,-99) , 
5, 0.99062, 0, 0, 0.49587,-99) , 
6, 0.980413, 0, 0, 0.513661,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.0821737);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.199775, 0, 1, 0.63823,-99) , 
NN(
NN(
0, 
0, 
-1, 0.911685, 0, 1, 0.534276,-99) , 
NN(
0, 
0, 
-1, 3.79163, 1, -1, 0.473057,-99) , 
2, 183.577, 0, 0, 0.495761,-99) , 
6, 0.980413, 0, 0, 0.510631,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0854738);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.199775, 0, 1, 0.619049,-99) , 
NN(
NN(
0, 
0, 
-1, 0.990072, 0, 1, 0.536513,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469925,-99) , 
4, 2.86207, 1, 0, 0.483342,-99) , 
6, 0.911685, 0, 0, 0.501066,-99) , 
6, 0.980413, 0, 0, 0.513282,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0764509);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635962,-99) , 
NN(
NN(
0, 
0, 
-1, 0.990126, 0, 1, 0.524016,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43839,-99) , 
0, 120.347, 1, 0, 0.479202,-99) , 
3, 1.99351, 1, 0, 0.505325,-99) , 
6, 0.989909, 0, 0, 0.512815,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.055582);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.618085,-99) , 
NN(
NN(
0, 
0, 
-1, 0.944693, 0, 1, 0.526896,-99) , 
NN(
0, 
0, 
-1, 3.93697, 1, -1, 0.479779,-99) , 
7, 0.990126, 0, 0, 0.494542,-99) , 
6, 0.989909, 0, 0, 0.501572,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0521984);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.199775, 0, 1, 0.57932,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455197,-99) , 
5, 0.906201, 0, 0, 0.505864,-99) , 
NN(
0, 
0, 
-1, 0.942583, 0, -1, 0.457163,-99) , 
4, 3.79163, 1, 0, 0.49732,-99) , 
6, 0.980413, 0, 0, 0.505682,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0467391);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59234,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488764,-99) , 
2, 203.353, 0, 0, 0.497561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434091,-99) , 
1, -0.0848233, 0, 0, 0.49316,-99) , 
6, 0.989909, 0, 0, 0.498753,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0412828);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.90557, 1, 1, 0.563529,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474659,-99) , 
6, 0.825776, 0, 0, 0.504079,-99) , 
NN(
0, 
0, 
-1, 0.885936, 1, -1, 0.456375,-99) , 
1, -0.0167758, 0, 0, 0.498622,-99) , 
6, 0.980413, 0, 0, 0.505216,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0653916);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.974713, 0, 1, 0.60582,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457781,-99) , 
0, 133.476, 1, 0, 0.491746,-99) , 
6, 0.961424, 0, 0, 0.510526,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427799,-99) , 
5, 0.953216, 0, 0, 0.489899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40359,-99) , 
6, 0.951906, 1, 0, 0.465667,-99) , 
7, 0.895066, 0, 0, 0.499642,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0496373);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547612,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47519,-99) , 
4, 2.86207, 1, 0, 0.481519,-99) , 
3, 0.854572, 1, 0, 0.485731,-99) , 
6, 0.980413, 0, 0, 0.491964,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0551767);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.974713, 0, 1, 0.586204,-99) , 
NN(
0, 
0, 
-1, 168.523, 0, -1, 0.488735,-99) , 
6, 0.961424, 0, 0, 0.504674,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452919,-99) , 
3, 2.14908, 1, 0, 0.488906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41709,-99) , 
6, 0.951906, 1, 0, 0.468771,-99) , 
7, 0.895066, 0, 0, 0.495972,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0370458);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.980414, 0, 1, 0.513973,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445275,-99) , 
5, 0.953216, 0, 0, 0.485242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430563,-99) , 
6, 0.951906, 1, 0, 0.469948,-99) , 
7, 0.895066, 0, 0, 0.503309,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0465003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492634,-99) , 
0, 156.384, 0, 0, 0.496465,-99) , 
6, 0.980414, 0, 0, 0.504715,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46126,-99) , 
6, 0.866487, 1, 0, 0.482754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441136,-99) , 
4, 3.40111, 1, 0, 0.469881,-99) , 
7, 0.895066, 0, 0, 0.496282,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0560068);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477964,-99) , 
7, 0.974713, 0, 0, 0.561578,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488097,-99) , 
2, 168.523, 0, 0, 0.503209,-99) , 
6, 0.961424, 0, 0, 0.512693,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459304,-99) , 
7, 0.854327, 0, 0, 0.493903,-99) , 
NN(
0, 
0, 
-1, 0.854322, 1, -1, 0.456908,-99) , 
3, 1.93066, 1, 0, 0.476216,-99) , 
7, 0.895066, 0, 0, 0.50387,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0438282);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471884,-99) , 
7, 0.952096, 0, 0, 0.538124,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497491,-99) , 
0, 87.6604, 1, 0, 0.501931,-99) , 
6, 0.951928, 0, 0, 0.509843,-99) , 
NN(
0, 
0, 
-1, 1.99883, 1, -1, 0.459582,-99) , 
1, -0.0167758, 0, 0, 0.503977,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0436593);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489463,-99) , 
7, 0.895068, 0, 0, 0.512443,-99) , 
1, 0.48224, 0, 0, 0.51602,-99) , 
NN(
0, 
0, 
-1, 1.99883, 1, -1, 0.470485,-99) , 
1, -0.0167758, 0, 0, 0.510709,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0670859);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.913793, 0, 1, 0.564222,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476627,-99) , 
0, 129.114, 1, 0, 0.500708,-99) , 
3, 1.53887, 1, 0, 0.516369,-99) , 
NN(
NN(
0, 
0, 
-1, 0.832556, 0, 1, 0.524935,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449155,-99) , 
7, 0.990109, 0, 0, 0.468352,-99) , 
6, 0.875966, 1, 0, 0.49365,-99) , 
0, 110.568, 0, 0, 0.50672,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0307529);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54404,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488326,-99) , 
6, 0.90852, 0, 0, 0.496192,-99) , 
6, 0.989909, 0, 0, 0.499441,-99) , 
0, 156.384, 0, 0, 0.502606,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0444551);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.99452, 1, 1, 0.549592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492375,-99) , 
3, 1.53887, 1, 0, 0.500645,-99) , 
6, 0.951896, 0, 0, 0.511931,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495579,-99) , 
6, 0.832556, 0, 0, 0.515867,-99) , 
NN(
0, 
0, 
-1, 1.35005, 0, -1, 0.472113,-99) , 
6, 0.875966, 1, 0, 0.491685,-99) , 
0, 110.568, 0, 0, 0.503327,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0202326);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 156.384, 0, 1, 0.508914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471,-99) , 
5, 0.887441, 0, 0, 0.506648,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0205405);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532949,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537651,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502395,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477099,-99) , 
3, 1.25713, 0, 0, 0.497268,-99) , 
1, 0.482326, 0, 0, 0.499851,-99) , 
0, 156.384, 0, 0, 0.502195,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0255983);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527832,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532541,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489929,-99) , 
4, 2.84512, 1, 0, 0.494214,-99) , 
1, 0.482326, 0, 0, 0.496664,-99) , 
0, 156.384, 0, 0, 0.49887,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0259903);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538515,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492299,-99) , 
5, 0.990636, 0, 0, 0.501353,-99) , 
2, 242.906, 0, 0, 0.503745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469202,-99) , 
1, -0.0848233, 0, 0, 0.501321,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0176669);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53205,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48822,-99) , 
4, 3.77694, 1, 0, 0.501984,-99) , 
2, 242.906, 0, 0, 0.503917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475679,-99) , 
1, -0.0848233, 0, 0, 0.501937,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0145305);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52538,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526318,-99) , 
NN(
0, 
0, 
-1, 143.284, 1, -1, 0.495506,-99) , 
1, 0.482326, 0, 0, 0.497474,-99) , 
0, 156.384, 0, 0, 0.499446,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.028209);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499705,-99) , 
6, 0.951896, 0, 0, 0.509674,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476041,-99) , 
3, 1.34815, 0, 0, 0.497312,-99) , 
0, 110.568, 0, 0, 0.504395,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453358,-99) , 
6, 0.904341, 1, 0, 0.485028,-99) , 
1, -0.0167758, 0, 0, 0.502134,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0343299);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54329,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475517,-99) , 
1, 0.0433748, 0, 0, 0.504412,-99) , 
3, 1.31114, 1, 0, 0.510008,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498789,-99) , 
0, 75.6611, 1, 0, 0.506585,-99) , 
NN(
0, 
0, 
-1, 0.961563, 0, -1, 0.463266,-99) , 
6, 0.932937, 1, 0, 0.494334,-99) , 
0, 110.568, 0, 0, 0.503345,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0110612);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525772,-99) , 
NN(
NN(
0, 
0, 
-1, 0.372856, 0, 1, 0.502567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474768,-99) , 
0, 143.284, 1, 0, 0.500817,-99) , 
0, 156.384, 0, 0, 0.502578,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0151635);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523014,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494736,-99) , 
0, 105.193, 0, 0, 0.514663,-99) , 
NN(
0, 
0, 
-1, 143.284, 1, -1, 0.495738,-99) , 
2, 223.13, 0, 0, 0.4984,-99) , 
0, 156.384, 0, 0, 0.500136,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.01459);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 223.13, 0, 1, 0.504916,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458205,-99) , 
3, 1.99883, 1, 0, 0.487287,-99) , 
1, -0.0167758, 0, 0, 0.502859,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0114588);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518552,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515682,-99) , 
NN(
0, 
0, 
-1, 143.284, 1, -1, 0.496364,-99) , 
2, 242.906, 0, 0, 0.498162,-99) , 
0, 156.384, 0, 0, 0.499599,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.00902673);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525765,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499884,-99) , 
3, 0.817216, 1, 0, 0.501614,-99) , 
2, 242.906, 0, 0, 0.503166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48033,-99) , 
1, -0.0848233, 0, 0, 0.501564,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0176272);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.186833, 1, 1, 0.521079,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498703,-99) , 
2, 194.879, 0, 0, 0.503362,-99) , 
2, 144.024, 1, 0, 0.50543,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462231,-99) , 
3, 1.99883, 1, 0, 0.487194,-99) , 
1, -0.0167758, 0, 0, 0.503303,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0194605);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527091,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489656,-99) , 
4, 4.24285, 1, 0, 0.505343,-99) , 
1, 0.48224, 0, 0, 0.506807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463853,-99) , 
1, -0.114021, 0, 0, 0.486789,-99) , 
1, -0.0167758, 0, 0, 0.504472,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0463836);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489665,-99) , 
6, 0.904337, 0, 0, 0.515552,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48862,-99) , 
7, 0.961608, 1, 0, 0.503525,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447489,-99) , 
7, 0.961596, 0, 0, 0.483294,-99) , 
6, 0.942433, 1, 0, 0.498274,-99) , 
1, 0.391509, 0, 0, 0.500749,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0411908);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560863,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485795,-99) , 
7, 0.996011, 0, 0, 0.502339,-99) , 
6, 0.961377, 0, 0, 0.510938,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480905,-99) , 
7, 0.963415, 1, 0, 0.50483,-99) , 
NN(
0, 
0, 
-1, 0.911829, 0, -1, 0.45775,-99) , 
6, 0.961423, 1, 0, 0.495644,-99) , 
7, 0.98062, 0, 0, 0.501928,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0365756);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496145,-99) , 
4, 3.83347, 0, 0, 0.502499,-99) , 
6, 0.970869, 0, 0, 0.508683,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488412,-99) , 
6, 0.922977, 0, 0, 0.498338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449766,-99) , 
6, 0.961423, 1, 0, 0.488244,-99) , 
7, 0.952102, 0, 0, 0.499859,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0431611);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545879,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47916,-99) , 
6, 0.930186, 1, 0, 0.508682,-99) , 
6, 0.970869, 0, 0, 0.513063,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442139,-99) , 
4, 3.90864, 1, 0, 0.502226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452916,-99) , 
6, 0.970918, 1, 0, 0.494169,-99) , 
7, 0.952102, 0, 0, 0.504908,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0248014);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544594,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493817,-99) , 
4, 3.37191, 0, 0, 0.502428,-99) , 
6, 0.970869, 0, 0, 0.507272,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465295,-99) , 
6, 0.970921, 1, 0, 0.495279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466512,-99) , 
4, 3.89622, 1, 0, 0.491116,-99) , 
7, 0.971114, 0, 0, 0.498795,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0285857);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.861035, 1, 1, 0.513575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482244,-99) , 
6, 0.828488, 0, 0, 0.508361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50916,-99) , 
NN(
0, 
0, 
-1, 0.970894, 1, -1, 0.48479,-99) , 
4, 2.74225, 1, 0, 0.488432,-99) , 
7, 0.971114, 0, 0, 0.497903,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0193137);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530601,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5204,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489908,-99) , 
3, 2.11526, 0, 0, 0.494652,-99) , 
0, 156.384, 0, 0, 0.496473,-99) , 
6, 0.989909, 0, 0, 0.498266,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0248204);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490064,-99) , 
5, 0.98113, 0, 0, 0.516443,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496324,-99) , 
0, 156.384, 0, 0, 0.500351,-99) , 
NN(
0, 
0, 
-1, 163.8, 0, -1, 0.47496,-99) , 
3, 2.67688, 1, 0, 0.495949,-99) , 
1, 0.391509, 0, 0, 0.498887,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0208461);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.980388, 0, 1, 0.506656,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493825,-99) , 
1, -0.0556986, 0, 0, 0.51066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45777,-99) , 
6, 0.913967, 1, 0, 0.48967,-99) , 
1, 0.0512717, 0, 0, 0.503448,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0225872);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527429,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49755,-99) , 
0, 87.6604, 1, 0, 0.504882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489361,-99) , 
1, 0.407861, 0, 0, 0.492879,-99) , 
6, 0.872348, 1, 0, 0.498019,-99) , 
6, 0.989909, 0, 0, 0.499561,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.025775);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527244,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493086,-99) , 
6, 0.869166, 1, 0, 0.504519,-99) , 
6, 0.961377, 0, 0, 0.507924,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496003,-99) , 
6, 0.922977, 0, 0, 0.501941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476421,-99) , 
6, 0.961423, 1, 0, 0.496661,-99) , 
7, 0.952102, 0, 0, 0.503063,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0254179);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550648,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494297,-99) , 
4, 3.16707, 1, 0, 0.503789,-99) , 
0, 156.384, 0, 0, 0.506745,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49298,-99) , 
7, 0.961593, 0, 0, 0.504451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469719,-99) , 
1, 0.113896, 0, 0, 0.492609,-99) , 
3, 2.67688, 1, 0, 0.504449,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0233518);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499051,-99) , 
6, 0.904437, 0, 0, 0.512085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469885,-99) , 
6, 0.970919, 1, 0, 0.501096,-99) , 
1, 0.255414, 0, 0, 0.505373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484157,-99) , 
5, 0.887441, 0, 0, 0.504105,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0240574);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.951885, 0, 1, 0.516303,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482462,-99) , 
4, 4.03504, 1, 0, 0.50983,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499978,-99) , 
3, 1.06317, 1, 0, 0.50549,-99) , 
NN(
0, 
0, 
-1, 0.984057, 0, -1, 0.485196,-99) , 
6, 0.91395, 1, 0, 0.497575,-99) , 
1, 0.255414, 0, 0, 0.50235,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0234138);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526551,-99) , 
NN(
NN(
0, 
0, 
-1, 147.507, 1, 1, 0.505568,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478074,-99) , 
7, 0.885615, 1, 0, 0.493773,-99) , 
6, 0.935649, 1, 0, 0.502652,-99) , 
6, 0.989909, 0, 0, 0.5039,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0158267);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520711,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497569,-99) , 
2, 132.723, 1, 0, 0.511675,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494801,-99) , 
2, 228.781, 0, 0, 0.497333,-99) , 
2, 144.024, 1, 0, 0.498996,-99) , 
6, 0.989909, 0, 0, 0.500131,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.024219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494179,-99) , 
2, 169.533, 0, 0, 0.52049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495269,-99) , 
0, 110.568, 1, 0, 0.50025,-99) , 
6, 0.951906, 0, 0, 0.504612,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492004,-99) , 
5, 0.980838, 1, 0, 0.507397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470022,-99) , 
6, 0.913967, 1, 0, 0.492578,-99) , 
1, 0.0512717, 0, 0, 0.502341,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0161306);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.7271, 0, 1, 0.51423,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476366,-99) , 
1, -0.0232759, 0, 0, 0.499225,-99) , 
4, 2.54802, 1, 0, 0.501456,-99) , 
1, 0.391509, 0, 0, 0.503285,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0302461);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49436,-99) , 
3, 2.23927, 1, 0, 0.5088,-99) , 
NN(
0, 
0, 
-1, 168.772, 0, -1, 0.483931,-99) , 
6, 0.837986, 0, 0, 0.50385,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490304,-99) , 
7, 0.952103, 0, 0, 0.50548,-99) , 
NN(
0, 
0, 
-1, 0.904405, 1, -1, 0.478814,-99) , 
3, 1.34815, 0, 0, 0.494956,-99) , 
0, 110.568, 0, 0, 0.500068,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.025382);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515274,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486205,-99) , 
4, 2.84512, 0, 0, 0.508492,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491112,-99) , 
6, 0.9614, 0, 0, 0.495478,-99) , 
3, 2.11526, 0, 0, 0.500178,-99) , 
0, 156.384, 0, 0, 0.501237,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0178241);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519344,-99) , 
NN(
NN(
0, 
0, 
-1, 0.954617, 0, 1, 0.503883,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443981,-99) , 
7, 0.933094, 0, 0, 0.48521,-99) , 
6, 0.970894, 1, 0, 0.501314,-99) , 
4, 2.37921, 1, 0, 0.502399,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0171474);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514894,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497476,-99) , 
6, 0.954617, 0, 0, 0.499427,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44949,-99) , 
3, 1.90557, 1, 0, 0.484751,-99) , 
6, 0.970894, 1, 0, 0.497409,-99) , 
4, 2.37921, 1, 0, 0.498461,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0241989);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.837985, 0, 1, 0.519155,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460462,-99) , 
4, 3.28376, 1, 0, 0.488305,-99) , 
5, 0.952787, 0, 0, 0.506917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498636,-99) , 
6, 0.986744, 0, 0, 0.502021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471302,-99) , 
0, 88.0209, 0, 0, 0.497655,-99) , 
6, 0.866471, 1, 0, 0.501114,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0180711);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.7271, 0, 1, 0.512595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520045,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470539,-99) , 
6, 0.970894, 1, 0, 0.498841,-99) , 
4, 2.54802, 1, 0, 0.500958,-99) , 
1, 0.391509, 0, 0, 0.502623,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0231737);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476836,-99) , 
1, 0.0753894, 0, 0, 0.505933,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493266,-99) , 
2, 223.13, 0, 0, 0.496775,-99) , 
5, 0.99464, 0, 0, 0.500088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483401,-99) , 
5, 0.887441, 0, 0, 0.499089,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0135668);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498157,-99) , 
3, 1.7271, 0, 0, 0.510208,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517709,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474312,-99) , 
6, 0.970894, 1, 0, 0.497262,-99) , 
4, 2.54802, 1, 0, 0.499303,-99) , 
1, 0.391509, 0, 0, 0.500864,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0142968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497722,-99) , 
4, 3.53619, 1, 0, 0.511104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514321,-99) , 
NN(
0, 
0, 
-1, 0.970894, 1, -1, 0.494826,-99) , 
4, 2.54802, 1, 0, 0.496772,-99) , 
1, 0.391509, 0, 0, 0.498823,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0122061);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.7271, 0, 1, 0.511293,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519765,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485499,-99) , 
6, 0.837985, 0, 0, 0.498061,-99) , 
3, 0.854572, 1, 0, 0.499633,-99) , 
1, 0.391509, 0, 0, 0.501301,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0158523);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527137,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497239,-99) , 
3, 1.7271, 0, 0, 0.508243,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539381,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497142,-99) , 
0, 156.384, 0, 0, 0.500281,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462101,-99) , 
2, 163.8, 0, 0, 0.485706,-99) , 
3, 2.67688, 1, 0, 0.49776,-99) , 
1, 0.391509, 0, 0, 0.49926,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0141621);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535471,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482716,-99) , 
7, 0.838034, 0, 0, 0.501294,-99) , 
0, 156.384, 0, 0, 0.503444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494625,-99) , 
2, 167.967, 0, 0, 0.50053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477079,-99) , 
1, 0.113896, 0, 0, 0.492539,-99) , 
3, 2.67688, 1, 0, 0.501676,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0233012);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495298,-99) , 
3, 1.71622, 0, 0, 0.510846,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492949,-99) , 
4, 3.05355, 1, 0, 0.502508,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484072,-99) , 
0, 119.881, 1, 0, 0.493739,-99) , 
3, 1.7666, 1, 0, 0.497868,-99) , 
2, 144.024, 1, 0, 0.499384,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0134952);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495515,-99) , 
1, 0.392328, 0, 0, 0.497729,-99) , 
2, 242.906, 0, 0, 0.499094,-99) , 
3, 0.854572, 1, 0, 0.500316,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0122069);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.19863, 0, 1, 0.512652,-99) , 
NN(
NN(
0, 
0, 
-1, 0.961402, 0, 1, 0.505062,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478588,-99) , 
1, 0.0731549, 0, 0, 0.496141,-99) , 
3, 1.7666, 1, 0, 0.500342,-99) , 
2, 144.024, 1, 0, 0.50178,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0145697);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499483,-99) , 
4, 3.19863, 0, 0, 0.509602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515129,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494115,-99) , 
7, 0.876055, 1, 0, 0.496701,-99) , 
0, 156.633, 0, 0, 0.497988,-99) , 
2, 144.024, 1, 0, 0.499344,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0112144);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.885432, 1, 1, 0.510061,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4993,-99) , 
6, 0.961402, 0, 0, 0.504043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477099,-99) , 
6, 0.961423, 1, 0, 0.496141,-99) , 
3, 1.7666, 1, 0, 0.499862,-99) , 
2, 144.024, 1, 0, 0.501053,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.021375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.44101, 1, 1, 0.520251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494084,-99) , 
6, 0.961402, 0, 0, 0.49904,-99) , 
4, 3.02618, 1, 0, 0.504929,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495198,-99) , 
7, 0.876053, 1, 0, 0.499649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474441,-99) , 
6, 0.980413, 1, 0, 0.496984,-99) , 
3, 1.76573, 1, 0, 0.500717,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0133403);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498968,-99) , 
7, 0.993769, 0, 0, 0.503436,-99) , 
7, 0.876509, 1, 0, 0.504868,-99) , 
NN(
0, 
0, 
-1, 0.894935, 1, -1, 0.48929,-99) , 
7, 0.847537, 0, 0, 0.503164,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.017312);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.970895, 0, 1, 0.508505,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476573,-99) , 
6, 0.961423, 1, 0, 0.499907,-99) , 
3, 2.2213, 1, 0, 0.505753,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483694,-99) , 
6, 0.894935, 1, 0, 0.492624,-99) , 
7, 0.847537, 0, 0, 0.504317,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0247102);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49922,-99) , 
5, 0.995062, 0, 0, 0.513303,-99) , 
NN(
0, 
0, 
-1, 0.885558, 0, -1, 0.493929,-99) , 
6, 0.894941, 0, 0, 0.503547,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49202,-99) , 
5, 0.971522, 1, 0, 0.503994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460625,-99) , 
0, 97.9169, 0, 0, 0.480456,-99) , 
6, 0.932937, 1, 0, 0.49742,-99) , 
0, 110.568, 0, 0, 0.500942,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.018716);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49831,-99) , 
1, 0.245364, 0, 0, 0.503949,-99) , 
3, 1.31114, 1, 0, 0.507131,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498734,-99) , 
0, 75.6611, 1, 0, 0.504501,-99) , 
NN(
0, 
0, 
-1, 97.9169, 0, -1, 0.480865,-99) , 
6, 0.932937, 1, 0, 0.497901,-99) , 
0, 110.568, 0, 0, 0.503206,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0154962);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 188.717, 0, 1, 0.512908,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496354,-99) , 
2, 183.577, 1, 0, 0.50334,-99) , 
0, 133.476, 0, 0, 0.505533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491095,-99) , 
5, 0.887441, 0, 0, 0.504669,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0259683);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530465,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490919,-99) , 
4, 3.2593, 0, 0, 0.501332,-99) , 
1, 0.17722, 0, 0, 0.509918,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478681,-99) , 
6, 0.923445, 1, 0, 0.512794,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4825,-99) , 
5, 0.952899, 0, 0, 0.4975,-99) , 
1, 0.140255, 1, 0, 0.501567,-99) , 
2, 203.353, 0, 0, 0.503398,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.027401);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523992,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490148,-99) , 
7, 0.923534, 0, 0, 0.5029,-99) , 
1, 0.17722, 0, 0, 0.509114,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471154,-99) , 
3, 2.58635, 1, 0, 0.510739,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49181,-99) , 
6, 0.98036, 0, 0, 0.494127,-99) , 
1, 0.140255, 1, 0, 0.498543,-99) , 
2, 203.353, 0, 0, 0.50086,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0156952);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5215,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488182,-99) , 
6, 0.823421, 1, 0, 0.500388,-99) , 
6, 0.854644, 0, 0, 0.509843,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514641,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496541,-99) , 
5, 0.99732, 0, 0, 0.499394,-99) , 
2, 242.906, 0, 0, 0.500813,-99) , 
5, 0.94372, 1, 0, 0.502651,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0190322);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.855263, 0, 1, 0.51053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483457,-99) , 
6, 0.94507, 1, 0, 0.507129,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513416,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468638,-99) , 
4, 3.80661, 1, 0, 0.494665,-99) , 
7, 0.885603, 1, 0, 0.498975,-99) , 
5, 0.99062, 1, 0, 0.503461,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0274722);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517381,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492079,-99) , 
6, 0.925649, 1, 0, 0.508855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485402,-99) , 
5, 0.972753, 0, 0, 0.49482,-99) , 
6, 0.854404, 0, 0, 0.503567,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489015,-99) , 
2, 168.755, 0, 0, 0.500568,-99) , 
NN(
0, 
0, 
-1, 3.18453, 0, -1, 0.483299,-99) , 
5, 0.99509, 0, 0, 0.495487,-99) , 
5, 0.99062, 1, 0, 0.499932,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0256094);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488959,-99) , 
6, 0.935681, 1, 0, 0.506672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47343,-99) , 
5, 0.963889, 0, 0, 0.491057,-99) , 
7, 0.885561, 0, 0, 0.503508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487335,-99) , 
6, 0.923446, 0, 0, 0.499763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478671,-99) , 
0, 87.9591, 0, 0, 0.496776,-99) , 
5, 0.99062, 1, 0, 0.500479,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.01341);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.928866, 0, 1, 0.504891,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493524,-99) , 
4, 3.83347, 0, 0, 0.496245,-99) , 
7, 0.961608, 1, 0, 0.500289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487253,-99) , 
6, 0.980413, 1, 0, 0.499045,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0215417);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479524,-99) , 
1, -0.0227729, 0, 0, 0.502962,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476557,-99) , 
4, 2.59647, 1, 0, 0.491409,-99) , 
4, 2.86207, 0, 0, 0.500823,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484389,-99) , 
7, 0.849799, 0, 0, 0.500551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480585,-99) , 
2, 163.8, 0, 0, 0.493403,-99) , 
7, 0.895066, 0, 0, 0.499037,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0148293);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491888,-99) , 
3, 1.71622, 0, 0, 0.505287,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509846,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493555,-99) , 
1, -0.0165151, 1, 0, 0.49469,-99) , 
0, 156.633, 0, 0, 0.495748,-99) , 
2, 144.024, 1, 0, 0.496862,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00940453);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498727,-99) , 
4, 3.28024, 0, 0, 0.510957,-99) , 
NN(
0, 
0, 
-1, 0.899613, 0, -1, 0.497548,-99) , 
7, 0.876055, 1, 0, 0.499957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491245,-99) , 
6, 0.980413, 1, 0, 0.499125,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.00862552);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.14908, 0, 1, 0.511629,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483528,-99) , 
7, 0.899613, 0, 0, 0.499899,-99) , 
7, 0.876055, 1, 0, 0.502006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493596,-99) , 
6, 0.980413, 1, 0, 0.501204,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0187492);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52661,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489718,-99) , 
0, 112.062, 0, 0, 0.511171,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492391,-99) , 
6, 0.872335, 1, 0, 0.498069,-99) , 
6, 0.951906, 0, 0, 0.500878,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511525,-99) , 
NN(
0, 
0, 
-1, 0.904341, 1, -1, 0.485696,-99) , 
4, 2.98023, 1, 0, 0.49466,-99) , 
1, 0.0512717, 0, 0, 0.499706,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0228613);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492295,-99) , 
3, 2.45579, 1, 0, 0.509456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467972,-99) , 
0, 88.508, 0, 0, 0.503768,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513702,-99) , 
NN(
0, 
0, 
-1, 1.9471, 0, -1, 0.493305,-99) , 
0, 87.6604, 1, 0, 0.496699,-99) , 
6, 0.904452, 0, 0, 0.499719,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00883013);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499195,-99) , 
3, 2.14908, 0, 0, 0.511298,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498721,-99) , 
0, 156.384, 0, 0, 0.500071,-99) , 
7, 0.876055, 1, 0, 0.502088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493729,-99) , 
6, 0.980413, 1, 0, 0.501291,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0112709);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.28024, 0, 1, 0.511882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49336,-99) , 
6, 0.937456, 1, 0, 0.501963,-99) , 
7, 0.876055, 1, 0, 0.503744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495936,-99) , 
6, 0.980413, 1, 0, 0.503,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0258242);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494261,-99) , 
6, 0.970477, 1, 0, 0.512288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472329,-99) , 
5, 0.978249, 0, 0, 0.505206,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493634,-99) , 
5, 0.962161, 1, 0, 0.501119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483397,-99) , 
4, 4.25641, 1, 0, 0.499618,-99) , 
6, 0.923442, 0, 0, 0.501509,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.020119);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536811,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498729,-99) , 
6, 0.866476, 1, 0, 0.503221,-99) , 
4, 4.24285, 0, 0, 0.505965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490129,-99) , 
7, 0.961614, 1, 0, 0.502201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467502,-99) , 
4, 3.5555, 1, 0, 0.493821,-99) , 
5, 0.9531, 0, 0, 0.503036,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0180039);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.24285, 0, 1, 0.507447,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492097,-99) , 
7, 0.980622, 1, 0, 0.502708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472513,-99) , 
4, 3.5555, 1, 0, 0.495418,-99) , 
5, 0.9531, 0, 0, 0.504546,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0228915);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497038,-99) , 
7, 0.904562, 0, 0, 0.510262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477437,-99) , 
0, 88.508, 0, 0, 0.505764,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496369,-99) , 
7, 0.904572, 1, 0, 0.50145,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506783,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47495,-99) , 
7, 0.971086, 0, 0, 0.49065,-99) , 
2, 188.022, 1, 0, 0.497942,-99) , 
6, 0.904452, 0, 0, 0.501284,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0119163);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.976798, 1, 1, 0.515451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49187,-99) , 
2, 163.8, 0, 0, 0.507211,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517984,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48406,-99) , 
7, 0.857045, 0, 0, 0.498625,-99) , 
3, 2.90467, 0, 0, 0.500498,-99) , 
6, 0.951928, 0, 0, 0.501951,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0155151);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497748,-99) , 
2, 169.533, 0, 0, 0.512681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487524,-99) , 
1, 0.0923559, 0, 0, 0.506315,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493382,-99) , 
1, 0.148752, 1, 0, 0.496379,-99) , 
3, 2.90467, 0, 0, 0.498181,-99) , 
6, 0.951928, 0, 0, 0.499942,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
